<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>978. 最长湍流子数组</title>
      <link href="2020/10/26/leetcode/2020/978.zui-chang-tuan-liu-zi-shu-zu/"/>
      <url>2020/10/26/leetcode/2020/978.zui-chang-tuan-liu-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. 合并区间</title>
      <link href="2020/10/22/leetcode/2020/56.he-bing-qu-jian/"/>
      <url>2020/10/22/leetcode/2020/56.he-bing-qu-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</p><p>输出: [[1,6],[8,10],[15,18]]</p><p>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: intervals = [[1,4],[4,5]]</p><p>输出: [[1,5]]</p><p>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><p>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</p><p>提示：</p><p>$intervals[i][0] &lt;= intervals[i][1]$</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/merge-intervals">https://leetcode-cn.com/problems/merge-intervals</a></p><p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个题比较简单，首先按照区间的左区间进行排序，判断每个区间的右区间是否小于下一个区间的左区间，维护两个指针 $low$ 和 $high$。</p><p>如果小于：说明这两个区间可以合并 $high = max(high, intervals[i][1])$</p><p>如果大于：说明这两个区间不可以合并 $low = intervals[i][0], high = intervals[i][1]$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> merge(vector<vector<int>>& intervals) {        vector<vector<int>> ans;        if (intervals.empty()) {            return ans;        }        // c++的lambda表达式        auto cmp = [=](const vector<int> &a, const vector<int> &b) { return a[0] < b[0]; };        // sort函数第三个参数接受一个谓词，这个谓词可以是lambda，也可以是函数指针，也可以是函数对象（即重载()的对象）        sort(intervals.begin(), intervals.end(), cmp);        int size = intervals.size();        int low = intervals[0][0], high = intervals[0][1];        for (int i = 1; i < size; ++i) {            if (intervals[i][0] <= high) {                high = max(intervals[i][1], high);            } else {                ans.push_back({low, high});                low = intervals[i][0];                high = intervals[i][1];            }        }        ans.push_back({low, high});        return ans;    }};</code></pre><ul><li>Python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def merge(self, intervals: List[List[int]]) -> List[List[int]]:        ans = []        if len(intervals) == 0:            return ans        intervals.sort(key=lambda x : x[0])        low, high = intervals[0][0], intervals[0][1]        for i in range(1, len(intervals)):            if high >= intervals[i][0]:                high = max(high, intervals[i][1])            else:                ans.append([low, high])                low = intervals[i][0]                high = intervals[i][1]        ans.append([low, high])        return ans</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>763. 划分字母区间</title>
      <link href="2020/10/22/leetcode/2020/763.hua-fen-zi-mu-qu-jian/"/>
      <url>2020/10/22/leetcode/2020/763.hua-fen-zi-mu-qu-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：S = “ababcbacadefegdehijhklij”</p><p>输出：[9,7,8]</p><p>解释：</p><p>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。</p><p>每个字母最多出现在一个片段中。</p><p>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/partition-labels">https://leetcode-cn.com/problems/partition-labels</a></p><p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>'a'</code> 到 <code>'z'</code>。</li></ul></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用 <code>unordered_map</code> 记录每个字母的最远位置，接着遍历整个字符串，维护一个起始距离 $low$ 和最远的距离 $high$，如果 $i == high $ 说明该区间结束，更新 $low$ 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>C++</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> partitionLabels(string S) {        int size = S.size();        vector<int> ans;        unordered_map<char, int> mp;        for (int i = 0; i < size; ++i) {            // 记录每个单词最后的位置            mp[S[i]] = i;        }        int low = 0, high = 0;        for (int i = 0; i < size; ++i) {            high = max(high, mp[S[i]]);            if (i == high) {                // 如果 i == high 说明到了最后一个位置                ans.emplace_back(high - low + 1);                // 更新low                low = i + 1;            }        }        return ans;    }};</code></pre><ul><li>Python</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def partitionLabels(self, S: str) -> List[int]:        mp = {}        ans = []        for i in range(0, len(S)):            mp[S[i]] = i        low, high = 0, 0        for i in range(0, len(S)):            high = max(high, mp[S[i]])            if i == high:                ans.append(high - low + 1)                low = i + 1        return ans</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬取必应壁纸</title>
      <link href="2020/10/13/python/2020/python-pa-qu-bi-ying-bi-zhi/"/>
      <url>2020/10/13/python/2020/python-pa-qu-bi-ying-bi-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个喜欢折腾的人，长期看到桌面只有一种壁纸，就想着自己从网上爬取一些壁纸，存下来，随机切换壁纸。</p><p>本文仅供学习交流。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>Python3 + requests + re</strong></p><p><strong>Fiddler</strong> 抓包工具。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>必应官网好像无法使用 <strong>Ctrl + U</strong> 查看源代码和 <strong>Ctrl + Shift + I或者F12</strong> 打开控制台。</p><p>通过 <strong>Fiddler</strong> 进行抓包。</p><p>发现就这两个请求</p><p><img src="https://gitee.com/incipe-win/images/raw/master/20201013233758.png" alt=""></p><p>那么可以肯定，图片的 <strong>url</strong> 肯定就在网页源代码里面。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201013234416095.png" alt=""></p><p>我们可以在源代码中看到我们想要的图片 <strong>url</strong></p><p>通过正则进行抓取即可。</p><pre class=" language-lang-python"><code class="language-lang-python">import requestsimport threadingimport jsonimport refrom pprint import pprintimport timeclass Bing:    def __init__(self):        self.url = "https://bing.ioliu.cn/?p={}"        self.headers = {            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36"}    def parse_url(self, url):        print("*" * 20)        response = requests.get(url, headers=self.headers)        return response.content    def regular_img_name(self, img_url):        ret = re.findall(            r"http://h.\.ioliu.cn/bing/(.*?)\.(.*?)$", img_url, re.M | re.S)        print(ret)        return ret    def download_imgs(self, img_list):        for url in img_list:            img = self.parse_url(url)            time.sleep(1)            print(url)            strs = self.regular_img_name(url)            with open("./bing/{}.{}".format(strs[0][0], strs[0][1]), "wb") as f:                f.write(img)            print("{} success".format(url))    def regular_img_url(self, html_str):        ret = re.findall(r".*?pic=(.*?)\?imageslim.*?", html_str, re.M | re.S)        return ret    def run(self):        for i in range(1, 10):            url = self.url.format(i)            html_str = self.parse_url(url).decode()            img_list = self.regular_img_url(html_str)            print(img_list)            self.download_imgs(img_list)if __name__ == "__main__":    bing = Bing()    bing.run()</code></pre><p>可以改进为多线程爬虫版本~</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201021183614746.png" alt=""></p><p>注意：跑代码之前要在当前代码路径建立一个叫 <strong>bing</strong> 的文件夹~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写完代码后发现：</p><p>必应壁纸好像提供了官方接口的~</p><pre class=" language-lang-html"><code class="language-lang-html">http://cn.bing.com/HPImageArchive.aspx?idx=0&n=1</code></pre><p>只要在解析出的 <strong>url</strong> 前面加上 <code>http://www.bing.com</code> 就好了。</p><p>网络爬虫的代码不一定一直可用， 代码要根据实际情况进行更改，不可一概论之！</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCP 12. 小张刷题计划</title>
      <link href="2020/10/02/leetcode/2020/lcp-12.xiao-zhang-shua-ti-ji-hua/"/>
      <url>2020/10/02/leetcode/2020/lcp-12.xiao-zhang-shua-ti-ji-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，编号从 0 到 n-1，并计划在 m 天内按照题目</p><p>编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。</p><p>在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，</p><p>可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。</p><p>我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。</p><p>示例 1：</p><p>输入：time = [1,2,3,3], m = 2</p><p>输出：3</p><p>解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。</p><p>示例 2：</p><p>输入：time = [999,999,999], m = 4</p><p>输出：0</p><p>解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。</p><p>限制：</p><p>1 &lt;= time.length &lt;= 10^5</p><p>1 &lt;= time[i] &lt;= 10000</p><p>1 &lt;= m &lt;= 1000</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua">https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Ⅰ-这是一类题"><a href="#Ⅰ-这是一类题" class="headerlink" title="Ⅰ. 这是一类题"></a>Ⅰ. 这是一类题</h3><p>最大化最小值，最大化平均值，最小化最大值……</p><p><a href="https://blog.csdn.net/yxnd150150/article/details/53391202">如何理解最大化最小值问题和最小化最大值问题</a></p><p>这类题主要的方法就是二分答案/搜索。</p><h3 id="Ⅱ-类似的题目"><a href="#Ⅱ-类似的题目" class="headerlink" title="Ⅱ. 类似的题目"></a>Ⅱ. 类似的题目</h3><p><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></p><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a></p><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p><p><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力</a></p><h3 id="Ⅲ-代码"><a href="#Ⅲ-代码" class="headerlink" title="Ⅲ. 代码"></a>Ⅲ. 代码</h3><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    bool check(int mid, int m, vector<int> &time) {        // 所用天数, 总用时, 题耗时最多        // 这里用了贪心的思想, 耗时最多的那个题目, 就场外求助        int days = 1, total = 0, maxCost = 0;        // 每天的场外求助是否被使用        bool use = true;        int size = time.size();        for (int i = 0; i < size; ++i) {            // 维护那个耗时最长的题的花费时间            maxCost = max(maxCost, time[i]);            // 总用时            total += time[i];            // 如果大于我给定的时间了            if (total > mid) {                // 如果有场外求助, 说明我今天还可以多解决一道题                if (use) {                    total -= maxCost;                    use = false;                } else {                    // 如果没有场外求助, 开启下一天, 所有信息清空                    ++days;                    total = 0;                    maxCost = 0;                    --i;                    use = true;                }            }            // 如果天数大于m了, 说明一天只有mid的时间不够, 返回false            if (days > m) {                return false;            }        }        return true;    }public:    int minTime(vector<int>& time, int m) {        int left = 0, right = 0;        // 左边界=>0, 右边界=>所有题的总时间        for (auto &it : time) {            right += it;        }        while (left <= right) {            int mid = left + (right - left) / 2;            // 每天用mid的时间可以完成吗？            if (check(mid, m, time)) {                // 如果可以完成, 说明时间还可以减少                right = mid - 1;            } else {                // 如果不能完成, 说明时间不够                left = mid + 1;            }        }        return left;    }};</code></pre><ul><li>Python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def check(self, mid, m, time):        use = True        days, total, maxCost = 1, 0, 0        size = len(time)        i = 0        while i < size:            maxCost = max(maxCost, time[i])            total += time[i]            if total > mid:                if use:                    total -= maxCost                    use = False                else:                    days += 1                    i -= 1                    use, total, maxCost = True, 0, 0            i += 1            if days > m:                return False        return True    def minTime(self, time: List[int], m: int) -> int:        left, right = 0, sum(time)        while left <= right:            mid = (left + right) // 2            if self.check(mid, m, time):                right = mid - 1            else:                left = mid + 1        return left</code></pre><p><strong>特别注意：Python中在 <code>for in range(size)</code> 中修改i的值是没有作用的，也强烈建议不要这样子做</strong></p><p>原因是因为 <code>for</code> 循环每次结束 <code>i</code> 都会被重新赋值。</p><p><a href="https://www.quora.com/Why-can%E2%80%99t-you-modify-lists-through-for-in-loops-in-Python">Why can’t you modify lists through “for in” loops in Python?</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是要多练习，做多了就好了，其余几道题解后面补上~</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中等 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="2020/10/01/linux/2020/git-shi-yong-chao-xiang-xi/"/>
      <url>2020/10/01/linux/2020/git-shi-yong-chao-xiang-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>读完本文，你将了解git的常用操作。</p><p>注：本文不介绍git历史，也不介绍如何安装git，更不介绍如何使用github。</p><p>有需要的读者可以参考 <a href="https://blog.csdn.net/qq_43826212/article/details/100023631?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160139441419724836744898%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=160139441419724836744898&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_v1-1-100023631.pc_v2_rank_blog_v1&amp;utm_term=git&amp;spm=1018.2118.3001.4187">同时推送代码至github和gitee</a></p></blockquote><h2 id="Ⅰ-基本操作"><a href="#Ⅰ-基本操作" class="headerlink" title="Ⅰ. 基本操作"></a>Ⅰ. 基本操作</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><pre class=" language-lang-bash"><code class="language-lang-bash">mkdir gitcd gitgit initInitialized empty Git repository in /home/incipe/Desktop/git/.git/ls -a.  ..  .git</code></pre><h3 id="添加到版本库"><a href="#添加到版本库" class="headerlink" title="添加到版本库"></a>添加到版本库</h3><pre class=" language-lang-bash"><code class="language-lang-bash">touch first.mdecho "Hello git" > first.mdcat first.md  Hello gitgit add first.mdgit commit -m "first commit" [master (root-commit) ff57502] first commit  1 file changed, 1 insertion(+)  create mode 100644 first.md</code></pre><p><code>git commit</code> <code>-m</code> 后输入本次的提交信息，可以输入任何内容，最好是有意义的。</p><p>查看版本记录。</p><pre class=" language-lang-bash"><code class="language-lang-bash">git log # git log --graph --pretty=onelinecommit ff57502578c70c7fc5225e1fc5aa0b6dfe6d86fc (HEAD -> master)Author: Incipe-win <xxxxxx@163.com>Date:   Thu Oct 1 19:50:09 2020 +0800    first commit</code></pre><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>我们在 <strong>first.md</strong> 增加如下内容：</p><pre class=" language-lang-bash"><code class="language-lang-bash">cat first.md Hello gitThat's the second line</code></pre><p>再次使用 <code>git commit -m</code> 提交。</p><pre class=" language-lang-bash"><code class="language-lang-bash">git add first.mdgit commit first.md [master f732109] second commit 1 file changed, 1 insertion(+)git logcommit f732109700ff998f243b67fef59976bf0c7c7ace (HEAD -> master)Author: Incipe-win <xxxx@163.com>Date:   Thu Oct 1 20:05:53 2020 +0800    second commitcommit ff57502578c70c7fc5225e1fc5aa0b6dfe6d86fcAuthor: Incipe-win <xxxx@163.com>Date:   Thu Oct 1 19:50:09 2020 +0800    first commit</code></pre><p>回退到第一次提交时的内容：</p><pre class=" language-lang-bash"><code class="language-lang-bash">git reset --hard HEAD^HEAD is now at ff57502 first commitcat first.mdHello git</code></pre><p>这个过程是这样的，有一个 <code>HEAD</code> 指针指向最新提交的那个版本，<code>^</code> 表示回到上一个版本，<code>^^</code> 表示上上个，有多少个  <code>^</code>  就表示回退到第几个版本，也可以用数字代替，比如：<code>git reset --hard HEAD~1</code> 后面这个数字表示回到第几个版本。</p><p>后面还可以接版本序列号。</p><p>如果，此时我想回到版本二应该怎么做，<code>git rest --hard f732109700ff998f243b67fef59976bf0c7c7ace</code> ，这串字符就是版本序列号，可以不要复制全部，只复制一部分也是可以的，跟这个命令等价 <code>git rest --hard f732109</code>  </p><p>如果找不到版本序列号应该怎么回到版本二呢？</p><pre class=" language-lang-bash"><code class="language-lang-bash">git reflogff57502 (HEAD -> master) HEAD@{0}: reset: moving to HEAD^f732109 HEAD@{1}: commit: second commitff57502 (HEAD -> master) HEAD@{2}: reset: moving to HEADff57502 (HEAD -> master) HEAD@{3}: reset: moving to HEADff57502 (HEAD -> master) HEAD@{4}: commit (initial): first commitgit reset --hard f732109     HEAD is now at f732109 second commitcat first.md Hello gitThat's the second line</code></pre><p> <code>git reflog</code> 查看所有的操作记录。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE1.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.png" alt=""></p><p>每次提交，回退都是 <code>HEAD</code> 指针的修改。</p><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>查看当前工作树状态，  <code>git status</code> </p><pre class=" language-lang-bash"><code class="language-lang-bash">cat first.md Hello git# 给first.md增加如下内容，但不提交cat first.md Hello gitWhere there is a will, there is a waygit statusOn branch masterChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git restore <file>..." to discard changes in working directory)    modified:   first.mdno changes added to commit (use "git add" and/or "git commit -a")# 这里会给个提示，告诉我修改了fitst.md 内容，但是没有提交。git add first.mdgit statusOn branch masterChanges to be committed:  (use "git restore --staged <file>..." to unstage)    modified:   first.mdgit commit -m "version 3"[master c6ea42a] version 3 1 file changed, 1 insertion(+)git statusOn branch masternothing to commit, working tree clean</code></pre><p>总的来讲，我们操作的目录就叫工作区，<code>git add</code> 就是把工作区的文件体检到暂存区， <code>git commit -m</code> 就是把暂存区所有的修改记录创建一个版本记录。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/w1.png" alt=""></p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><pre class=" language-lang-bash"><code class="language-lang-bash">cat first.md Hello gitWhere there is a will, there is a waycat first.md Hello gitWhere there is a will, there is a wayThis is the third linegit statusOn branch masterChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git restore <file>..." to discard changes in working directory)    modified:   first.mdno changes added to commit (use "git add" and/or "git commit -a")git restore first.md cat first.md Hello gitWhere there is a will, there is a way</code></pre><h3 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h3><pre class=" language-lang-bash"><code class="language-lang-bash">ls -lart total 20drwxr-xr-x 3 incipe incipe 4096 10月  1 19:44 ..-rw-rw-r-- 1 incipe incipe   48 10月  1 21:07 first.md-rw-rw-r-- 1 incipe incipe   66 10月  1 21:10 second.mddrwxrwxr-x 3 incipe incipe 4096 10月  1 21:10 .drwxrwxr-x 8 incipe incipe 4096 10月  1 21:10 .gitcat first.md Hello gitWhere there is a will, there is a waycat second.md Hello gitWhere there is a will, there is a wayThis is new linegit statusOn branch masterChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git restore <file>..." to discard changes in working directory)    modified:   second.mdno changes added to commit (use "git add" and/or "git commit -a")git diff HEAD -- second.mddiff --git a/second.md b/second.mdindex f9c6e01..6e93719 100644--- a/second.md+++ b/second.md@@ -1,3 +1,4 @@ Hello git Where there is a will, there is a way+This is new linegit diff HEAD HEAD^ -- second.mddiff --git a/second.md b/second.mddeleted file mode 100644index f9c6e01..0000000--- a/second.md+++ /dev/null@@ -1,3 +0,0 @@-Hello git-Where there is a will, there is a way-</code></pre><p>每个版本的文件前面有 <code>+ -</code> 两个符号，相应的，文件内容出现那个符号，就表示是哪个文件说拥有的，如果没有，就代表是都有的。</p><h2 id="Ⅱ-分支操作"><a href="#Ⅱ-分支操作" class="headerlink" title="Ⅱ. 分支操作"></a>Ⅱ. 分支操作</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre class=" language-lang-bash"><code class="language-lang-bash">git checkout -b devSwitched to a new branch 'dev'# <=># git branch dev# git checkout devgit branch* dev  master</code></pre><p><img src="https://gitee.com/incipe-win/images/raw/master/branch.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/fdd.png" alt=""></p><p>合并分支，<code>git</code> 默认会采用快速合并的方法，如果不想采用的话，可以使用 <code>git merge --no-ff -m "合并信息" 分支</code></p><pre class=" language-lang-bash"><code class="language-lang-bash"># 切换回mastergit checkout masterM    second.mdSwitched to branch 'master'git merge devAlready up to date.git branch -d devDeleted branch dev (was 24df10d).git branch* master</code></pre><p><img src="https://gitee.com/incipe-win/images/raw/master/wds.png" alt=""></p><h3 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h3><p>比如下图，在 <code>dev</code> 分支上对某个文件进行了修改并且进行了提交，切换回 <code>master</code> 分支又对这个文件进行修改并且进行了提交，然后合并分支会导致冲突。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/wfdfd.png" alt=""></p><p>手动解决冲突即可。这个时候合并分支会出现如下信息：</p><pre class=" language-lang-bash"><code class="language-lang-bash">Auto-merging second.mdCONFLICT (content): Merge conflict in second.mdAutomatic merge failed; fix conflicts and then commit the result.vim second.mdHello gitWhere there is a will, there is a way<<<<<<< HEADThis is a new line=======This is third line>>>>>>> dev# 修改为Hello gitWhere there is a will, there is a wayThis is a new lineThis is third line# 手动提交git add second.mdgit commit -m "解决冲突"[master b75d71c] 解决冲突git log --graph --pretty=oneline*   b75d71c42798ca48cf869cf6a0c3709c4dc8127e (HEAD -> master) 解决冲突|\  | * f0bc35a5b50666bf709a0c510f7ab73f81d4cdb1 (dev) dev* | 51d0b83dd8be9b3593f1effaaab82f54dd7b636c master|/  * 6f2fc2d87aa23e9a5e82746497f7001c7a0e36ea update</code></pre><p>如果是这种情况，在 <code>dev</code> 分支上，建立了新的文件，进行提交，切换回 <code>master</code> 分支在创建的文件夹里面进行添加，最后合并分支，不会报错，<code>git</code> 会手动帮我们进行一次新的提交。</p><h2 id="Ⅲ-总结"><a href="#Ⅲ-总结" class="headerlink" title="Ⅲ. 总结"></a>Ⅲ. 总结</h2><p><code>git</code> 用法挺多的，这里罗列了一部分常用的东西，记录下来，方便日后查找用法直接定位。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决使用代理软件后win10自带应用无法联网的问题</title>
      <link href="2020/09/29/software/2020/jie-jue-shi-yong-dai-li-ruan-jian-hou-win10-zi-dai-ying-yong-wu-fa-lian-wang-de-wen-ti/"/>
      <url>2020/09/29/software/2020/jie-jue-shi-yong-dai-li-ruan-jian-hou-win10-zi-dai-ying-yong-wu-fa-lian-wang-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>使用clash for windows软件，里面有个 <strong>UWP Loopback</strong></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200929225152288.png" alt="image-20200929225152288"></p><p>点击一下，会弹出这个界面。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200929225256212.png" alt="image-20200929225256212"></p><p>然后你想让哪个软件走代理，就选中哪个软件，最后点击 <strong>Save Changes</strong> 即可。</p><p>特别注意：第一个选项不能打勾，否则设置没有作用的。</p><h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><p>使用 <strong>Fiddler</strong> 软件，左上角有个 <strong>WinConfig</strong> ，点击一下，也会出现这个弹窗。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200929225256212.png" alt="image-20200929225256212"></p><p>按照方案一的操作进行即可解决！！！</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GEC6818音乐播放器制作</title>
      <link href="2020/09/28/iot/2020/gec6818-yin-le-bo-fang-qi-zhi-zuo/"/>
      <url>2020/09/28/iot/2020/gec6818-yin-le-bo-fang-qi-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><pre class=" language-lang-bash"><code class="language-lang-bash"># linux操作系统uname -aLinux incipe-virtual-machine 5.4.0-31-generic #35-Ubuntu SMP Thu May 7 20:20:34 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux# 交叉编译器arm-linux-gcc -vUsing built-in specs.Target: arm-none-linux-gnueabiConfigured with: /opt/FriendlyARM/mini2440/build-toolschain/working/src/gcc-4.4.3/configure --build=i386-build_redhat-linux-gnu --host=i386-build_redhat-linux-gnu --target=arm-none-linux-gnueabi --prefix=/opt/FriendlyARM/toolschain/4.4.3 --with-sysroot=/opt/FriendlyARM/toolschain/4.4.3/arm-none-linux-gnueabi//sys-root --enable-languages=c,c++ --disable-multilib --with-arch=armv4t --with-cpu=arm920t --with-tune=arm920t --with-float=soft --with-pkgversion=ctng-1.6.1 --disable-sjlj-exceptions --enable-__cxa_atexit --with-gmp=/opt/FriendlyARM/toolschain/4.4.3 --with-mpfr=/opt/FriendlyARM/toolschain/4.4.3 --with-ppl=/opt/FriendlyARM/toolschain/4.4.3 --with-cloog=/opt/FriendlyARM/toolschain/4.4.3 --with-mpc=/opt/FriendlyARM/toolschain/4.4.3 --with-local-prefix=/opt/FriendlyARM/toolschain/4.4.3/arm-none-linux-gnueabi//sys-root --disable-nls --enable-threads=posix --enable-symvers=gnu --enable-c99 --enable-long-long --enable-target-optspaceThread model: posixgcc version 4.4.3 (ctng-1.6.1)</code></pre><p>开发板 <strong>GEC6818</strong> ，<a href="https://blog.csdn.net/qq_41768362/article/details/96891717">详情介绍</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Ⅰ-总体框架"><a href="#Ⅰ-总体框架" class="headerlink" title="Ⅰ. 总体框架"></a>Ⅰ. 总体框架</h3><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200928220250419.png" alt="image-20200928220250419"></p><h3 id="Ⅱ-目录结构"><a href="#Ⅱ-目录结构" class="headerlink" title="Ⅱ. 目录结构"></a>Ⅱ. 目录结构</h3><pre class=" language-lang-bash"><code class="language-lang-bash">.├── include│   ├── get_touch.h│   ├── lcd.h│   ├── play_music.h│   ├── show_bmp.h│   └── ts_init.h├── Makefile├── README.md└── sources    ├── lcd.c    ├── main.c    ├── play_music.c    ├── show_bmp.c    └── ts_init.c</code></pre><h3 id="Ⅲ-流程图"><a href="#Ⅲ-流程图" class="headerlink" title="Ⅲ. 流程图"></a>Ⅲ. 流程图</h3><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200928220610937.png" alt="image-20200928220610937"></p><h3 id="Ⅳ-需要用的知识"><a href="#Ⅳ-需要用的知识" class="headerlink" title="Ⅳ.  需要用的知识"></a>Ⅳ.  需要用的知识</h3><ol><li>Linux系统API，可以参考此文，<a href="https://blog.csdn.net/qq_43826212/article/details/106106508">你会linux系统API吗？</a></li><li>Makefile文件编写，可以参考此文，<a href="https://blog.csdn.net/qq_43826212/article/details/105973943">简简单单学会写makefile</a></li><li>交叉编译开发</li><li>如果没有安装 <strong>madplay</strong> ，还要源码编译安装 <strong>madplay</strong> ，这个后面有空补上。</li><li>markdown使用语法，可以参考，<a href="https://markdown-zh.readthedocs.io/en/latest/">Markdown: 语法</a></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>接下来详细讲解每个模块的具体功能与作用。</p><h3 id="Ⅰ-LCD模块"><a href="#Ⅰ-LCD模块" class="headerlink" title="Ⅰ. LCD模块"></a>Ⅰ. LCD模块</h3><p>LCD是GEC6818的显示屏，要想展示图片就必须打开LCD显示屏。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>// lcd 文件描述符int fd = 0;// 共享映射区首地址unsigned int *plcd = NULL;/** *  打开lcd屏幕和共享映射区 * */void lcd_init() {  fd = open("/dev/fb0", O_RDWR);  if (fd == -1) {    perror("lcd open error: ");    exit(-1);  }  // 打开共享映射区  plcd = (unsigned int *)mmap(NULL, 800 * 480 * 4, PROT_READ | PROT_WRITE,                              MAP_SHARED, fd, 0);  if (plcd == MAP_FAILED) {    perror("mmap error: ");    exit(-1);  }}/** *  关闭lcd屏幕和映射区 * */void lcd_uninit() {  // 关闭共享映射区  munmap(plcd, 800 * 480 * 4);  // 关闭文件描述符  close(fd);}</code></pre><p>打开映射区的目的是为了加快显示图片的速度，直接使用 <code>write</code> 函数也是可以的。</p><h3 id="Ⅱ-显示图片模块"><a href="#Ⅱ-显示图片模块" class="headerlink" title="Ⅱ. 显示图片模块"></a>Ⅱ. 显示图片模块</h3><p>在这之前先简单介绍下 <strong>bmp</strong> 图片的存储格式。</p><p>BMP文件通常是不压缩的，通常比同一幅图像的压缩图像文件格式要大很多。可以参考<a href="https://baike.baidu.com/item/BMP%E6%A0%BC%E5%BC%8F/3427000">百度百科</a> ，这里只介绍存储格式。</p><h4 id="BMP文件组成"><a href="#BMP文件组成" class="headerlink" title="BMP文件组成"></a>BMP文件组成</h4><ol><li>BMP文件头，14字节，BMP文件的类型、文件大小和位图起始位置等信息。</li><li>位头信息，40字节。</li><li>颜色表，可用索引来表示图像。</li><li>位图数据，即图像数据。</li></ol><p><img src="https://gitee.com/incipe-win/images/raw/master/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="文件格式"></p><center>图片来源：粤嵌课设老师</center><p>例如，偏移量从 <code>0x02 ~ 0x05</code> 表示图片大小，<code>0x12 ~ 0x15</code> 表示图片宽， <code>0x16 ~ 0x19</code> 表示图片高， <code>0x1c ~ 0x1d</code> 表示图片的位深。</p><p>把这按照小端拼接起来就可以得到图片大小，宽高和位深信息。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>extern int fd;extern unsigned int* plcd;/** *  绘制图片 * */void lcd_drawpoint(int w, int h, unsigned int color) {  //(w,h)显示了color色  *(plcd + w + h * 800) = color;}/** *  读取bmp图片数据 *  从x0，y0处开始显示一张宽w高h的图片 * */void show_bmp(int x0, int y0, int w, int h, const char* bmp_file) {  int bmp = 0;  bmp = open(bmp_file, O_RDONLY);  if (-1 == bmp) {    perror("open bmp error");    exit(-1);  }  //读取BMP和DIB数据  int ret = 0;  // BMP头和DIB数据  unsigned char ch[64] = {0};  ret = read(bmp, ch, 54);  if (-1 == ret) {    perror("read bmp error");    exit(-1);  } else if (0 == ret) {    printf("no read data or file end\n");    exit(-1);  }  // 3.处理数据  int file_size = 0;  int width = 0, hight = 0, pix_bit = 0;  unsigned int color = 0;  // rgba位图  unsigned char a, r, g, b;  //存储图像的位图数据(各个像素点颜色值分量)  unsigned char pix[800 * 480 * 4] = {0};  file_size = ch[2] | ch[3] << 8 | ch[4] << 16 | ch[5] << 24;  width = ch[0x12] | ch[0x13] << 8 | ch[0x14] << 16 | ch[0x15] << 24;  hight = ch[0x16] | ch[0x17] << 8 | ch[0x18] << 16 | ch[0x19] << 24;  pix_bit = ch[0x1c] | ch[0x1d] << 8;  //读取位图数据  read(bmp, pix, w * h * pix_bit / 8);  int i = 0;  for (int y = 0; y < h; y++) {    for (int x = 0; x < w; x++) {      b = pix[i++];      g = pix[i++];      r = pix[i++];      a = (pix_bit == 32) ? pix[i++] : 0;      color = a << 24 | r << 16 | g << 8 | b;      lcd_drawpoint(x0 + x, y0 + ((h - 1) - y), color);    }  }  close(bmp);}</code></pre><p>因为前54个字节，我们是不需要的，所以，文件要偏移54个字节，或者把这54个字节读取出来。</p><p>注：<strong>bmp</strong> 图片是没有透明度选项的，即 <strong>rgb</strong> 颜色标准。</p><h3 id="Ⅲ-打开触屏文件"><a href="#Ⅲ-打开触屏文件" class="headerlink" title="Ⅲ. 打开触屏文件"></a>Ⅲ. 打开触屏文件</h3><p>打开触屏的主要目的是实现上一首下一首，播放暂停功能的实现。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <linux/input.h>#include <stdbool.h>#include <stdio.h>#include <stdlib.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int ts = 0;extern bool flag;/** *  获取触摸的x，y坐标 * */void get_touch(int *x, int *y) {  int ret;  struct input_event ev;  //输入事件结构体变量,用来保存读取的输入事件  // 1) 打开触摸屏文件  ts = open("/dev/input/event0", O_RDWR);  if (-1 == ts) {    perror("open input error");    exit(-1);  }  // 2) 读取触摸屏事件  while (1) {    if (flag) {      break;    }    ret = read(ts, &ev, sizeof(ev));  //读取输入事件保存到结构体ev中    if (ret == sizeof(ev)) {      if (ev.type == EV_ABS && ev.code == ABS_X) {        *x = ev.value * 0.8;  //此时的value是触摸点X轴的坐标      }      if (ev.type == EV_ABS && ev.code == ABS_Y) {        *y = ev.value * 0.8;  //此时的value是触摸点Y轴的坐标      }      if (ev.type == EV_KEY && ev.code == BTN_TOUCH && ev.value == 0) {        //手指从触摸屏 离开        printf("(x = %d, y = %d)\n", *x, *y);        break;      }    }  }}/** *  关闭触屏板 * */void close_ts() { close(ts); }</code></pre><h3 id="Ⅳ-实现音乐播放器功能"><a href="#Ⅳ-实现音乐播放器功能" class="headerlink" title="Ⅳ. 实现音乐播放器功能"></a>Ⅳ. 实现音乐播放器功能</h3><p>介绍下 <code>madplay</code> 的使用。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">管理madplay的主程序，包括播放，暂停播放，恢复播放，停止播放system("madplay 1.mp3 &"); // 利用system函数调用madplay播放器播放*.mp3音乐system("madplay 1.mp3 -r &"); // 循环播放：参数-rsystem("killall -9 madplay"); // 利用system函数调用killall命令将madplay终止掉 system("killall -STOP madplay &"); // 利用system函数调用killall命令将madplay暂停system("killall -CONT madplay &"); // 利用system函数调用killall命令恢复madplay的播放system("madplay 1.mp3 -a volume &");// 初始化播放音量，volume表示音量大小，范围是 -175 to +18 dB// 更多可以使用man命令查看// man madplay</code></pre><p>再介绍下信号：</p><pre class=" language-lang-bash"><code class="language-lang-bash">kill --l  -- list signal names or numbers of specified signals-n  -- specify signal number-s  -- specify signal name-ABRT    -BUS     -CONT    -HUP     -INT     -PIPE    -PROF    -QUIT    -STKFLT  -SYS     -TRAP    -TTIN    -URG     -USR2    -WINCH   -XFSZ                  -ALRM    -CHLD    -FPE     -ILL     -KILL    -POLL    -PWR     -SEGV    -STOP    -TERM    -TSTP    -TTOU    -USR1    -VTALRM  -XCPU</code></pre><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <linux/input.h>#include <stdbool.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>char music[7][6] = {"1.mp3", "2.mp3", "3.mp3", "4.mp3",                    "5.mp3", "6.mp3", "7.mp3"};int order = 0;extern bool isFirst;extern bool isPlay;extern int vol;/** *  播放音乐 *  如果是第一次播放就开始播放 *  如果不是，就继续播放 * */void play_music() {  if (isFirst) {    char command[100] = {0};    sprintf(command, "madplay %s -a %d &", music[order], vol);    printf("%s\n", command);    system(command);  } else {    system("killall -CONT madplay &");  }}/** *  暂停音乐 * */void stop_music() { system("killall -STOP madplay &"); }/** *  下一首 * */void next_music() {  system("killall -9 madplay");  if (order == 6) {    order = -1;  }  char command[100] = {0};  sprintf(command, "madplay %s -a %d &", music[++order], vol);  printf("%s\n", command);  system(command);}/** *  上一首 * */void pre_music() {  system("killall -9 madplay");  if (order == 0) {    order = 7;  }  char command[100] = {0};  sprintf(command, "madplay %s -a %d &", music[--order], vol);  printf("%s\n", command);  system(command);}</code></pre><p>这里播放音乐有个逻辑，就是如果是第一次播放的话，就要开始播放音乐，如果不是的话，就要继续播放音乐。</p><p>另外，上一首下一首功能，要防止数组越界，更简单的直接取模也是可以的。</p><h3 id="Ⅴ-主函数逻辑功能"><a href="#Ⅴ-主函数逻辑功能" class="headerlink" title="Ⅴ. 主函数逻辑功能"></a>Ⅴ. 主函数逻辑功能</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <signal.h>#include <stdbool.h>#include <stdio.h>#include <stdlib.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>extern void lcd_init();extern void lcd_uninit();extern void get_touch(int *, int *);extern void close_ts();extern void show_bmp(int, int, int, int, const char *);extern void play_music();extern void stop_music();extern void next_music();extern void pre_music();bool isFirst = true;bool isPlay = false;bool flag = false;int vol = 0;/** *  处理信号函数 * */void my_handler(int sig) {  // 最好不加  printf("End of program, end of code: %d\n", sig);  flag = true;}int main(int argc, char *argv[]) {  // argv[0] 文件名 argv[1] 音量大小  if (argc != 2) {    vol = 0;  } else {    switch (atoi(argv[1])) {      case 0:        vol = -175;        break;      case 1:        vol = -15;        break;      case 2:        vol = 0;        break;      case 3:        vol = 10;        break;    }  }  signal(SIGINT, my_handler);  const char *background_bmp = "./bmp/background.bmp";  const char *next_bmp = "./bmp/next.bmp";  const char *pre_bmp = "./bmp/pre.bmp";  const char *pause_bmp = "./bmp/pause.bmp";  const char *play_bmp = "./bmp/play.bmp";  lcd_init();  show_bmp(0, 0, 800, 480, background_bmp);  show_bmp(44, 340, 100, 100, pre_bmp);  show_bmp(375, 340, 100, 100, pause_bmp);  show_bmp(639, 340, 100, 100, next_bmp);  // 触屏得到的坐标  int x = 0, y = 0;  while (1) {    if (flag) {      // 不让程序自动处理ctrl + z/c      system("killall -9 madplay");      show_bmp(375, 340, 100, 100, pause_bmp);      flag = false;      break;    }    get_touch(&x, &y);    if (!flag) {      if (375 < x && x < 475 && 340 < y && y < 440) {        // 如果正在播放音乐，就停止播放音乐        // 如果音乐没有播放，就开始播放音乐        if (isPlay) {          stop_music();          show_bmp(375, 340, 100, 100, pause_bmp);          isPlay = false;        } else {          play_music();          show_bmp(375, 340, 100, 100, play_bmp);          isPlay = true;          isFirst = false;        }      }      // 上一首音乐      if (45 < x && x < 145 && 340 < y && y < 440) {        pre_music();        show_bmp(375, 340, 100, 100, play_bmp);        isFirst = false;        isPlay = true;      }      // 下一首音乐      if (639 < x && x < 739 && 340 < y && y < 440) {        next_music();        show_bmp(375, 340, 100, 100, play_bmp);        isFirst = false;        isPlay = true;      }    }  }  close_ts();  lcd_uninit();  return 0;}</code></pre><p>主函数增加了一个 <code>ctrl + c/z</code> 信号处理，不想让程序帮我处理这个信号，我要自己处理，目的是为了解决直接使用 <code>ctrl + c</code> 结束程序，<code>madplay</code> 还在播放音乐的情况。</p><p>其次就是通过触摸屏得到的触摸点，进行相应的操作逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码经过编译，可以成功移植到 <strong>GEC1818</strong> 开发板上，具体操作，可见 <strong>README.md</strong> 文件。</p><p>源码地址，<a href="https://github.com/Incipe-win/cpp/tree/master/c/arm/music">github</a></p><p>代码很大一部分是教课设的粤嵌老师造的轮子，自己的代码实际工作量不大。</p><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><ol><li>使用了较多的全局变量，这样会导致代码的耦合性降低，后期维护难度大；</li><li>功能还是有所欠缺；</li><li>代码还是有点冗余，不太精简。</li><li>……</li></ol>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20.04安装arm-linux-gcc交叉编译器</title>
      <link href="2020/09/28/iot/2020/ubuntu20.04-an-zhuang-arm-linux-gcc-jiao-cha-bian-yi-qi/"/>
      <url>2020/09/28/iot/2020/ubuntu20.04-an-zhuang-arm-linux-gcc-jiao-cha-bian-yi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>本文安装的交叉编译器是 <strong>arm-linux-gcc4.4.3</strong> 32位的，其他版本安装类似。</p><p><a href="http://www.arm9.net/download.asp">友善之臂官网下载地址</a> ：<a href="http://www.arm9.net/download.asp">http://www.arm9.net/download.asp</a></p><p>喜欢网盘下载的朋友可以使用 [<a href="https://pan.baidu.com/s/1bSNel0a13lJsn9fxOT7gZQ">https://pan.baidu.com/s/1bSNel0a13lJsn9fxOT7gZQ</a> 提取码: u3yd] 进行安装。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果之前安装过旧版本的，可以考虑删除旧的版本在进行安装，如果不知道有没有安装过，就不管了。</p><p>下载好后进入 <strong>Ubuntu20.04</strong>  进行解压。</p><pre class=" language-lang-bash"><code class="language-lang-bash">tar -zxvf arm-linux-gcc-4.4.3-20100728.tar.gz</code></pre><p>此时当前目录下解压没错误的话会多个 <strong>opt</strong> 文件夹， 大致目录结构如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">.└── FriendlyARM    └── toolschain        └── 4.4.3            ├── arm-none-linux-gnueabi            ├── bin              ├── include              ├── lib              ├── libexec              ├── share</code></pre><p>移动/复制 <strong>FriendlyARM</strong> 目录到 <code>/usr/local/bin/</code> 目录下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">cd optsudo mv FriendlyARM /usr/local/bin/</code></pre><p>接下来添加环境变量即可。</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim ~/.zshrc# 如果用的bash就是.bashrc# 在文件末尾添加export PATH=$PATH:/usr/local/bin/FriendlyARM/toolschain/4.4.3/binsource ~/.zshrc</code></pre><p>测试是否安装成功：</p><pre class=" language-lang-bash"><code class="language-lang-bash">arm-linux-gcc -v# 如果出现如下信息即成功Using built-in specs.Target: arm-none-linux-gnueabiConfigured with: /opt/FriendlyARM/mini2440/build-toolschain/working/src/gcc-4.4.3/configure --build=i386-build_redhat-linux-gnu --host=i386-build_redhat-linux-gnu --target=arm-none-linux-gnueabi --prefix=/opt/FriendlyARM/toolschain/4.4.3 --with-sysroot=/opt/FriendlyARM/toolschain/4.4.3/arm-none-linux-gnueabi//sys-root --enable-languages=c,c++ --disable-multilib --with-arch=armv4t --with-cpu=arm920t --with-tune=arm920t --with-float=soft --with-pkgversion=ctng-1.6.1 --disable-sjlj-exceptions --enable-__cxa_atexit --with-gmp=/opt/FriendlyARM/toolschain/4.4.3 --with-mpfr=/opt/FriendlyARM/toolschain/4.4.3 --with-ppl=/opt/FriendlyARM/toolschain/4.4.3 --with-cloog=/opt/FriendlyARM/toolschain/4.4.3 --with-mpc=/opt/FriendlyARM/toolschain/4.4.3 --with-local-prefix=/opt/FriendlyARM/toolschain/4.4.3/arm-none-linux-gnueabi//sys-root --disable-nls --enable-threads=posix --enable-symvers=gnu --enable-c99 --enable-long-long --enable-target-optspaceThread model: posixgcc version 4.4.3 (ctng-1.6.1)</code></pre><h2 id="安装出错解决办法"><a href="#安装出错解决办法" class="headerlink" title="安装出错解决办法"></a>安装出错解决办法</h2><p>输入 <code>arm-linux-gcc -v</code> 如果出现如下报错信息：</p><pre class=" language-lang-bash"><code class="language-lang-bash">arm-linux-gcc -v/FriendlyARM/toolschain/4.4.3/bin/arm-linux-gcc: 15: exec: /FriendlyARM/toolschain/4.4.3/bin/.arm-none-linux-gnueabi-gcc: not found</code></pre><p>因为在64位Linux系统下无法兼容32位交叉编译器，解决办法：</p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo apt-get install libc6-i386</code></pre><p>应该就没问题了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编译方法跟 <code>gcc</code> 一样的，可以参考我的这个博客，<a href="https://blog.csdn.net/qq_43826212/article/details/105973943">简简单单学会写makefile</a></p><p>这个安装还是挺简单的。</p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>147. 对链表进行插入排序</title>
      <link href="2020/09/24/leetcode/2020/147.dui-lian-biao-jin-xing-cha-ru-pai-xu/"/>
      <url>2020/09/24/leetcode/2020/147.dui-lian-biao-jin-xing-cha-ru-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>对链表进行插入排序。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/Insertion-sort-example-300px.gif" alt="img"></p><p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。</p><p>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p>插入排序算法：</p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。</li></ol><p><strong>示例 1：</strong></p><blockquote><p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/insertion-sort-list">https://leetcode-cn.com/problems/insertion-sort-list</a></p><p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个题竟然翻车了，做了好久。其实并不难，过程记录下来。思路就按照题目给的 <strong>gif</strong> 来就行了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>声明一个只有头结点的链表，记录排序后的新链表，声明两个新的指针 <strong>p</strong> 指向新链表的头，<strong>q</strong> 原节点的头。</li><li>原链表头指针往后移动一位。</li><li>如果 <code>p-&gt;next &amp;&amp; head-&gt;val &gt; p-&gt;next-&gt;val</code> 说明新链表的下一个节点小于原链表当前的头节点，说明 <strong>p-&gt;next</strong> 不是合适的插入位置， 我们要把 <strong>p</strong> 指针向后移动一位，因为链表的拼接就是键的断裂，重连，所以这段代码就应该是这样的，向让 <strong>q</strong> 指向 <strong>p</strong> 的下一个节点，然后再把 <strong>p</strong> 的下一个节点指向<strong>q</strong> 就好了 <code>q-&gt;next = p-&gt;next, p-&gt;next = q;</code> 重复这段过程即可。</li><li>当原链表的头指针指向最后一个元素时，说明链表排序完了。</li></ol><p>附上 <strong>gif</strong> 演示动图：</p><p><img src="https://gitee.com/incipe-win/images/raw/master/147.gif" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* insertionSortList(ListNode* head) {        ListNode *ans = new ListNode(-1);        while (head) {            ListNode *p = ans;            while (p->next && p->next->val < head->val) {                p = p->next;            }            ListNode *q = head;            head = head->next;            q->next = p->next;            p->next = q;        }        return ans->next;    }};</code></pre><ul><li>Python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def insertionSortList(self, head: ListNode) -> ListNode:        ans = ListNode(-1)        while head:            p = ans            while p.next and p.next.val < head.val:                p = p.next            q = head            head = head.next            q.next = p.next            p.next = q        return ans.next</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好像执行的速度有点慢，我们遍历原链表的时候，要是原链表当前节点值小于下一个结点的值，就移动原链表的头指针。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200924195550563.png" alt="image-20200924195550563"></p><p>参考：</p><pre class=" language-lang-python"><code class="language-lang-python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def insertionSortList(self, head: ListNode) -> ListNode:        ans = ListNode(0)        ans.next = head        while head and head.next:            if head.val <= head.next.val:                head = head.next                continue            p = ans            while p.next.val < head.next.val:                p = p.next            q = head.next            head.next = q.next            q.next = p.next            p.next = q        return ans.next</code></pre><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200924195559279.png" alt="image-20200924195559279"></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+Typora+Gitee搭建本地博客图片环境</title>
      <link href="2020/08/26/software/2020/picgo-typora-gitee-da-jian-ben-di-bo-ke-huan-jing/"/>
      <url>2020/08/26/software/2020/picgo-typora-gitee-da-jian-ben-di-bo-ke-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来想着看看别人的博客就可以轻松实现了，到头来，使用方法好像出现了点变化，又被折腾了，记录下最新使用方法。</p><ul><li><p>安装 <a href="https://typora.io/">typora</a></p></li><li><p>安装 <a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></p></li></ul><ul><li>拥有 <code>Gitee</code> 账号</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Ⅰ-获得token"><a href="#Ⅰ-获得token" class="headerlink" title="Ⅰ. 获得token"></a>Ⅰ. 获得token</h3><p>没有 <code>Gitee</code> 仓库就创建一个，这个不再赘述。</p><p>获得 <code>token</code></p><p><img src="https://gitee.com/incipe-win/images/raw/master/20200826111336.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200826111456078.png" alt="image-20200826111456078"></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200826111539632.png" alt="image-20200826111539632"></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200826111619610.png" alt="image-20200826111619610"></p><p>然后会得到 <code>token</code> 复制下来，后面会用到的。</p><h3 id="Ⅱ-PicGo配置"><a href="#Ⅱ-PicGo配置" class="headerlink" title="Ⅱ. PicGo配置"></a>Ⅱ. PicGo配置</h3><p>打开 <code>PicGo</code>，按照图中步骤安装 <code>gitee</code> 插件。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/20200826110730.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/20200826110942.png" alt=""></p><p>之前的版本没有 <code>owner</code> 这个选项，所以直接在 <code>repo</code> 仓库处填 <code>username/reponame</code> 就可以了，但是最新的这个版本是不可以的。</p><ul><li><code>owner</code> 填写你的 <code>gitee</code> 用户名即可。</li><li><code>repo</code> 填写你创建的仓库名称即可。</li><li><code>token</code> 刚刚复制的。</li></ul><p>举个例子，我创建了仓库，会有个 <code>url</code> 地址。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200826111848674.png" alt="image-20200826111848674"></p><p><code>repo</code> 填写中间这个 <code>incipe-win</code> <code>repo</code> 填写这个 <code>images</code> 即可。</p><h3 id="Ⅲ-测试"><a href="#Ⅲ-测试" class="headerlink" title="Ⅲ. 测试"></a>Ⅲ. 测试</h3><p>做完了上面这些，测试下是否成功了。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200826112013726.png" alt="image-20200826112013726"></p><p>这里上传图片，要是在相册有你刚刚上传的图片，说明 <code>PicGo</code> 配置成功。</p><p>接下来配置 <code>typora</code> </p><p> 打开偏好设置 <code>ctrl + 逗号</code></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20200826112200377.png" alt="image-20200826112200377"></p><p>按照图片中的设置好即可。</p><p>点击 <code>验证图片上传选项</code>  </p><p>验证成功即可。</p><p>以后每次只要把图片粘贴到 <code>typora</code> 点击上传图片即可自动传到 <code>gitee</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>踩坑不可避免，学习不能“照本宣科”。</p><p>经过测试，无论是到自建博客，还是CSDN，还是微信公众号都没问题。</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda常用方法</title>
      <link href="2020/08/24/python/2020/conda-shi-yong/"/>
      <url>2020/08/24/python/2020/conda-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考我的这篇文章即可，<a href="https://blog.csdn.net/qq_43826212/article/details/108058020">Ubuntu20.04安装Anaconda</a></p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="Ⅰ-创建虚拟环境"><a href="#Ⅰ-创建虚拟环境" class="headerlink" title="Ⅰ. 创建虚拟环境"></a>Ⅰ. 创建虚拟环境</h3><pre class=" language-lang-bash"><code class="language-lang-bash">conda create --name name python=3.8</code></pre><p><code>name</code> 就是你要创建的虚拟环境的名字，<code>python</code> 指定版本后，就会自动寻找这个版本的最新版本。</p><h3 id="Ⅱ-激活环境"><a href="#Ⅱ-激活环境" class="headerlink" title="Ⅱ. 激活环境"></a>Ⅱ. 激活环境</h3><pre class=" language-lang-bash"><code class="language-lang-bash">activate name # windowssource activate name # linux</code></pre><p>如果 <code>source activate name</code> 失效，说明找不到 <code>activate</code> 这个命令了。</p><p>如下信息：</p><p><code>source: no such file or directory: activate</code></p><p>事实上，最新版的 <code>conda</code> 也会给你个警告，说这个方法已经被禁用了。</p><p>使用 <code>conda activate name</code> 即可。</p><h3 id="Ⅲ-退出虚拟环境"><a href="#Ⅲ-退出虚拟环境" class="headerlink" title="Ⅲ. 退出虚拟环境"></a>Ⅲ. 退出虚拟环境</h3><pre class=" language-lang-bash"><code class="language-lang-bash">conda deactivate name</code></pre><h3 id="Ⅳ-删除虚拟环境"><a href="#Ⅳ-删除虚拟环境" class="headerlink" title="Ⅳ. 删除虚拟环境"></a>Ⅳ. 删除虚拟环境</h3><pre class=" language-lang-python"><code class="language-lang-python">conda remove --name name --all</code></pre><h3 id="Ⅴ-查看所有的虚拟环境"><a href="#Ⅴ-查看所有的虚拟环境" class="headerlink" title="Ⅴ. 查看所有的虚拟环境"></a>Ⅴ. 查看所有的虚拟环境</h3><pre class=" language-lang-bash"><code class="language-lang-bash">conda info -e</code></pre><h2 id="conda包管理"><a href="#conda包管理" class="headerlink" title="conda包管理"></a>conda包管理</h2><h3 id="Ⅰ-安装包"><a href="#Ⅰ-安装包" class="headerlink" title="Ⅰ. 安装包"></a>Ⅰ. 安装包</h3><pre class=" language-lang-bash"><code class="language-lang-bash">conda install 包名</code></pre><h3 id="Ⅱ-查看已经安装的包"><a href="#Ⅱ-查看已经安装的包" class="headerlink" title="Ⅱ. 查看已经安装的包"></a>Ⅱ. 查看已经安装的包</h3><pre class=" language-lang-bash"><code class="language-lang-bash">conda list</code></pre><h3 id="Ⅲ-更新"><a href="#Ⅲ-更新" class="headerlink" title="Ⅲ. 更新"></a>Ⅲ. 更新</h3><pre class=" language-lang-bash"><code class="language-lang-bash">conda update condaconda update anaconda</code></pre><h3 id="Ⅳ-删除包"><a href="#Ⅳ-删除包" class="headerlink" title="Ⅳ.  删除包"></a>Ⅳ.  删除包</h3><pre class=" language-lang-bash"><code class="language-lang-bash">conda uninstall 包名</code></pre><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p><code>anaconda</code> 服务器在国外，下载包的速度会超级慢，改成清华源，速度会有质的改善。</p><p>执行如下命令：</p><pre class=" language-lang-bash"><code class="language-lang-bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Liunx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas入门</title>
      <link href="2020/08/20/python/2020/pandas-ru-men/"/>
      <url>2020/08/20/python/2020/pandas-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是pandas"><a href="#什么是pandas" class="headerlink" title="什么是pandas"></a>什么是pandas</h2><p><code>pandas</code> 是基于一种 <code>NumPy</code> 的一种工具。<code>NumPy</code> 只能处理数值型的数据，但是 <code>pandas</code> 除了处理数值之外，还可以处理其它类型的数据。比如，字符串，时间序列等。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Ⅰ-数据结构"><a href="#Ⅰ-数据结构" class="headerlink" title="Ⅰ. 数据结构"></a>Ⅰ. 数据结构</h3><div class="table-container"><table><thead><tr><th style="text-align:center">维数</th><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Series</td><td style="text-align:center">带标签的一维同构数组</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">DataFrame</td><td style="text-align:center">带标签的，大小可变的，二维异构表格</td></tr></tbody></table></div><h4 id="一维Series"><a href="#一维Series" class="headerlink" title="一维Series"></a>一维Series</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><pre class=" language-lang-python"><code class="language-lang-python">import pandas as pd         import numpy as npt1 = pd.Series([1, 2, 3, 4])                                                                               """0    11    22    33    4dtype: int64"""t2 = pd.Series([1, 2, 3, 4, 5], index=list("abcde"))"""a    1b    2c    3d    4e    5dtype: int64""" dic = {"name" : "incipe", "age" : 0, "tel" : "xxxxxxxxxxx"}t3 = pd.Series(dic)  """name         incipeage               0tel     xxxxxxxxxxxdtype: object"""t2.astype(float)"""0    1.01    2.02    3.03    4.04    5.0dtype: float64"""t4 = pd.Series(np.arange(6))"""0    01    12    23    34    45    5dtype: int64"""</code></pre><h5 id="索引切片"><a href="#索引切片" class="headerlink" title="索引切片"></a>索引切片</h5><pre class=" language-lang-python"><code class="language-lang-python">t4[1]# 1t4[[1, 2, 3]]"""1    12    23    3dtype: int64"""t4[1:5:2]"""1    13    3dtype: int64"""t3["name"]"""'incipe'"""t3.index# Index(['name', 'age', 'tel'], dtype='object')t3.values# array(['incipe', 0, 'xxxxxxxxxxx'], dtype=object)</code></pre><h4 id="二维DataFrame"><a href="#二维DataFrame" class="headerlink" title="二维DataFrame"></a>二维DataFrame</h4><pre class=" language-lang-python"><code class="language-lang-python">t5 = pd.DataFrame(np.arange(12).reshape(3, 4)) """   0  1   2   30  0  1   2   31  4  5   6   72  8  9  10  11"""t6 = pd.DataFrame(np.arange(12).reshape(3, 4), index=list("abc"), columns=list("efgh"))# index行索引，columns列索引"""   e  f   g   ha  0  1   2   3b  4  5   6   7c  8  9  10  11"""dic = {"name" : ["incipe", "win"], "age" : [0, 0], "tel" : ["xxx", "xxx"]}t7 = pd.DataFrame(dic)"""     name  age  tel0  incipe    0  xxx1     win    0  xxx"""l = [{"name" : "incipe"}, {"age" : 0}, {"tel" : "xxx"}]t8 = pd.DataFrame(l)"""     name  age  tel0  incipe  NaN  NaN1     NaN  0.0  NaN2     NaN  NaN  xxx"""t6.index"""Index(['a', 'b', 'c'], dtype='object')"""t6.columns"""Index(['e', 'f', 'g', 'h'], dtype='object')"""t6.values"""array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])"""t6.shape# (3, 4)t6.dtypes"""e    int64f    int64g    int64h    int64dtype: object"""t6.describe()"""         e    f     g     hcount  3.0  3.0   3.0   3.0mean   4.0  5.0   6.0   7.0std    4.0  4.0   4.0   4.0min    0.0  1.0   2.0   3.025%    2.0  3.0   4.0   5.050%    4.0  5.0   6.0   7.075%    6.0  7.0   8.0   9.0max    8.0  9.0  10.0  11.0""" t6.info()"""<class 'pandas.core.frame.DataFrame'>Index: 3 entries, a to cData columns (total 4 columns): #   Column  Non-Null Count  Dtype---  ------  --------------  ----- 0   e       3 non-null      int64 1   f       3 non-null      int64 2   g       3 non-null      int64 3   h       3 non-null      int64dtypes: int64(4)memory usage: 120.0+ bytes"""t6.sort_values(by="h", ascending=False)# 缺省ascending，默认按照升序排序"""   e  f   g   hc  8  9  10  11b  4  5   6   7a  0  1   2   3"""</code></pre><h5 id="索引切片-1"><a href="#索引切片-1" class="headerlink" title="索引切片"></a>索引切片</h5><pre class=" language-lang-python"><code class="language-lang-python">t6[:2] """   e  f  g  ha  0  1  2  3b  4  5  6  7"""t6["f"]"""a    1b    5c    9Name: f, dtype: int64"""</code></pre><p><code>中括号里面是数字，表示对行进行操作，是字符串，表示对列进行操作，是列的索引。对行进行操作得到的依旧是DataFrame类型，对列进行操作，得到的是Series类型。</code></p><p>通过标签索引取数据。</p><pre class=" language-lang-python"><code class="language-lang-python">t6.loc["a", "e"]# 0t6.loc["a", :]"""e    0f    1g    2h    3Name: a, dtype: int64"""t6.loc[:, "e"]"""a    0b    4c    8Name: e, dtype: int64"""t6.loc[["a", "b"], :] """   e  f  g  ha  0  1  2  3b  4  5  6  7"""t6.loc[:, ["e", "f"]]"""   e  fa  0  1b  4  5c  8  9"""t6.loc[["a", "b"], ["e", "f"]]"""   e  fa  0  1b  4  5"""t6.loc["a":"c", ["e", "f"]] # 这里的切片有点不同，最后一个元素是可以选中的"""   e  fa  0  1b  4  5c  8  9"""</code></pre><p>通过位置获取数据。</p><pre class=" language-lang-python"><code class="language-lang-python">t6.iloc[1: ,]"""e    4f    5g    6h    7Name: b, dtype: int64"""t6.iloc[:, 1]  """a    1b    5c    9Name: f, dtype: int64"""t6.iloc[[1, 2], [2, 3]]"""    g   hb   6   7c  10  11"""</code></pre><p><code>这里的取多行多列跟NumPy的有区别，在NumPy中，[[1, 2], [3, 4]]表示取第2行第3列的元素和第3行第5列的元素，构成了一个一维数组，而在pandas中，表述取第2行第4列的元素，第2行第5列的元素和第3行第4列的元素，第3行第5列的元素，组成一个DataFrame的二维数组。</code></p><h5 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h5><pre class=" language-lang-python"><code class="language-lang-python">t6 > 5"""       e      f      g      ha  False  False  False  Falseb  False  False   True   Truec   True   True   True   True"""t6[t6 > 5]"""     e    f     g     ha  NaN  NaN   NaN   NaNb  NaN  NaN   6.0   7.0c  8.0  9.0  10.0  11.0"""t6[t6["e"] > 1]"""   e  f   g   hb  4  5   6   7c  8  9  10  11"""</code></pre><h3 id="Ⅱ-读取数据"><a href="#Ⅱ-读取数据" class="headerlink" title="Ⅱ. 读取数据"></a>Ⅱ. 读取数据</h3><p><code>pandas</code> 提供了读取很多种文件的方法，比如：</p><ul><li>读取 <code>csv</code> <code>pd.read_csv()</code></li><li>读取 <code>sql</code> <code>pd.read_sql()</code></li><li>读取 <code>excel</code> <code>pd.read_excel()</code></li><li>读取 <code>html</code> <code>pd.read_html()</code></li><li>读取 <code>json</code> <code>pd.read_json()</code> </li></ul><p>更多参考 <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-store-in-csv">pandas.pydata.org</a> </p><h3 id="Ⅲ-字符串方法"><a href="#Ⅲ-字符串方法" class="headerlink" title="Ⅲ. 字符串方法"></a>Ⅲ. 字符串方法</h3><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">cat()</td><td style="text-align:center">拼接字符串，可以指定分隔符</td></tr><tr><td style="text-align:center">contains()</td><td style="text-align:center">返回一个布尔矩阵表明是每个元素包含字符串或正则表达式</td></tr><tr><td style="text-align:center">count()</td><td style="text-align:center">对出现符合的规则进行计数</td></tr><tr><td style="text-align:center">endswith()、startswith()</td><td style="text-align:center">等价于<code>str.startswith(pattern)</code> 或者  <code>str.endswith(pattern)</code></td></tr><tr><td style="text-align:center">findall()</td><td style="text-align:center">返回每一个字串中出现的所有满足样式或正则的匹配</td></tr><tr><td style="text-align:center">get()</td><td style="text-align:center">索引每一个元素（返回第i个元素）</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:center">使用传入的分隔符依次拼接每一个元素</td></tr><tr><td style="text-align:center">len()</td><td style="text-align:center">计算字符串长度</td></tr><tr><td style="text-align:center">lower()、upper()</td><td style="text-align:center">大小写转换</td></tr><tr><td style="text-align:center">match()</td><td style="text-align:center">根据指定的正则表达式对元素进行<code>re.match()</code> 并以列表形式返回匹配到的组</td></tr><tr><td style="text-align:center">pad()</td><td style="text-align:center">将白空格插入到字符串的左、右或者两端</td></tr><tr><td style="text-align:center">center()</td><td style="text-align:center">等价于 <code>pad(side="both")</code></td></tr><tr><td style="text-align:center">repeat()</td><td style="text-align:center">值复制（ <code>s.str.repeat(3)</code> 等价于x * 3）</td></tr><tr><td style="text-align:center">replace()</td><td style="text-align:center">将匹配到的子串或正则表达式替换为另外的字符串，或者一个可调用对象的返回值</td></tr><tr><td style="text-align:center">slice()</td><td style="text-align:center">将序列中的每一个字符串切片</td></tr><tr><td style="text-align:center">split()</td><td style="text-align:center">基于分隔符切分字符串</td></tr><tr><td style="text-align:center">strip()、rstrip()、lstrip()</td><td style="text-align:center">去掉空白符，包括换行符号</td></tr></tbody></table></div><p>更多请参考 <a href="https://www.pypandas.cn/docs/user_guide/text.html#方法总览">Pandas中文网</a></p><h3 id="Ⅳ-缺失数据处理"><a href="#Ⅳ-缺失数据处理" class="headerlink" title="Ⅳ. 缺失数据处理"></a>Ⅳ. 缺失数据处理</h3><p>在 <code>pandas</code> 中，缺失数据会被定位为 <code>NaN</code></p><ul><li>判断当前数据有没有 <code>NaN</code> <code>pd.isnull(a), pd.notnull()</code></li></ul><h4 id="处理方法1"><a href="#处理方法1" class="headerlink" title="处理方法1"></a>处理方法1</h4><p>删除 <code>NaN</code> 所在的行列 <code>dropna(axis=0, how='any', inplace=False)</code></p><p>参数：</p><ul><li><code>axis</code> 删除行还是列，0表示行，1表示列。</li><li><code>how</code> 参数为 <code>any</code> 表示某行或者某列只要有一个 <code>NaN</code> 就删除，为 <code>all</code> 时某行某列要全为 <code>NaN</code> 才删除。</li><li><code>inplace</code> 时候原地修改。</li></ul><pre class=" language-lang-python"><code class="language-lang-python">t7.DataFrame(np.arange(24).reshape(4, 6))t7.index = list("abcd")t7.columns = list("efghij")t7.loc["a", "h"] = np.nant7.iloc[2, 2] = np.nan"""    e   f     g     h   i   ja   0   1   2.0   NaN   4   5b   6   7   8.0   9.0  10  11c  12  13   NaN  15.0  16  17d  18  19  20.0  21.0  22  23"""pd.isnull(t7)"""       e      f      g      h      i      ja  False  False  False   True  False  Falseb  False  False  False  False  False  Falsec  False  False   True  False  False  Falsed  False  False  False  False  False  False"""t7.dropna(axis=0) """    e   f     g     h   i   jb   6   7   8.0   9.0  10  11d  18  19  20.0  21.0  22  23"""</code></pre><h4 id="处理方法2"><a href="#处理方法2" class="headerlink" title="处理方法2"></a>处理方法2</h4><p>填充数据 <code>t.fillna(t.mean()</code> <code>t.fiallna(t.median())</code> <code>t.fillna(0))</code></p><pre class=" language-lang-python"><code class="language-lang-python">t7["h"].fillna(t7["h"].mean())"""a    15.0b     9.0c    15.0d    21.0Name: h, dtype: float64"""t7["g"].fillna(t7["g"].median())"""a     2.0b     8.0c     8.0d    20.0Name: g, dtype: float64"""</code></pre><h3 id="Ⅴ-统计方法"><a href="#Ⅴ-统计方法" class="headerlink" title="Ⅴ. 统计方法"></a>Ⅴ. 统计方法</h3><ul><li>获取不同字段的个数 <code>unique()</code></li><li>获取某行或某列或整个数组均值 <code>mean()</code></li><li>获取某行或某列中位数 <code>median()</code></li><li>获取某行或某列或整个数组信息 <code>info()</code></li><li>获取某行或某列或整个数组描述信息 <code>desctibe()</code></li></ul><h3 id="Ⅵ-数据合并"><a href="#Ⅵ-数据合并" class="headerlink" title="Ⅵ. 数据合并"></a>Ⅵ. 数据合并</h3><p><code>join()</code> 把数据行索引相同的数据合并。</p><pre class=" language-lang-python"><code class="language-lang-python">t1 = pd.DataFrame(np.ones((2, 4)), index=["A", "B"], columns=["a", "b", "c", "d"])"""     a    b    c    dA  1.0  1.0  1.0  1.0B  1.0  1.0  1.0  1.0"""t2 = pd.DataFrame(np.ones((3, 3)), index=list("ABC"), columns=list("xyz"))"""     x    y    zA  1.0  1.0  1.0B  1.0  1.0  1.0C  1.0  1.0  1.0"""t1.join(t2)"""     a    b    c    d    x    y    zA  1.0  1.0  1.0  1.0  1.0  1.0  1.0B  1.0  1.0  1.0  1.0  1.0  1.0  1.0"""t2.join(t1)"""     x    y    z    a    b    c    dA  1.0  1.0  1.0  1.0  1.0  1.0  1.0B  1.0  1.0  1.0  1.0  1.0  1.0  1.0C  1.0  1.0  1.0  NaN  NaN  NaN  NaN"""</code></pre><p><code>merge()</code>  按照列索引进行数据合并</p><p>默认链接方式 <code>inner</code> 取交集，内连接</p><pre class=" language-lang-python"><code class="language-lang-python">t3 = pd.DataFrame(np.zeros((2, 5)), index=list("qw"), columns=list("xjkhg"))"""     x    j    k    h    gq  0.0  0.0  0.0  0.0  0.0w  0.0  0.0  0.0  0.0  0.0"""t2.merge(t3)"""Empty DataFrameColumns: [x, y, z, j, k, h, g]Index: []"""t3.merge(t3)"""Empty DataFrameColumns: [x, y, z, j, k, h, g]Index: []"""</code></pre><p>因为没有相同的列，所以不能合并。</p><p>取并集 <code>outer</code>， 外连接</p><pre class=" language-lang-python"><code class="language-lang-python">t2.merge(t3, left_on="x", right_on="x", how="outer")"""     x    y    z    j    k    h    g0  1.0  1.0  1.0  NaN  NaN  NaN  NaN1  1.0  1.0  1.0  NaN  NaN  NaN  NaN2  1.0  1.0  1.0  NaN  NaN  NaN  NaN3  0.0  NaN  NaN  0.0  0.0  0.0  0.04  0.0  NaN  NaN  0.0  0.0  0.0  0.0"""t4 = pd.DataFrame(np.arange(24).reshape(4, 6), index=list("yuio"), columns=list("xyjklp"))"""    x   y_x     j     k     l     p  y_y    z0   0   1.0   2.0   3.0   4.0   5.0  NaN  NaN1   6   7.0   8.0   9.0  10.0  11.0  NaN  NaN2  12  13.0  14.0  15.0  16.0  17.0  NaN  NaN3  18  19.0  20.0  21.0  22.0  23.0  NaN  NaN4   1   NaN   NaN   NaN   NaN   NaN  1.0  1.05   1   NaN   NaN   NaN   NaN   NaN  1.0  1.06   1   NaN   NaN   NaN   NaN   NaN  1.0  1.0"""</code></pre><p>左连接 <code>left</code> 以左边的为准</p><pre class=" language-lang-python"><code class="language-lang-python">t2.merge(t4, how="left")# 以t2为准"""     x    y    z   j   k   l   p0  1.0  1.0  1.0 NaN NaN NaN NaN1  1.0  1.0  1.0 NaN NaN NaN NaN2  1.0  1.0  1.0 NaN NaN NaN NaN"""t4.merge(t2, how="left")# 以t4为准"""    x   y   j   k   l   p   z0   0   1   2   3   4   5 NaN1   6   7   8   9  10  11 NaN2  12  13  14  15  16  17 NaN3  18  19  20  21  22  23 NaN"""</code></pre><p>右连接 <code>right</code></p><pre class=" language-lang-python"><code class="language-lang-python">t4.merge(t2, how="right") """     x    y   j   k   l   p    z0  1.0  1.0 NaN NaN NaN NaN  1.01  1.0  1.0 NaN NaN NaN NaN  1.02  1.0  1.0 NaN NaN NaN NaN  1.0"""t2.merge(t4, how="right")"""    x   y   z   j   k   l   p0   0   1 NaN   2   3   4   51   6   7 NaN   8   9  10  112  12  13 NaN  14  15  16  173  18  19 NaN  20  21  22  23"""</code></pre><h3 id="Ⅶ-分组聚合"><a href="#Ⅶ-分组聚合" class="headerlink" title="Ⅶ. 分组聚合"></a>Ⅶ. 分组聚合</h3><p><code>groupby(by="columns_name")</code> </p><p>返回值得到一个 <code>DataFrameGroupBy</code> 对象。</p><p>也可以按照多列进行分组，参数传个列表进去就好了 <code>groupby(by=["columns_name1", "columns_name2"])</code> </p><pre class=" language-lang-python"><code class="language-lang-python">l = [{"Country" : "CN", "Custom" : "xxx"}, {"Country" : "ZA", "Custom" : "xxx1"}, {"Country" : "UK", "Custom" : "xxx2"}, {"Country" : "US", "Custom" : "xxx3"}] df = pd.DataFrame(l)"""  Country Custom0      CN    xxx1      ZA   xxx12      UK   xxx23      US   xxx3"""group = df.groupby("Country") """<pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f92edc33940>"""for i in group:     print(i)     print("*" * 10) """('CN',   Country Custom0      CN    xxx)**********('UK',   Country Custom2      UK   xxx2)**********('US',   Country Custom3      US   xxx3)**********('ZA',   Country Custom1      ZA   xxx1)**********"""for i, j in group:     print(i)     print("-" * 10)     print(j)     print("*" * 10)"""CN----------  Country Custom0      CN    xxx**********UK----------  Country Custom2      UK   xxx2**********US----------  Country Custom3      US   xxx3**********ZA----------  Country Custom1      ZA   xxx1**********"""</code></pre><p>按照 <code>column_name</code> 进行分组，得到的是一个元组，第一个字段是 <code>column_name</code> 名字，第二个字段是这个 <code>column_name</code> 的 <code>DataFrame</code></p><p>聚合方法</p><pre class=" language-lang-python"><code class="language-lang-python">group.count()"""Country        CN            1UK            1US            1ZA            1"""</code></pre><p>数据量太小了，展示效果不好。</p><p> 除了前面提到的统计方法可以作为聚合方法，还有更多聚合方法：</p><ul><li><code>std()、var()</code> 无偏(分母为n - 1)标准差和方差。</li><li><code>min()、max()</code> 最大最小值。</li></ul><h3 id="Ⅷ-时间序列"><a href="#Ⅷ-时间序列" class="headerlink" title="Ⅷ. 时间序列"></a>Ⅷ. 时间序列</h3><p><code>pd.date_range(start=None, end=None, periods=None, freq='D')</code></p><pre class=" language-lang-python"><code class="language-lang-python">date = pd.date_range(start="20000131", end="20000215", freq="D") """DatetimeIndex(['2000-01-31', '2000-02-01', '2000-02-02', '2000-02-03',               '2000-02-04', '2000-02-05', '2000-02-06', '2000-02-07',               '2000-02-08', '2000-02-09', '2000-02-10', '2000-02-11',               '2000-02-12', '2000-02-13', '2000-02-14', '2000-02-15'],              dtype='datetime64[ns]', freq='D')"""date = pd.date_range(start="20000131", end="20000215", freq="10D")"""DatetimeIndex(['2000-01-31', '2000-02-10'], dtype='datetime64[ns]', freq='10D')"""date = pd.date_range(start="20000131", periods=10, freq="D")"""DatetimeIndex(['2000-01-31', '2000-02-01', '2000-02-02', '2000-02-03',               '2000-02-04', '2000-02-05', '2000-02-06', '2000-02-07',               '2000-02-08', '2000-02-09'],              dtype='datetime64[ns]', freq='D')"""</code></pre><p><code>freq</code> 选值<a href="https://www.pypandas.cn/docs/user_guide/timeseries.html#dateoffset-对象">pandas中文</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数据分析简单的一些概要就到这里了。以后可能会有更为详细的介绍和用法。</p><p>数据太多，人都傻了。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTI1MzQxNQ==&amp;mid=2247484617&amp;idx=1&amp;sn=f00f712717335fadd23a41d3bfc1ff85&amp;chksm=ce801001f9f79917f6df1a293e016de139d403b34a1835dc014cc13baa650c5eca0b60d5a04f&amp;token=2012451960&amp;lang=zh_CN#rd">数据可视化matplotlib</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTI1MzQxNQ==&amp;mid=2247484702&amp;idx=1&amp;sn=870a99fa69d1fcf991ced5d93b719cfd&amp;chksm=ce8011d6f9f798c03aa72e13fb8cc8033bde43a02270ef11957db8c62e319836e4a12ef48816&amp;token=2012451960&amp;lang=zh_CN#rd">科学计算NumPy</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib使用</title>
      <link href="2020/08/16/python/2020/matplotlib-shi-yong/"/>
      <url>2020/08/16/python/2020/matplotlib-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是matplotlib"><a href="#什么是matplotlib" class="headerlink" title="什么是matplotlib"></a>什么是matplotlib</h2><blockquote><p>Matplotlib 可能是 Python 2D-绘图领域使用最广泛的套件。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。这里将会探索 matplotlib 的常见用法。</p><div align="right"> 菜鸟教程</div></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Ⅰ-绘制折线图"><a href="#Ⅰ-绘制折线图" class="headerlink" title="Ⅰ. 绘制折线图"></a>Ⅰ. 绘制折线图</h3><h4 id="绘制简单图"><a href="#绘制简单图" class="headerlink" title="绘制简单图"></a>绘制简单图</h4><pre class=" language-lang-python"><code class="language-lang-python">from matplotlib import pyplot as pltx = range(2, 26, 2)y = [1, 20, 34, 4, 53, 64, 7, 8, 94, -10, 11, 22]plt.plot(x, y)plt.show()</code></pre><h4 id="修改图片大小"><a href="#修改图片大小" class="headerlink" title="修改图片大小"></a>修改图片大小</h4><pre class=" language-lang-python"><code class="language-lang-python">figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)</code></pre><ul><li><code>num</code> 图像编号或名称，数字表示编号，字符串表示名称。</li><li><code>figsize</code> 图像大小，宽高，单位为英寸。</li><li><code>dpi</code> 图像的分辨率，每英寸多少个像素。</li><li><code>facecolor</code> 背景颜色。</li><li><code>edgecolor</code> 边框颜色。</li><li><code>frameon</code> 是否显示边框。</li></ul><p>用例：</p><p><code>plt.figure(figsize=(20, 8), dpi=80)``figsize</code> </p><h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><pre class=" language-lang-python"><code class="language-lang-python">plt.savefig("./xxx.svg")</code></pre><p>保存图片到本地，支持 <code>svg</code> 矢量图形。</p><h4 id="设置坐标轴"><a href="#设置坐标轴" class="headerlink" title="设置坐标轴"></a>设置坐标轴</h4><p>以x轴为例。</p><pre class=" language-lang-python"><code class="language-lang-python">x_ticks = [i/2 for i in range(4, 49)]plt.xticks(x_ticks[::3])</code></pre><p>从2开始，每隔1.5个单位显示一个刻度。</p><p>还可以起别名。</p><pre class=" language-lang-python"><code class="language-lang-python">x_ticks = [i/2 for i in range(4, 49)]x_labels = ["h" + str(i) for i in range(1, 14)]plt.xticks(x_ticks[::3], x_labels)</code></pre><p>字体旋转 <code>rotation</code> 后接旋转度数。</p><pre class=" language-lang-python"><code class="language-lang-python">plt.xticks(list(range(120))[::3], labels=x[::3], rotation=45)</code></pre><p>y轴即 <code>plt.yticks</code> </p><pre class=" language-lang-python"><code class="language-lang-python">plt.yticks(range(min(y), max(y) + 1))</code></pre><h4 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h4><p>查看 <code>linux</code> 有哪些字体： <code>fc-list</code> 有哪些中文字体 <code>fc-list :lang=zh</code></p><pre class=" language-lang-python"><code class="language-lang-python">import matplotlibfont = {"family": "Noto Sans Mono",        "weight": "bold",        "size": "larger"        }matplotlib.rc("font", **font)</code></pre><p>或者：</p><pre class=" language-lang-python"><code class="language-lang-python">from matplotlib import font_managermy_font = font_manager.FontProperties(    fname="/usr/share/fonts/opentype/noto/NotoSansCJK-Bold.ttc")plt.xticks(list(range(120))[::3], labels=x[::3], rotation=45,           fontproperties=my_font)</code></pre><blockquote><ul><li><p>family: A list of font names in decreasing order of priority.<br>The items may include a generic font family name, either<br>‘serif’, ‘sans-serif’, ‘cursive’, ‘fantasy’, or ‘monospace’.<br>In that case, the actual font to be used will be looked up<br>from the associated rcParam.</p></li><li><p>style: Either ‘normal’, ‘italic’ or ‘oblique’.</p></li><li><p>variant: Either ‘normal’ or ‘small-caps’.</p></li><li><p>stretch: A numeric value in the range 0-1000 or one of<br>‘ultra-condensed’, ‘extra-condensed’, ‘condensed’,<br>‘semi-condensed’, ‘normal’, ‘semi-expanded’, ‘expanded’,<br>‘extra-expanded’ or ‘ultra-expanded’</p></li><li><p>weight: A numeric value in the range 0-1000 or one of<br>‘ultralight’, ‘light’, ‘normal’, ‘regular’, ‘book’, ‘medium’,<br>‘roman’, ‘semibold’, ‘demibold’, ‘demi’, ‘bold’, ‘heavy’,<br>‘extra bold’, ‘black’</p></li><li><p>size: Either an relative value of ‘xx-small’, ‘x-small’,<br>‘small’, ‘medium’, ‘large’, ‘x-large’, ‘xx-large’ or an<br>absolute font size, e.g., 12</p></li></ul></blockquote><h4 id="添加描述信息"><a href="#添加描述信息" class="headerlink" title="添加描述信息"></a>添加描述信息</h4><pre class=" language-lang-python"><code class="language-lang-python">plt.xlabel("时间", fontproperties=my_font)plt.ylabel("温度 单位(摄氏度)", fontproperties=my_font)plt.title("10～12点每分钟气温变化情况", fontproperties=my_font)</code></pre><h4 id="绘制网格"><a href="#绘制网格" class="headerlink" title="绘制网格"></a>绘制网格</h4><pre class=" language-lang-python"><code class="language-lang-python">plt.grid()</code></pre><ul><li><code>alpha</code> 设置透明度。范围 <code>0~1</code></li><li><code>axis</code> 显示哪个轴的网格 <code>axis='x'</code> 显示 <code>x</code> 轴，<code>axis='y</code> 显示 <code>y</code>  轴，<code>axis='both</code> 都显示。</li><li><code>color</code> 设置网格线颜色。</li><li><code>linestyle</code> 线条风格，<code>plt.grid(linestyle='-.')</code></li></ul><h4 id="绘制多次图形"><a href="#绘制多次图形" class="headerlink" title="绘制多次图形"></a>绘制多次图形</h4><pre class=" language-lang-python"><code class="language-lang-python">plt.plot(x, y1, color="green", label="XX1")plt.plot(x, y2, color="blue", label="XX2")plt.legend(prop=my_font)</code></pre><p>多次调用 <code>plot</code> 方法即可，为了区分，给 <code>plot</code> 方法传入 <code>label</code> 参数，最后调用 <code>legend</code> 方法显示即可。</p><h3 id="Ⅱ-绘制散点图"><a href="#Ⅱ-绘制散点图" class="headerlink" title="Ⅱ. 绘制散点图"></a>Ⅱ. 绘制散点图</h3><p>跟绘制折线图没太大却别。</p><p>把 <code>plt.plot()</code> 改成 <code>plt.scatter()</code> 即可。</p><h4 id="隐藏坐标轴"><a href="#隐藏坐标轴" class="headerlink" title="隐藏坐标轴"></a>隐藏坐标轴</h4><pre class=" language-lang-python"><code class="language-lang-python">plt.axes().get_xaxis().set_visible(False)plt.axes().get_yaxis().set_visible(False)</code></pre><h3 id="Ⅲ-绘制条形图"><a href="#Ⅲ-绘制条形图" class="headerlink" title="Ⅲ. 绘制条形图"></a>Ⅲ. 绘制条形图</h3><p>方法 <code>plt.bar()</code> 绘制竖直条形图，方法 <code>plt.barh()</code> 绘制横向条形图。</p><pre class=" language-lang-python"><code class="language-lang-python">plt.bar(x, y width=bar_width, color="blue", label="xxx"plt.barh(x, y height=bar_width, color="red", label="xxx"</code></pre><h3 id="Ⅳ-绘制直方图"><a href="#Ⅳ-绘制直方图" class="headerlink" title="Ⅳ. 绘制直方图"></a>Ⅳ. 绘制直方图</h3><h4 id="直方图与条形图区别"><a href="#直方图与条形图区别" class="headerlink" title="直方图与条形图区别"></a>直方图与条形图区别</h4><ol><li><p>条形图 是用条形的 “长度” 表示各类别频数的多少，其宽度（表示类别）则是固定的。</p></li><li><p>直方图 是用 “面积” 表示各组频数的多少，矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，因此其高度与宽度均有意义。<script type="math/tex">组数 = \frac{极差}{组距}</script></p></li><li>条形图主要用于展示分类数据，而直方图则主要用于展示数据型数据。’</li></ol><h4 id="频数分布直方图"><a href="#频数分布直方图" class="headerlink" title="频数分布直方图"></a>频数分布直方图</h4><pre class=" language-lang-python"><code class="language-lang-python">d = 3num_bins = (max(a) - min(a)) // dplt.figure(figsize=(20, 8), dpi=80)plt.hist(a, num_bins)plt.xticks(range(min(a), max(a) + d, d))plt.grid()plt.show()</code></pre><h4 id="频率分布直方图"><a href="#频率分布直方图" class="headerlink" title="频率分布直方图"></a>频率分布直方图</h4><pre class=" language-lang-python"><code class="language-lang-python">d = 3num_bins = (max(a) - min(a)) // dplt.figure(figsize=(20, 8), dpi=80)plt.hist(a, num_bins, density=True)plt.xticks(range(min(a), max(a) + d, d))plt.grid()plt.show()</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个内容太多了，只罗列了一些比较常用的。更多的可以去看源码。</p><p>更多图形直接参考 <code>matplotlib</code> <a href="https://matplotlib.org/gallery/index.html">官方文档</a> </p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学计算Numpy</title>
      <link href="2020/08/16/python/2020/ke-xue-ji-suan-numpy/"/>
      <url>2020/08/16/python/2020/ke-xue-ji-suan-numpy/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Numpy"><a href="#什么是Numpy" class="headerlink" title="什么是Numpy"></a>什么是Numpy</h2><blockquote><p>NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：</p><ul><li>一个强大的N维数组对象 ndarray</li><li>广播功能函数</li><li>整合 C/C++/Fortran 代码的工具</li><li>线性代数、傅里叶变换、随机数生成等功能</li></ul></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Ⅰ-创建ndarray"><a href="#Ⅰ-创建ndarray" class="headerlink" title="Ⅰ. 创建ndarray"></a>Ⅰ. 创建ndarray</h3><p>调用 <code>array()</code> 方法即可。</p><pre class=" language-lang-python"><code class="language-lang-python">def array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</code></pre><p>参数：</p><ul><li><code>object</code> 数组或嵌套的数列。</li><li><code>dtype</code> 数组元素的数据类型。</li><li><code>copy</code> 对象是否需要复制。</li><li><code>order</code> 创建数组的样式,，C为行方向，F为列方向，A原顺序，K元素在内存中的出现顺序。</li><li><code>subok</code> 默认返回一个与基类类型一致的数组。</li><li><code>ndmin</code> 指定生成数组的最小维度。</li></ul><p>还可以使用：</p><pre class=" language-lang-python"><code class="language-lang-python">numpy.arange(12) # 创建一个一维数组。`# array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])`numpy.arange(12).reshape(3, 4)  # 创建一个3行4列的数组。"""array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])"""numpy.arange(12).reshape(2, 2, 3) # 创建一个三维数组"""array([[[ 0,  1,  2],        [ 3,  4,  5]],       [[ 6,  7,  8],        [ 9, 10, 11]]])"""</code></pre><p>怎么理解三维数组，简单的来说，我们把第一维看成数组分成了多少块，第二维就是每块有机房，第三维就是有几列。</p><h3 id="Ⅱ-查看数据类型"><a href="#Ⅱ-查看数据类型" class="headerlink" title="Ⅱ. 查看数据类型"></a>Ⅱ. 查看数据类型</h3><p>调用方法 <code>dtype</code> 即可。</p><pre class=" language-lang-python"><code class="language-lang-python">t1 = np.arange(18).reshape(3, 3, 2)t1.detype"""dtype('int64')"""</code></pre><p>更多数据类型请参考 <a href="https://www.numpy.org.cn/user/basics/types.html#数组类型之间的转换">numpy中文网</a></p><h3 id="Ⅲ-查看数组维度"><a href="#Ⅲ-查看数组维度" class="headerlink" title="Ⅲ. 查看数组维度"></a>Ⅲ. 查看数组维度</h3><p>调用 <code>shape</code> 方法即可。</p><pre class=" language-lang-python"><code class="language-lang-python">import numpy as npt1 = np.array([[1, 2, 3], [4, 5, 6]])t1.shape# (2, 3)</code></pre><p><code>shape</code> 方法给我们返回一个元组。</p><p>调用 <code>reshape()</code> 方法改变数组形状。</p><pre class=" language-lang-python"><code class="language-lang-python">t2 = t1.reshape(3, 2)"""array([[1, 2],       [3, 4],       [5, 6]])"""</code></pre><p>调用 <code>reshape()</code> 方法后，原来的数组形状是不变的，返回值返回变形后的新数组。</p><p>把数组转化为一维数组。</p><pre class=" language-lang-python"><code class="language-lang-python">t3 = t2.flatten()"""array([1, 2, 3, 4, 5, 6])"""</code></pre><p>还可以用</p><pre class=" language-lang-python"><code class="language-lang-python">t4 = t2.reshape(6,)"""array([1, 2, 3, 4, 5, 6])"""</code></pre><p>或者</p><pre class=" language-lang-python"><code class="language-lang-python">t5 = t2.reshape(t2.shape[0] * t2.shape[1], )  """array([1, 2, 3, 4, 5, 6])"""</code></pre><p>因为 <code>shape</code>  方法返回一个 <code>tuple</code> 所以第一个是行，第二个是列，行×列就是数组总个数。</p><p>转换成二维，三维方法一样 <code>t.reshape(2, 3)</code> 把数组 <code>t</code> 转化为2行3列的数组。</p><h3 id="Ⅳ-数组的计算"><a href="#Ⅳ-数组的计算" class="headerlink" title="Ⅳ. 数组的计算"></a>Ⅳ. 数组的计算</h3><h4 id="数组与数字"><a href="#数组与数字" class="headerlink" title="数组与数字"></a>数组与数字</h4><p>数字和数组里面的每个数字相加、相减、相乘、相除。</p><pre class=" language-lang-python"><code class="language-lang-python">t = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]) t += 2"""array([[[ 3,  4,  5],        [ 6,  7,  8],        [ 9, 10, 11]]])"""</code></pre><p>注意，这里除0，只会有警告，不会报错。</p><pre class=" language-lang-python"><code class="language-lang-python">t = np.array([0, 1, 2]) t /= 0# array([nan, inf, inf])</code></pre><p>这里的 <code>nan</code> 是由0除0产生的，即 <code>not a number</code> 不是一个数字</p><p>这里的 <code>inf</code> 是由其它数字除0产生的，即 无穷的意思。</p><h4 id="数组与数组"><a href="#数组与数组" class="headerlink" title="数组与数组"></a>数组与数组</h4><ol><li>当数组形状一样的时候，加减乘除都是对应位置的元素进行计算。</li></ol><pre class=" language-lang-python"><code class="language-lang-python">t1 = np.arange(12).reshape(3, 4) t2 = np.arange(100, 112).reshape(3, 4)   t1 + t2 """array([[100, 102, 104, 106],       [108, 110, 112, 114],       [116, 118, 120, 122]])"""</code></pre><ol><li><p>数组形状不一样时，如果两个数组的后缘维度(从后面开始算起的维度)的轴长度相符或其中一方长度为1时，是广播相容的。</p><p>比如，(3, 4)和 (4,)是可以计算的；(2, 3, 4)和(1, 3, 4)是可以计算的。</p></li></ol><pre class=" language-lang-python"><code class="language-lang-python">t1 = np.arange(12).reshape(3, 4) """array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])"""t3 = np.arange(4)# array([0, 1, 2, 3])t1 + t3"""array([[ 0,  2,  4,  6],       [ 4,  6,  8, 10],       [ 8, 10, 12, 14]])"""</code></pre><p>或者</p><pre class=" language-lang-python"><code class="language-lang-python">t1 = np.arange(12).reshape(3, 4) """array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])"""t4 = np.arange(3).reshape(3, 1) """array([[0],       [1],       [2]])"""t1 + t4"""array([[ 0,  1,  2,  3],       [ 5,  6,  7,  8],       [10, 11, 12, 13]])"""</code></pre><h3 id="Ⅴ-读取数据"><a href="#Ⅴ-读取数据" class="headerlink" title="Ⅴ. 读取数据"></a>Ⅴ. 读取数据</h3><p>这个功能用的不多，因为 <code>pandas</code> 太强了。</p><pre class=" language-lang-python"><code class="language-lang-python">import numpy as npnp.loadtxt(frame, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes', max_rows=None)</code></pre><p>参数：</p><ul><li><code>frame</code> 文件，字符串或者产生器，一般是文件的绝对路径或者相对路径。</li><li><code>dtype</code> 数据类型、文件的字符串以什么数据类型读入数组中。</li><li><code>comments</code> 跳过文件中指定参数开头的行。</li><li><code>delimiter</code> 读取文件中数据的分隔符。</li><li><code>converters</code> 对读取的数据进行预处理。</li><li><code>skiprows</code> 选择跳过的行数，一般跳过第一行表头。</li><li><code>uescols</code> 指定需要读取的列。</li><li><code>unpack</code> 如果为True，读入属性将分别写入不同数组变量，False读入数据只写入一个数组变量。就是转置的意思。</li><li><code>encoding</code> 对读取文件进行预编码。</li><li><code>max_rows</code> 最大读取行数。</li></ul><h3 id="Ⅵ-数组的转置"><a href="#Ⅵ-数组的转置" class="headerlink" title="Ⅵ. 数组的转置"></a>Ⅵ. 数组的转置</h3><p>一维数组不需要转置。</p><p>二维数组转置</p><pre class=" language-lang-python"><code class="language-lang-python">import numpy as npt1 = np.arange(24).reshape(4, 6)t2 = t1.T"""array([[ 0,  6, 12, 18],       [ 1,  7, 13, 19],       [ 2,  8, 14, 20],       [ 3,  9, 15, 21],       [ 4, 10, 16, 22],       [ 5, 11, 17, 23]])"""t3 = t1.transpose()"""array([[ 0,  6, 12, 18],       [ 1,  7, 13, 19],       [ 2,  8, 14, 20],       [ 3,  9, 15, 21],       [ 4, 10, 16, 22],       [ 5, 11, 17, 23]])"""</code></pre><p>三维及三维以上。</p><pre class=" language-lang-python"><code class="language-lang-python">t4 = np.arange(16).reshape(2, 2, 4) t4.transpose((1, 0, 2)) """array([[[ 0,  1,  2,  3],        [ 8,  9, 10, 11]],       [[ 4,  5,  6,  7],        [12, 13, 14, 15]]])"""t4.swapaxes(1, 0)  """array([[[ 0,  1,  2,  3],        [ 8,  9, 10, 11]],       [[ 4,  5,  6,  7],        [12, 13, 14, 15]]])"""</code></pre><p> <code>transpose()</code> 接受一个元组，原来的轴是 <code>(0, 1, 2)</code>  通过 <code>transpose()</code> 方法把原来的 <code>0</code> 轴变成了 <code>1</code> 轴。</p><p>三维的数组的轴，就看成一个 <code>xyz</code> 坐标系即可。<code>x</code> 轴对应于 <code>0</code>  轴，<code>y</code> 轴对应于 <code>1</code> 轴，<code>z</code> 轴对应于 <code>2</code> 轴。</p><h3 id="Ⅶ-numpy索引和切片"><a href="#Ⅶ-numpy索引和切片" class="headerlink" title="Ⅶ. numpy索引和切片"></a>Ⅶ. numpy索引和切片</h3><h4 id="取行"><a href="#取行" class="headerlink" title="取行"></a>取行</h4><pre class=" language-lang-python"><code class="language-lang-python">import numpy as npt = np.arange(24).reshape(4, 6)"""array([[ 0,  1,  2,  3,  4,  5],       [ 6,  7,  8,  9, 10, 11],       [12, 13, 14, 15, 16, 17],       [18, 19, 20, 21, 22, 23]])"""t[1] # t[1, :]"""array([0, 1, 2, 3, 4, 5])"""t[1::] # t[1::, :]"""array([[ 6,  7,  8,  9, 10, 11],       [12, 13, 14, 15, 16, 17],       [18, 19, 20, 21, 22, 23]])"""t[[1, 3]] # t[[1, 3], :]"""array([[ 6,  7,  8,  9, 10, 11],       [18, 19, 20, 21, 22, 23]])"""</code></pre><h4 id="取列"><a href="#取列" class="headerlink" title="取列"></a>取列</h4><pre class=" language-lang-python"><code class="language-lang-python">t[:,2]"""array([ 2,  8, 14, 20])"""# 取列[:,2]前面的:不能省略, 表示所有行都要t[:, 2::]  """array([[ 2,  3,  4,  5],       [ 8,  9, 10, 11],       [14, 15, 16, 17],       [20, 21, 22, 23]])"""t[:, [1, 2, 3]]                                                                                               """array([[ 1,  2,  3],       [ 7,  8,  9],       [13, 14, 15],       [19, 20, 21]])"""</code></pre><h4 id="同时取行和列"><a href="#同时取行和列" class="headerlink" title="同时取行和列"></a>同时取行和列</h4><pre class=" language-lang-python"><code class="language-lang-python">t[2,3]# 15 表示取3行4列的元素t[1:3,2:5] """array([[ 8,  9, 10],       [14, 15, 16]])"""t[[0, 1, 2], [2, 3, 4]] """array([ 2,  9, 16])"""</code></pre><h3 id="Ⅷ-修改数组值"><a href="#Ⅷ-修改数组值" class="headerlink" title="Ⅷ. 修改数组值"></a>Ⅷ. 修改数组值</h3><pre class=" language-lang-python"><code class="language-lang-python">t < 10"""array([[ True,  True,  True,  True,  True,  True],       [ True,  True,  True,  True, False, False],       [False, False, False, False, False, False],       [False, False, False, False, False, False]])"""t[t < 10] = 100"""array([[100, 100, 100, 100, 100, 100],       [100, 100, 100, 100,  10,  11],       [ 12,  13,  14,  15,  16,  17],       [ 18,  19,  20,  21,  22,  23]])"""t = np.arange(24).reshape(4,6) """array([[ 0,  1,  2,  3,  4,  5],       [ 6,  7,  8,  9, 10, 11],       [12, 13, 14, 15, 16, 17],       [18, 19, 20, 21, 22, 23]])"""np.where(t < 10, 0, 100)"""array([[  0,   0,   0,   0,   0,   0],       [  0,   0,   0,   0, 100, 100],       [100, 100, 100, 100, 100, 100],       [100, 100, 100, 100, 100, 100]])"""t = np.arange(24).reshape(4,6) t.clip(10, 18) """array([[10, 10, 10, 10, 10, 10],       [10, 10, 10, 10, 10, 11],       [12, 13, 14, 15, 16, 17],       [18, 18, 18, 18, 18, 18]])小于10的替换成10，大于18的替换为18，不能替换nan"""t = t.astype(float)"""array([[ 0.,  1.,  2.,  3.,  4.,  5.],       [ 6.,  7.,  8.,  9., 10., 11.],       [12., 13., 14., 15., 16., 17.],       [18., 19., 20., 21., 22., 23.]])"""t[3, 3] = np.nan"""array([[ 0.,  1.,  2.,  3.,  4.,  5.],       [ 6.,  7.,  8.,  9., 10., 11.],       [12., 13., 14., 15., 16., 17.],       [18., 19., 20., nan, 22., 23.]])"""t.clip(10, 18)"""array([[10., 10., 10., 10., 10., 10.],       [10., 10., 10., 10., 10., 11.],       [12., 13., 14., 15., 16., 17.],       [18., 18., 18., nan, 18., 18.]])"""</code></pre><h3 id="Ⅸ-nan特性"><a href="#Ⅸ-nan特性" class="headerlink" title="Ⅸ. nan特性"></a>Ⅸ. nan特性</h3><p>两个 <code>nan</code>  是不相等的。</p><pre class=" language-lang-python"><code class="language-lang-python">np.nan == np.nan                                                                                            # False</code></pre><p>根据这个特性，判断一个数组中有多少个 <code>nan</code></p><pre class=" language-lang-python"><code class="language-lang-python">t                                                                                                """array([[ 0.,  1.,  2.,  3.,  4.,  5.],       [ 6.,  7.,  8.,  9., 10., 11.],       [12., 13., 14., 15., 16., 17.],       [18., 19., 20., nan, 22., 23.]])"""np.count_nonzero(t!=t)# 1</code></pre><p> 判断一个数字是不是 <code>nan</code></p><pre class=" language-lang-python"><code class="language-lang-python">np.isnan(t[3, 3])# Truenp.isnan(t)"""array([[False, False, False, False, False, False],       [False, False, False, False, False, False],       [False, False, False, False, False, False],       [False, False, False,  True, False, False]])"""t[np.isnan(t)] = 0 """array([[ 0.,  1.,  2.,  3.,  4.,  5.],       [ 6.,  7.,  8.,  9., 10., 11.],       [12., 13., 14., 15., 16., 17.],       [18., 19., 20.,  0., 22., 23.]])"""</code></pre><p><code>nan</code> 与任何值计算都为 <code>nan</code></p><pre class=" language-lang-python"><code class="language-lang-python">t                                                                                                """array([[ 0.,  1.,  2.,  3.,  4.,  5.],       [ 6.,  7.,  8.,  9., 10., 11.],       [12., 13., 14., 15., 16., 17.],       [18., 19., 20., nan, 22., 23.]])"""t.sum() # np.sum(t)# nannp.sum(t, axis=0)"""array([36., 40., 44., nan, 52., 56.])"""</code></pre><p>求和 <code>np.sum()</code> 方法里的参数 <code>axis</code> 表示轴的意思，一维数组一个轴，就是 <code>0</code> 二维数组两个轴 <code>0, 1</code> 三维数组三个轴 <code>0, 1, 2</code> </p><h3 id="Ⅹ-numpy中常用的统计函数"><a href="#Ⅹ-numpy中常用的统计函数" class="headerlink" title="Ⅹ. numpy中常用的统计函数"></a>Ⅹ. numpy中常用的统计函数</h3><ul><li>求和 <code>np.sum(a, axis=None)</code></li><li>均值 <code>np.mean(a, axis=None)</code></li><li>中值 <code>np.median(a, axis=None)</code></li><li>最大值 <code>np.max(a, axis=None)</code></li><li>最小值 <code>np.min(a, axis=None)</code></li><li>极差 <code>np.ptp(a, axis=None)</code></li><li>标准差 <code>np.sed(a, axis=None)</code></li></ul><p>标准差公式 <script type="math/tex">\sigma = \sqrt{\frac{1}{N} \sum_{i=1}^{N}(x_i - \mu)^2}</script></p><p>这里都只列举的两个参数，更多参数作用可以参考源代码。</p><h3 id="Ⅺ-数组的拼接"><a href="#Ⅺ-数组的拼接" class="headerlink" title="Ⅺ. 数组的拼接"></a>Ⅺ. 数组的拼接</h3><h4 id="竖直拼接"><a href="#竖直拼接" class="headerlink" title="竖直拼接"></a>竖直拼接</h4><pre class=" language-lang-python"><code class="language-lang-python">t1 = np.arange(24).reshape(4, 6)"""array([[ 0,  1,  2,  3,  4,  5],       [ 6,  7,  8,  9, 10, 11],       [12, 13, 14, 15, 16, 17],       [18, 19, 20, 21, 22, 23]])"""t2 = np.arange(24, 48).reshape(4, 6)  """array([[24, 25, 26, 27, 28, 29],       [30, 31, 32, 33, 34, 35],       [36, 37, 38, 39, 40, 41],       [42, 43, 44, 45, 46, 47]])"""np.vstack((t1, t2)) """array([[ 0,  1,  2,  3,  4,  5],       [ 6,  7,  8,  9, 10, 11],       [12, 13, 14, 15, 16, 17],       [18, 19, 20, 21, 22, 23],       [24, 25, 26, 27, 28, 29],       [30, 31, 32, 33, 34, 35],       [36, 37, 38, 39, 40, 41],       [42, 43, 44, 45, 46, 47]])"""</code></pre><h4 id="水平拼接"><a href="#水平拼接" class="headerlink" title="水平拼接"></a>水平拼接</h4><pre class=" language-lang-python"><code class="language-lang-python">np.hstack((t1, t2))"""array([[ 0,  1,  2,  3,  4,  5, 24, 25, 26, 27, 28, 29],       [ 6,  7,  8,  9, 10, 11, 30, 31, 32, 33, 34, 35],       [12, 13, 14, 15, 16, 17, 36, 37, 38, 39, 40, 41],       [18, 19, 20, 21, 22, 23, 42, 43, 44, 45, 46, 47]])"""</code></pre><h3 id="XII-其他方法"><a href="#XII-其他方法" class="headerlink" title="XII. 其他方法"></a>XII. 其他方法</h3><ul><li>获取最大最小值位置，<code>np.argmax(a, axis=None)</code> <code>np.argmin(a, axis=None)</code> </li><li>创建一个全为0的数组，<code>np.zeros((行, 列))</code></li><li>创建一个全为1的数组，<code>np.ones((行, 列))</code></li><li>创建一个对角线为1的正方形数组(方阵)，<code>np.eys(3)</code></li></ul><h4 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h4><ul><li><code>np.random.rand(d0, d1, d2, ... , dn)</code> n维度均匀分布随机数组，范围 <code>0 ~ 1</code></li><li><code>np.random.randn(d0, d1, d2, ... , dn)</code> n维度正态分布随机数组，平均数0，标准差1</li><li><code>np.random.randint(low, high, (行, 列))</code> 范围 <code>[low, high)</code></li><li><code>np.random.uniform(low, high, (行, 列)</code> 浮点数</li><li><code>np.random.normal(loc, scale, (行, 列))</code> 指定正态分布抽取样本，分布中心 <code>loc</code> ，标准差 <code>scale</code></li><li><code>np.random.seed()</code> 随机种子，c/c++常用操作 <code>srand((unisgned)time(NULL))</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20.04安装Anaconda</title>
      <link href="2020/08/16/linux/2020/ubuntu20.04-an-zhuang-anaconda/"/>
      <url>2020/08/16/linux/2020/ubuntu20.04-an-zhuang-anaconda/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://repo.anaconda.com/archive/index.html">官网</a></p><p> 下载最新的就好了。</p><p>官网国内速度不行，建议去<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">清华开源镜像站</a>下载。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>切换到下载Anaconda目录。</p><p>打开终端，输入：</p><p><code>zsh Anaconda*-*.*.*-Linux-x86_64.sh</code></p><p>如果你用的 <code>bash</code> 请把 <code>zsh</code> 改为 <code>bash</code></p><p>一路回车，要输入的地方输入yes即可。</p><p>最后看到 <code>Thank you for installing Anaconda3</code> 说明安装成功。</p><p>安装成功了，Anaconda会自动在 <code>~/.zshrc 或 ~/.bashrc</code> 配置环境变量。</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>Anaconda默认安装在家目录下，有个 <code>anaconda3</code> 文件夹，要想卸载 <code>Anaconda</code> 用命令 <code>rm -rf anaconda3</code> 即可卸载。</p><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p>安装了 <code>anaconda</code> 后，会发现命令行前出现了  <code>(base)</code> ，这是因为 <code>anaconda</code> 的基础环境每次都被自动激活了。</p><p>介绍一种简单的方式，编辑 <code>~/.zshrc</code> 文件，同理，如果用的 <code>bash</code> 就是 <code>~/.bashrc</code></p><p>最后面增加一行 <code>conda deactivate</code></p><p>退出，终端输入 <code>source ~/.zshrc</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1009</title>
      <link href="2020/08/16/pat-jia-zu/2020/pat1011/"/>
      <url>2020/08/16/pat-jia-zu/2020/pat1011/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p><p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results — namely <code>W</code> for win, <code>T</code> for tie, and <code>L</code> for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p><p>For example, 3 games’ odds are given as the following:</p><blockquote><p> W    T    L<br>1.1  2.5  1.7<br>1.2  3.1  1.6<br>4.1  1.2  1.1</p></blockquote><p>To obtain the maximum profit, one must buy <code>W</code> for the 3rd game, <code>T</code> for the 2nd game, and <code>T</code> for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to <code>W</code>, <code>T</code> and <code>L</code>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>1.1 2.5 1.7<br>1.2 3.1 1.6<br>4.1 1.2 1.1</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>T T W 39.31</p></blockquote></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>翻译：随着2010年国际足联世界杯的举行，全世界的足球迷们都变得越来越兴奋，因为来自最好球队的最好球员们正在为南非世界</p><p>杯奖杯而战。同样，足球投注的球迷们也把他们的钱放在了他们的嘴上，通过各种形式的世界杯赌注。</p><p>中国足球彩票提供了“三赢”游戏。获胜的规则很简单：先从三个游戏中选择一个。然后，对于每一个选定的游戏，赌三个可能的结</p><p>果之一，W代表赢，T代表平局，L代表输。每个结果都有一个奇数。胜利者的奇数是三个赔率乘以65%的乘积。</p><p>例如，3场比赛的赔率如下：</p><blockquote><p> W    T    L<br>1.1  2.5  1.7<br>1.2  3.1  1.6<br>4.1  1.2  1.1</p></blockquote><p>为了获得最大的利润，第三局必须买W，第二局买T，第一局买T。如果每注2元，则最大利润为（4.1×3.1×2.5×65%－1）×2=39.31元（精确到小数点后2位）。</p><p>输入：每个输入案例包含一个输入案例。每个案例包含3个游戏的投注信息。每一场比赛都有三个不同的赔率，分别对应于W、T和L。</p><p>输出：对于每个测试用例，在一行中打印每个游戏的最佳赌注，最大利润精确到小数点后2位。字符和数字必须用一个空格隔开。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <cmath>#include <iostream>#include <map>#include <set>#include <string>#include <unordered_map>#include <unordered_set>#include <vector>using namespace std;int main() {  vector<char> vec(3);  vec[0] = 'W';  vec[1] = 'T';  vec[2] = 'L';  double ans = 1.0;  int p[3], index, c = 0;  for (int i = 0; i < 3; ++i) {    double temp = 0.0;    for (int j = 0; j < 3; ++j) {      double x;      cin >> x;      if (x >= temp) {        temp = x;        index = j;      }    }    p[c++] = index;    ans *= temp;  }  for (int i = 0; i < 3; ++i) {    printf("%c ", vec[p[i]]);  }  printf("%.2lf\n", (ans * 0.65 - 1) * 2);  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络模型</title>
      <link href="2020/08/13/linux/2020/wang-luo-mo-xing/"/>
      <url>2020/08/13/linux/2020/wang-luo-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>简单来讲，IP地址就是用来在网络中标记一台电脑的。在本地局域网是唯一的。</p><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>每个IP地址由网络地址和主机地址组成。</p><ul><li>A类IP地址，IP地址前8为表示网络ID，后24位表示主机ID。</li><li>B类IP地址，IP地址前16位表示网络ID，后16位表示主机ID。</li><li>C类IP地址，IP地址前24位表示网络ID，后8位表示主机ID。</li></ul><p>怎么区别？</p><ul><li>如果32位的二进制地址以0开头，就是A类地址。</li><li>如果32位的二进制地址以10开头，就是B类地址。</li><li>如果32位的二进制地址以110开头，就是C类地址。</li></ul><p>三类网络地址范围</p><div class="table-container"><table><thead><tr><th style="text-align:center">地址类</th><th style="text-align:center">二进制地址前几位值</th><th style="text-align:center">点分十进制地址中的第一个字段</th><th style="text-align:center">排除地址</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">0</td><td style="text-align:center">0~127</td><td style="text-align:center">10.0.0.0~10.255.255.255 <br>127.0.0.0~127.255.255.255</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">10</td><td style="text-align:center">128~191</td><td style="text-align:center">172.16.0.0~172.31.255.255</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">110</td><td style="text-align:center">192~223</td><td style="text-align:center">192.168.0.0~192.169.255.255</td></tr></tbody></table></div><p>此外，还有特殊用途的D类和E类地址</p><ul><li>D类IP地址，前4位总是1110，对应于十进制的224~239，一般用于多点广播。</li><li>E类IP地址，前五位对应于11110，对应于十进制的240~247，仅作实验和开发用。</li></ul><h3 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h3><h4 id="私有IP"><a href="#私有IP" class="headerlink" title="私有IP"></a>私有IP</h4><p>这些私有IP不会被连接到Internet，也就是我们局域网的IP地址。</p><p>范围</p><blockquote><p>10.0.0.0～10.255.255.255</p><p>172.16.0.0～172.31.255.255</p><p>192.168.0.0～192.168.255.255</p></blockquote><p><code>127.0.0.1~127.255.255.255</code> 用于回路测试。</p><p><code>127.0.0.1</code> 就可以代表本机IP地址。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口就好比，一间房子里面的很多门，端口是由端口号来标记的，端口号也可以理解为房门号。</p><p>在linux中，端口可以有 $2^{16}$ 65536个。 </p><h3 id="端口号分配"><a href="#端口号分配" class="headerlink" title="端口号分配"></a>端口号分配</h3><p>端口号肯定不能随便使用，按照一定规律分配。</p><ul><li><p>知名端口，是众所周知的端口号，范围从0到1023，如果一个程序需要使用知名端口需要有root权限。</p><pre><code>80端口分配给HTTP服务21端口分配给FTP服务</code></pre></li><li><p>动态端口，范围是从1024到65535，动态分配是指当一个系统程序或应用程序程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。</p></li></ul><h3 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h3><p>用 <code>netstat －an</code> 查看端口状态。</p><p><code>lsof -i [tcp/udp]:端口</code> 查看莫个端口是否被占用。</p><h2 id="TCP-IP协议簇"><a href="#TCP-IP协议簇" class="headerlink" title="TCP/IP协议簇"></a>TCP/IP协议簇</h2><p>协议就是，规定某种东西用用某种规定来解决，解决的方法必须按照协议内容来。</p><p>因为互联网协议包含了上百种的协议标准，但是最重要的两个是TCP和IP协议，所以把互联网的协议简称TCP/IP协议簇。</p><h3 id="两层模型"><a href="#两层模型" class="headerlink" title="两层模型"></a>两层模型</h3><p>TCP/IP模型</p><p><img src="https://i.loli.net/2020/08/14/pvNkws3U9RjHFqy.png" alt="TCP/IP模型"></p><p>TCP/IP示意图</p><p><img src="https://i.loli.net/2020/08/14/uQi6DFEKO2VGYhS.png" alt="TCP/IP示意图"></p><p>OSI模型</p><p><img src="https://i.loli.net/2020/08/14/7XpewqW21Qvmufj.png" alt="OSI模型"></p><p>网际层也称为：网络层；网络接口层也称为：链路层。</p><h3 id="以太网帧协议-网络接口层"><a href="#以太网帧协议-网络接口层" class="headerlink" title="以太网帧协议(网络接口层)"></a>以太网帧协议(网络接口层)</h3><p>网络接口层的软件从网络层接收数据报，把它转化为符合物理网络规范的形式。</p><p>一般以太网帧包括如下内容：</p><ul><li>前导码，表示帧起始的一系列比特(一共八字节，最后一个字节是帧起始符)。</li><li>目的地址，接收帧网络适配器的6字节物理地址。</li><li>源地址，发送帧的网络适配器的六字节物理地址。</li><li>可选的VLAN标记，目的是允许多个虚拟LAN通过一个网络交换机运行。</li><li>长度，2字节，16比特字段，表示数据字段的长度。</li><li>ARP数据，帧中传输的数据。</li><li>帧校验序列(FCS)，帧的4字节，32比特校验和。</li></ul><p><strong>简单的讲，以太网帧协议就是通过IP获取MAC地址，再根据MAC地址进行数据发送。</strong> </p><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP报头字段</p><ul><li>版本，IPV4，IPV6，前4位字段。</li><li>网际报头长度(IHL)，这个4位字段表示IP报头以32位字节为单位长度。IP报头最小长度是5个32位字，相应的二进制表示是0101。</li><li>服务类型，源IP能够指定特殊的路由信息。</li><li>总长度，这个16位的字段表示IP数据报的长度，单位是字节，包含了IP报头和数据载荷。</li><li>标头，这个16位的字段是一个逐渐增大的序列号，分配给源IP发出的信息。</li><li>标记，这个字段表示分段可能性。</li><li>分段偏移，这个13位字段是一个数值，被赋予每个连续的分段。</li><li>生存时间(TTL)，这个位字段表示数据报在被抛弃之前能够保留的时间或路由器跳数。</li><li>协议，这个8位字段表示接收数据载荷的协议。<ul><li>ICMP协议，协议标识1</li><li>TCP协议，协议标识6</li><li>UDP协议，协议标识17</li></ul></li><li>报头检验和，这个字段包含16位的检验和，只用于校验报头本身的有效性。</li><li>源IP地址，这个32位的字段包含了数据报的源IP地址。</li><li>目的IP地址，这个32位的字段包含了数据报的目的IP地址。</li><li>IP选项，这个字段支持一些可选的报头设置，主要用于测试，调试和安全的目的。</li><li>填充，IP选项字段的长度不是固定的。</li><li>IP数据载荷，这个字段通常包含传递给TCP或UDP，ICMP或IGMP的数据。</li></ul><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>面向无连接的不安全的报式传输。</p><ul><li>连接的时候不会握手。</li><li>数据发送出去就不管了。</li></ul><p>UDP协议比较简单，数据包包含：</p><ul><li>源端口，这个字段占据UDP报头的前16位，通常包含发送数据包的应用程序所使用的UDP端口。</li><li>目的端口，这个16位字段包含的端口地址是接收端计算机上的UDP软件交付数据报时使用的端口。</li><li>长度，这个16位字段以字节位单位表示UDP数据报的长度。</li><li>校验和，这16位字段用于确定数据报在传输过程中是否损坏。</li></ul><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>面向连接的安全的流式传输</p><ul><li>连接的时候，进行三次握手。</li><li>数据发送的时候，会进行数据确认。<ul><li>数据丢失，会进行数据重传。</li></ul></li></ul><p>TCP协议数据格式：</p><ul><li>源端口，16位，分配给源计算机上的应用程序的端口号。</li><li>目的端口，16位，分配给目的计算机上的应用程序的端口号。</li><li>序列号，32号，当SYN标记不为1时，这个当前数据分段第一个字节的序列号；如果SYN的值是1，这个字段的值就是初始序列号(ISN)，用于对序列号进行同步。</li><li>确认号，32位，用于确认已经接收到的数据分段，其值是接收计算机即将接收的下一个序列号，也就是上一个接收到的字节的序列号加1。</li><li>数据偏移，4位，这个字段表示报头的长度，也就是告诉接收端的TCP软件数据从何开始。</li><li>保留，6位，保留为将来使用。</li><li>控制标记，分别占用1位，标记控制用于表示数据分段的特殊信息。</li><li>URG，为1时表示当前数据分段是紧急的，也会让“紧急指针”字段的值很重要。</li><li>ACK，为1时表示“确认号”字段是很重要、</li><li>PSH，为1时让TCP软件把目前发送的所有数据都通过管道传递给接收应用程序。</li><li>RST，为1时会重置连接。</li><li>SYN，为1时表示序列号会被同步，说明是一个连接的开始。</li><li>FIN，为1时表示发送端计算机已经没有数据需要发送了。</li><li>窗口，16位，用于流量控制的参数。</li><li>检验和，16位，用于校验数据分段的完整性。</li><li>紧急指针，16位，这个一个偏移量指针，指向标记紧急信息开始的序列号。</li><li>选项，指定一些可选设置中的某一项小设置。</li><li>填充，额外填充的0(根据需要)，以确保数据从32位的边界开始。</li><li>数据，分段中传输的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1009</title>
      <link href="2020/08/12/pat-jia-zu/2020/pat1009/"/>
      <url>2020/08/12/pat-jia-zu/2020/pat1009/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>This time, you are supposed to find <em>A</em>×<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p><em>K</em> <em>N</em>1 <em>a**N</em>1 <em>N</em>2 <em>a**N</em>2 … <em>N**K</em> <em>a<strong>N</strong>K</em></p><p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>N**i</em> and <em>a<strong>N</strong>i</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10, 0≤<em>N**K</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the product of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be <strong>NO</strong> extra space at the end of each line. Please be accurate up to 1 decimal place.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>3 3 3.6 2 6.0 1 1.6</p></blockquote></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这就是多项式的乘法，翻译请看 <a href="https://blog.csdn.net/qq_43826212/article/details/107752511">PAT1002</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <cmath>#include <iostream>#include <map>#include <set>#include <string>#include <unordered_map>#include <unordered_set>#include <vector>using namespace std;int main() {  // exp是指数, coe是系数  int n, m, exp;  float coe;  map<int, float> mp1;  map<int, float> mp2;  cin >> n;  for (int i = 0; i < n; ++i) {    cin >> exp >> coe;    mp1[exp] = coe;  }  cin >> m;  for (int i = 0; i < m; ++i) {    cin >> exp >> coe;    mp2[exp] = coe;  }  map<int, float, greater<int>> mp;  map<int, float>::iterator it1;  map<int, float>::iterator it2;  for (it1 = mp1.begin(); it1 != mp1.end(); ++it1) {    for (it2 = mp2.begin(); it2 != mp2.end(); ++it2) {      int exp = it1->first + it2->first;      float coe = it1->second * it2->second;      if (mp[exp] == 0) {        mp[exp] = coe;      } else {        mp[exp] += coe;      }    }  }  map<int, float, greater<int>>::iterator it;  int ans = 0;  for (it = mp.begin(); it != mp.end(); ++it) {    if (fabs(it->second - 0.0) < 0.000001) {      ++ans;    }  }  cout << ans;  for (it = mp.begin(); it != mp.end(); ++it) {    if (fabs(it->second - 0.0) < 0.000001) {      continue;    }    printf(" %d %.1f", it->first, it->second);  }  cout << endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1006</title>
      <link href="2020/08/10/pat-jia-zu/2020/pat1006/"/>
      <url>2020/08/10/pat-jia-zu/2020/pat1006/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer <em>M</em>, which is the total number of records, followed by <em>M</em> lines, each in the format:</p><blockquote><p>ID_number Sign_in_time Sign_out_time</p></blockquote><p>where times are given in the format <code>HH:MM:SS</code>, and <code>ID_number</code> is a string with no more than 15 characters.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p><p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>SC3021234 CS301133</p></blockquote></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意：每一天第一个到电脑室的人会打开门，最后一个离开的人将要锁门。给你每个人来电脑室和离开电脑室的时间，要你计算出谁开门和谁锁门。</p><p>输入：测试案列第一行是一个正整数M，表示每天进入电脑室的人，接下来是M行，每一行包括ID，进电脑室时间，离开电脑室时间，这些时间都是格式化好的。ID不会多于15个字符。</p><p>输出：对于每一个测试案列，输出第一个到达人的ID和最后一个离开人的ID。</p><p>注意：保证数据是一致的，也就是说，每个人的进入进入时间肯定早于离开时间，没有两个人同时到达和离开。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>#include <map>#include <queue>#include <set>#include <stack>#include <string>#include <unordered_map>#include <unordered_set>#include <vector>using namespace std;int main() {  int m;  cin >> m;  string id, in, out;  string first = "24:00:00", last = "00:00:00";  string unlock, lock;  for (int i = 0; i < m; ++i) {    cin >> id >> in >> out;    if (in < first) {      unlock = id;      first = in;    }    if (out > last) {      lock = id;      last = out;    }  }  cout << unlock << " " << lock << endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1007</title>
      <link href="2020/08/10/pat-jia-zu/2020/pat1007/"/>
      <url>2020/08/10/pat-jia-zu/2020/pat1007/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>Given a sequence of <em>K</em> integers { <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }. A continuous subsequence is defined to be { <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>10<br>-10 1 2 3 4 -5 -23 3 7 -21</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>10 1 4</p></blockquote></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意：给你一个k个整数的序列，连续子序列定义为 <script type="math/tex">{N_i, N_{i + 1}, N_{i + 2}, ..., N_j}, 1 \leq i \leq j \leq k</script> ，最大子序列是具有最大元素和的连续子序列。例如，给定 <script type="math/tex">{-2, 11, -4, 13, -5, -2}</script> ，它的最大子序列为 <script type="math/tex">{11, -4, 13}</script> ，最大和为20。</p><p>现在，你应该找到最大子序列和，并且找到最大子序列的第一个元素和最后一个元素。</p><p>输入：第一行整数包含一个正整数K，接下来是K个数字，每个数字用空格隔开。</p><p>输出：对于每个测试案列，输出最大子序列和，和最大子序列的第一个元素和最后一个。中间用空格隔开，但是最后不要有额外的空格。在案列中，最大子序列和可能不是唯一的，输出一组较小的即可。如果K个数字全是负数，最大子序列和被定义为0，你应该输出K个数字的第一个元素和最后一个。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道求连续子数组的最大和的升级版，不仅仅要我们输出最大子序列和，还要输出最大子序列的第一个元素和最后一个元素。</p><p>求连续子数组最大和，一道典型的dp题。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxSubArray(vector<int>& nums) {        int size = nums.size();        vector<int> dp(size + 1);        dp[0] = nums[0];        int ans = nums[0];        for (int i = 1; i < size; ++i) {            dp[i] = max(0, dp[i - 1]) + nums[i];            ans = max(ans, dp[i]);        }        return ans;    }};</code></pre><p>我们只要在连续子数组和的情况下，加上判断条件，就能得到最大子序列的第一个元素和最后一个。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>#include <queue>#include <string>#include <unordered_map>#include <vector>using namespace std;int main() {  int k;  cin >> k;  vector<int> nums(k);  for (int i = 0; i < k; ++i) {    int temp;    cin >> temp;    nums[i] = temp;  }  vector<int> dp(k + 1);  dp[0] = nums[0];  int ans = nums[0];  int left = 0, right = k - 1, temp = 0;  for (int i = 1; i < k; ++i) {    dp[i] = max(0, dp[i - 1]) + nums[i];    if (dp[i] > ans) {      ans = dp[i];      left = temp + 1;      right = i;    }    if (dp[i] < 0) {      temp = i;    }  }  if (ans < 0) {    ans = 0;  }  cout << ans << " " << nums[left] << " " << nums[right] << endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1008</title>
      <link href="2020/08/10/pat-jia-zu/2020/pat1008/"/>
      <url>2020/08/10/pat-jia-zu/2020/pat1008/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>The highest building in our city has only one elevator. A request list is made up with <em>N</em> positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p><p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a positive integer <em>N</em>, followed by <em>N</em> positive numbers. All the numbers in the input are less than 100.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the total time on a single line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>3 2 3 1</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>41</p></blockquote></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意：我们城市最高的建筑只有一部电梯。请求列表由N个正数组成。每个数字表示当前电梯停靠的层数。电梯上升一层需要6秒，下降一层需要4秒。电梯每次在相应楼层停5秒。</p><p>输入：包含一个正整数N，紧跟着N个正整数，每个输入的数字小于100。</p><p>输出：输出总时间。</p><p>这题，太easy了。直接写代码就行了。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>#include <string>#include <vector>using namespace std;int main() {  int n;  cin >> n;  int up = 6, stay = 5, down = 4;  vector<int> vec(n);  for (int i = 0; i < n; ++i) {    int temp;    cin >> temp;    vec[i] = temp;  }  int times = vec[0] * up + stay;  for (int i = 1; i < n; ++i) {    if (vec[i] > vec[i - 1]) {      times += (vec[i] - vec[i - 1]) * up;    } else {      times += (vec[i - 1] - vec[i]) * down;    }    times += stay;  }  cout << times << endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1003 迪杰斯特拉(Dijkstra)</title>
      <link href="2020/08/07/pat-jia-zu/2020/pat1003/"/>
      <url>2020/08/07/pat-jia-zu/2020/pat1003/</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>迪杰斯特拉(Dijkstra)是从一个顶点到其余各顶点的<a href="https://baike.baidu.com/item/最短路径">最短路径</a>算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用<a href="https://baike.baidu.com/item/贪心算法/5411800">贪心算法</a>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。 </p><p>讲白了，就是给你一张有很多城市的地图，要你求指定两个城市之间的最小距离。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p><img src="https://i.loli.net/2020/08/07/sZhSK5J7B8iT9WC.png" alt="带权有向图.png"></p><p>给定一个上述图，要求某两个点之间的最短路径，这就叫做 <strong>有权图单源最短路</strong> 。如果是要求任意两个点之间的最短路径，这就是 <strong>有权图无源最短路径</strong> ，无源最短路径用 <strong>Dijkstra</strong> 的时间复杂度就上去了，一般用 <strong>Floyd</strong> 算法了。</p><p><strong>Dijkstra</strong> 理解不难，一起模拟一遍就懂了。</p><p>为了方便模拟，我们把源点定义为V1。(这里V4-&gt;V5 的距离为2， 忘记写了)</p><p><img src="https://i.loli.net/2020/08/07/93XwZRqDMlv1rtm.png" alt="幻灯片1.PNG"></p><p><img src="https://i.loli.net/2020/08/07/BbhtDRWKGre2Swq.png" alt="幻灯片2.PNG"></p><p><img src="https://i.loli.net/2020/08/07/8RAToLw763brfht.png" alt="幻灯片3.PNG"></p><p><img src="https://i.loli.net/2020/08/07/iFMD14dxqe6hztp.png" alt="幻灯片4.PNG"></p><p><img src="https://i.loli.net/2020/08/07/RzTmBhLD7fEcnHM.png" alt="幻灯片5.PNG"></p><p><img src="https://i.loli.net/2020/08/07/NTOMQYRsu8LP1UZ.png" alt="幻灯片6.PNG"></p><p><img src="https://i.loli.net/2020/08/07/JvmkxESRXuHTtbU.png" alt="幻灯片7.PNG"></p><p><img src="https://i.loli.net/2020/08/07/TintEkDNwMAyhsl.png" alt="幻灯片8.PNG"></p><p><img src="https://i.loli.net/2020/08/07/HwygvJxIbQThfeo.png" alt="幻灯片9.PNG"></p><h3 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h3><p>利用的c++的 <strong>pair和prority_queue</strong> 实现 <strong>Dijkstra</strong> </p><p>c++模板</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct cmp {  bool operator()(const pair<int, int> &a, const pair<int, int> &b) {    return a.first > b.first;  }};class Dijkstra { private:  int n;  vector<vector<pair<int, int>>> v; public:  void Init(int n) {    this->n = n;    v.clear();    v.resize(n + 1);    for (int i = 1; i <= n; i++) {      v[i].clear();    }  }  void Add(int a, int b, int c) {    v[a].push_back(make_pair(b, c));    // 如果是双向的，加上下面这一句。    // v[b].push_back(make_pair(a, c));  }  void GetDist(int st, vector<int> &dist, vector<int> &path) {    for (int i = 1; i <= n; ++i) {      path[i] = -1;    }    for (int i = 1; i <= n; ++i) {      dist[i] = INT_MAX;    }    priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;    dist[st] = 0;    q.push(make_pair(0, st));    while (!q.empty()) {      int now = q.top().second;      if (dist[now] != q.top().first) {        q.pop();        continue;      }      q.pop();      for (int i = 0; i < (int)v[now].size(); i++) {        int next = v[now][i].first, value = v[now][i].second;        if (dist[now] + value < dist[next]) {          dist[next] = dist[now] + value;          q.push(make_pair(dist[next], next));          path[next] = now;        }      }    }  }};</code></pre><p>  参考了网上一位大神的写法。<a href="https://space.bilibili.com/434011092">bilibili主页地址</a></p><p>测试代码</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>#include <queue>#include <stack>#include <utility>#include <vector>using namespace std;class Solution { public:  pair<int, vector<int>> solve(int n, vector<vector<int>> &edges,                               vector<int> &succProb, int start, int end) {    Dijkstra d;    d.Init(n);    int size = edges.size();    for (int i = 0; i < size; ++i) {      int a = edges[i][0], b = edges[i][1];      int c = succProb[i];      d.Add(a, b, c);    }    vector<int> dist(n + 1);    vector<int> path(n + 1);    d.GetDist(start, dist, path);    return make_pair(dist[end], path);  }  void printWay(const vector<int> &path, int end) {    stack<int> s;    while (path[end] != -1) {      s.push(path[end]);      end = path[end];    }    while (!s.empty()) {      cout << s.top() << " ";      s.pop();    }    cout << endl;  }};int main() {  vector<vector<int>> edges;  edges.push_back({1, 2});  // 2  edges.push_back({1, 4});  // 1  edges.push_back({2, 5});  // 10  edges.push_back({2, 4});  // 3  edges.push_back({3, 1});  // 4  edges.push_back({3, 6});  // 5  edges.push_back({4, 3});  // 2  edges.push_back({4, 5});  // 2  edges.push_back({4, 6});  // 8  edges.push_back({4, 7});  // 4  edges.push_back({5, 7});  // 6  edges.push_back({7, 6});  // 1  vector<int> succProb;  succProb.emplace_back(2);  succProb.emplace_back(1);  succProb.emplace_back(10);  succProb.emplace_back(3);  succProb.emplace_back(4);  succProb.emplace_back(5);  succProb.emplace_back(2);  succProb.emplace_back(2);  succProb.emplace_back(8);  succProb.emplace_back(4);  succProb.emplace_back(6);  succProb.emplace_back(1);  Solution s;  auto ans1 = s.solve(7, edges, succProb, 1, 6);  cout << "1->6最短路径长度是: " << ans1.first << endl;  cout << "路径是: ";  s.printWay(ans1.second, 6);  ans1 = s.solve(7, edges, succProb, 1, 2);  cout << "1->2最短路径长度是: " << ans1.first << endl;  cout << "路径是: ";  s.printWay(ans1.second, 2);  ans1 = s.solve(7, edges, succProb, 1, 3);  cout << "1->3最短路径长度是: " << ans1.first << endl;  cout << "路径是: ";  s.printWay(ans1.second, 3);  ans1 = s.solve(7, edges, succProb, 1, 4);  cout << "1->4最短路径长度是: " << ans1.first << endl;  cout << "路径是: ";  s.printWay(ans1.second, 4);  ans1 = s.solve(7, edges, succProb, 1, 5);  cout << "1->5最短路径长度是: " << ans1.first << endl;  cout << "路径是: ";  s.printWay(ans1.second, 5);  ans1 = s.solve(7, edges, succProb, 1, 6);  cout << "1->6最短路径长度是: " << ans1.first << endl;  cout << "路径是: ";  s.printWay(ans1.second, 6);  ans1 = s.solve(7, edges, succProb, 1, 7);  cout << "1->7最短路径长度是: " << ans1.first << endl;  cout << "路径是: ";  s.printWay(ans1.second, 7);  return 0;}</code></pre><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">PAT 1003 Emergency</a></p><blockquote><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to <em>N</em>−1), <em>M</em> - the number of roads, <em>C</em>1 and <em>C</em>2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers <em>c</em>1, <em>c</em>2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <em>C</em>1 to <em>C</em>2.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line two numbers: the number of different shortest paths between <em>C</em>1 and <em>C</em>2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p></blockquote><p>这题就是一道 <strong>Dijkstra</strong> 的变种题目。</p><blockquote><p>题意：作为城市搜救队的队长，你有一张特殊的地图，这张地图展示了由几条道路连接起来的几个分散城市。地图上标注了每个城市的救援队和每队城市之间的距离。当你收到城市的紧急电话后，你的工作是带领你的人尽快的赶到目的地，在此基础上召集更多的救援队。</p><p>输入：第一行由4个数字，第一个数字表示有几个城市N，第二个数字表示有几条道路M，第三个城市是起点城市C1，第四个是终点城市C2，第二行有N个数字，第i个数字表示第i个城市所用的救援队数量。接下来M行表示c1城市到c2城市的距离L。</p><p>输出：输出最短距离的路径条数和在最短距离的前提下，救援队的最大数量。</p></blockquote><p>这里不是单向图，两个城市可以互通的。</p><p>设置两个向量，<strong>num</strong> 和 <strong>maxPeople</strong> 分别表示最短路径条数和救援队最大人数。<strong>vec</strong> 每个城市的救援队的数量。</p><p>只需要多判断 <code>dist[now] + value = dist[next]</code> 的情况就好了。</p><p>当 <code>dist[now] + value = dist[next]</code> 意味着，最短路径多了一条，我们就用 <code>num[next] += num[now]</code> ，如果 <code>maxPeople[now] + vec[next] &gt; maxPeople[next]</code> ，说明我这条最短路径的救援队人数多，就更新 <strong>maxPeople</strong> 的值。</p><p>在 <code>dist[now] + value &lt; dist[next]</code> 时，最短路径保持不变，也就是 <code>num[next] = num[now]</code> ，但是救援队人数我们还是要累加的 <code>maxPeople[next] = maxPeople[now] + vec[next]</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>#include <queue>#include <stack>#include <utility>#include <vector>using namespace std;struct cmp {  bool operator()(pair<int, int> &a, pair<int, int> &b) {    return a.first > b.first;  }};class Dijkstra { private:  int n;  vector<vector<pair<int, int>>> v; public:  void Init(int n) {    this->n = n;    v.clear();    v.resize(n);    for (int i = 0; i < n; ++i) {      v[i].clear();    }  }  void Add(int a, int b, int c) {    v[a].push_back(make_pair(b, c));    v[b].push_back(make_pair(a, c));  }  void GetDist(int st, vector<int> &dist, vector<int> &path,               const vector<int> &vec, vector<int> &maxPeople,               vector<int> &num) {    for (int i = 0; i < n; ++i) {      maxPeople[i] = 0;    }    for (int i = 0; i < n; ++i) {      num[i] = 0;    }    maxPeople[st] = vec[st];    num[st] = 1;    for (int i = 0; i < n; ++i) {      path[i] = -1;    }    for (int i = 0; i < n; ++i) {      dist[i] = 2147483647;    }    priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;    dist[st] = 0;    q.push(make_pair(0, st));    while (!q.empty()) {      int now = q.top().second;      if (dist[now] != q.top().first) {        q.pop();        continue;      }      q.pop();      for (int i = 0; i < (int)v[now].size(); i++) {        int next = v[now][i].first, value = v[now][i].second;        if (dist[now] + value < dist[next]) {          dist[next] = dist[now] + value;          q.push(make_pair(dist[next], next));          path[next] = now;          num[next] = num[now];          maxPeople[next] = maxPeople[now] + vec[next];        } else if (dist[now] + value == dist[next]) {          num[next] += num[now];          if (maxPeople[now] + vec[next] > maxPeople[next]) {            maxPeople[next] = maxPeople[now] + vec[next];          }        }      }    }  }};int main() {  int n, m, start, end;  cin >> n >> m >> start >> end;  vector<int> vec;  for (int i = 0; i < n; ++i) {    int temp;    cin >> temp;    vec.emplace_back(temp);  }  vector<vector<int>> edges;  vector<int> succProb;  for (int i = 0; i < m; ++i) {    int c1, c2, c3;    cin >> c1 >> c2 >> c3;    edges.push_back({c1, c2});    succProb.emplace_back(c3);  }  int size = edges.size();  Dijkstra d;  d.Init(n);  for (int i = 0; i < size; ++i) {    int a = edges[i][0], b = edges[i][1];    int c = succProb[i];    d.Add(a, b, c);  }  vector<int> dist(n);  vector<int> path(n);  vector<int> num(n);  vector<int> maxPeople(n);  d.GetDist(start, dist, path, vec, maxPeople, num);  cout << num[end] << " " << maxPeople[end] << endl;  return 0;}</code></pre><p><a href="http://www.xuji.pro/[pat考试]1003-emergency-25/">嫖了几个测试用例</a></p><blockquote><p>6 9 0 5</p><p>1 2 1 5 3 4</p><p>0 1 1</p><p>0 2 2</p><p>0 3 1</p><p>1 2 1</p><p>2 3 1</p><p>2 4 1</p><p>2 5 1</p><p>3 4 1</p><p>4 5 1</p><p>6 9 0 2</p><p>1 2 1 5 3 4</p><p>0 1 1</p><p>0 2 2</p><p>0 3 1</p><p>1 2 1</p><p>2 3 1</p><p>2 4 1</p><p>2 5 1</p><p>3 4 1</p><p>4 5 1</p><p>6 9 0 4</p><p>1 2 1 5 3 4</p><p>0 1 1</p><p>0 2 2</p><p>0 3 1</p><p>1 2 1</p><p>2 3 1</p><p>2 4 1</p><p>2 5 1</p><p>3 4 1</p><p>4 5 1</p></blockquote><p>结果分别是：</p><blockquote><p>4 13</p><p>3 7</p><p>1 9</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1004</title>
      <link href="2020/08/04/pat-jia-zu/2020/pat1004/"/>
      <url>2020/08/04/pat-jia-zu/2020/pat1004/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 0&lt;<em>N</em>&lt;100, the number of nodes in a tree, and <em>M</em> (&lt;<em>N</em>), the number of non-leaf nodes. Then <em>M</em> lines follow, each in the format:</p><blockquote><p>ID K ID[1] ID[2] … ID[K]</p></blockquote><p>where <code>ID</code> is a two-digit number representing a given non-leaf node, <code>K</code> is the number of its children, followed by a sequence of two-digit <code>ID</code>‘s of its children. For the sake of simplicity, let us fix the root ID to be <code>01</code>.</p><p>The input ends with <em>N</em> being 0. That case must NOT be processed.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you are supposed to count those family members who have no child <strong>for every seniority level</strong> starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.</p><p>The sample case represents a tree with only 2 nodes, where <code>01</code> is the root and <code>02</code> is its only child. Hence on the root <code>01</code> level, there is <code>0</code> leaf node; and on the next level, there is <code>1</code> leaf node. Then we should output <code>0 1</code> in a line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>2 1<br>01 1 02</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>0 1</p></blockquote></blockquote><p> 题意：一个家庭的层级结构经常被表现为一个家谱树。你的任务是统计这些家庭成员中谁没有孩子。</p><p>输入：每个测试案例由N开始，表示有N个节点，接下来是M，表示非叶子节点个数，然后后面有M行，每行有如下格式：</p><p>ID 表示非叶子节点，K表示这个非叶子节点下的子孙数目，接下来的ID[1]……都是表示当前ID的子孙节点。根节点为01。</p><p>输出：输出每一层的叶子结点的个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始想着构建一颗二叉树，直接bfs，发现好像不太好实现。仔细想下，好像也没这个必要。</p><p>创建一个二维数组，每个数组的第一维表示非叶子节点个数，第二维表示这个非叶子节点下的子孙节点。</p><p>如果没有第二维度，说明这个节点没有子孙节点，也就说明这个节点是叶子节点。</p><p>统计每一层的叶子节点个数，保存起来，输出即可。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>#include <queue>#include <vector>using namespace std;int main() {  vector<int> vec[100];  vector<int> ans(100, 0);  int n, m, node, k, c;  cin >> n >> m;  for (int i = 0; i < m; ++i) {    cin >> node >> k;    for (int j = 0; j < k; ++j) {      cin >> c;      vec[node].emplace_back(c);    }  }  int cnt = 0, depth = 0;  queue<int> que;  que.push(1);  while (!que.empty()) {    ++depth;    int size = que.size();    for (int i = 0; i < size; ++i) {      int val = que.front();      que.pop();      if (vec[val].size() == 0) {        ++cnt;      } else {        for (int j = 0; j < (int)vec[val].size(); ++j) {          que.push(vec[val][j]);        }      }    }    ans[depth - 1] = cnt;    cnt = 0;  }  for (int i = 0; i < depth - 1; ++i) {    cout << ans[i] << " ";  }  cout << ans[depth - 1] << endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1005</title>
      <link href="2020/08/04/pat-jia-zu/2020/pat1005/"/>
      <url>2020/08/04/pat-jia-zu/2020/pat1005/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>Given a non-negative integer <em>N</em>, your task is to compute the sum of all the digits of <em>N</em>, and output every digit of the sum in English.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies one line which contains an <em>N</em> (≤10^100).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>12345</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>one five</p></blockquote></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意：给你一个非负整数N，你的目标是求出N各个位数的和。和的每一位数字用英文输出。</p><p>注意这里的N可能超级大。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>#include <unordered_map>#include <vector>using namespace std;int main() {  string n;  cin >> n;  int sum = 0;  for (auto s : n) {    sum += (s - '0');  }  unordered_map<int, string> mp;  mp[0] = "zero";  mp[1] = "one";  mp[2] = "two";  mp[3] = "three";  mp[4] = "four";  mp[5] = "five";  mp[6] = "six";  mp[7] = "seven";  mp[8] = "eight";  mp[9] = "nine";  string str = to_string(sum);  cout << mp[str[0] - '0'];  int size = str.size();  for (int i = 1; i < size; ++i) {    cout << " " << mp[str[i] - '0'];  }  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1002</title>
      <link href="2020/08/01/pat-jia-zu/2020/pat1002/"/>
      <url>2020/08/01/pat-jia-zu/2020/pat1002/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>This time, you are supposed to find <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p><em>K</em> N1 aN1 N2 aN2 … NK aNK</p><p>where <em>K</em> is the number of nonzero terms in the polynomial, Ni and <em>a<strong>N</strong>i</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10，0≤<em>NK</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>2 1 2.4 0 3.2</p><p>2 2 1.5 1 0.5</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>3 2 1.5 1 2.9 0 3.2</p></blockquote></blockquote><p>题目意思：给定A、B两个多项式，要你计算A + B</p><p>输入：每个输入包括两行，每一行包含一个多项式的信息，<code>K N1 aN1 N2 aN2 ... NK aNK</code></p><p>K表示多项式中的非零项的个数，Ni表示指数，aNi表示系数。</p><p>输出：对于每个测试案列应该按照输入方式一样输出多项式A+B的值，注意在末尾没有额外的空格。请精确到小数点后一位。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个题目也不怎么难，需要注意的是系数在后面就好了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义个降序排序的map，输入第一个多项式时，自己插入到map里面，输入第二个多项式时，要是mp键的值不为0，就加上系数，要是为0，说明没有同类项，就插入到map里面。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <cmath>#include <iostream>#include <map>#include <string>#include <unordered_map>using namespace std;int main() {  // 默认的map是按照升序排序的，加上greater就是按照int键进行降序排序了。  map<int, float, greater<int>> mp;  int n, m, exp;  float coe;  cin >> n;  for (int i = 0; i < n; ++i) {    cin >> exp >> coe;    mp[exp] = coe;  }  cin >> m;  for (int i = 0; i < m; ++i) {    cin >> exp >> coe;    if (mp[exp] == 0) {      mp[exp] = coe;    } else {      mp[exp] = mp[exp] + coe;    }  }  int ans = 0;  map<int, float>::iterator it;  for (it = mp.begin(); it != mp.end(); ++it) {    if (it->second != 0) {      ++ans;    }  }  cout << ans;  for (it = mp.begin(); it != mp.end(); ++it) {    if (fabs(it->second - 0.0) < 0.000001) {      continue;    }    //     cout << " " << it->first << " " << it->second;    // 注意输出格式，一位小数，末尾不能有空格！！！    printf(" %d %.1f", it->first, it->second);  }  cout << endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下创建虚拟python环境</title>
      <link href="2020/07/31/python/2020/linux-xia-chuang-jian-xu-ni-python-huan-jing/"/>
      <url>2020/07/31/python/2020/linux-xia-chuang-jian-xu-ni-python-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要虚拟环境"><a href="#为什么需要虚拟环境" class="headerlink" title="为什么需要虚拟环境"></a>为什么需要虚拟环境</h2><p>简单来讲，就是因为不同的项目可能需要不同的python package。但是，往往安装了最新版本的package会覆盖掉原来的，导致原有的项目因为package不同而无法正常工作。最常用的一个办法就是使用 <strong>virtualenv</strong> 创建虚拟环境，虚拟环境允许我们重新安装package而不影响系统全局的python解释器的package。 我们可以创建多个虚拟环境，维护不同package版本的项目。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class=" language-lang-bash"><code class="language-lang-bash">sudo pip3 install virtualenv # 安装虚拟环境</code></pre><p> 安装了  <code>virtualenv</code> 之后就可以创建虚拟环境了，但是命令有点复杂，我们通过安装扩展包来简化操作。</p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo pip3 install virtualenvwrapper # 安装虚拟环境扩展包</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置虚拟环境存放位置。</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim ~/.zshrc # 我使用的是zshrc，使用的bash改成bashrc# 在最后面添加export WORKON_HOME = $HOME/.virtualenv    # 新增环境变量WORKON_HOMEsource /usr/local/bin/virtualenvwrapper.sh # 使virtualenvwrapper命令生效</code></pre><p> 退出 <code>~/.zshrc</code></p><pre class=" language-lang-bash"><code class="language-lang-bash">source ~/.zshrc # 使zshrc命令立即生效</code></pre><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre class=" language-lang-bash"><code class="language-lang-bash">mkvirtualenv 虚拟环境名字 # 创建的使用的是python2的版本mkvirtualenv -p python3 虚拟环境名字 # 创建的是python3版本</code></pre><p>创建的虚拟环境可以到我们设置的 <code>~/.virtualenv</code> 目录下找到。</p><h3 id="进入-退出虚拟环境工作"><a href="#进入-退出虚拟环境工作" class="headerlink" title="进入/退出虚拟环境工作"></a>进入/退出虚拟环境工作</h3><pre class=" language-lang-bash"><code class="language-lang-bash"># 进入虚拟环境workon 虚拟环境名# 退出当前虚拟环境deactivateworkon + 按两次tab键，显示当前所有的虚拟环境</code></pre><h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><pre class=" language-lang-bash"><code class="language-lang-bash">rmvirtualenv 虚拟环境名</code></pre><h2 id="如何查看package包"><a href="#如何查看package包" class="headerlink" title="如何查看package包"></a>如何查看package包</h2><p>我们可以使用命令 <code>pip list</code> 或者 <code>pip freeze</code> 来显示当前python里面安装了哪些包。</p><p>真实环境里面，package一般放在 <code>/usr/local/lib/</code> 路径下。</p><p>虚拟环境，package就在 <code>~/.virtualenv/虚拟环境名/lib</code>   路径下。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>创建虚拟环境，并不是说我们退出虚拟环境，我们在虚拟环境里面创建的文件之类的就消失了，依旧存在的，虚拟环境只是给我们提供了一个真实的python环境，或者说系统环境，不相同的只是环境的不同，其它的都是一样的。这个跟沙盒还是有区别的。</p><p><code>在虚拟环境里面不要使用sudo来安装package</code> 使用的 <code>sudo</code> 会导致 <code>package</code> 或者 <code>软件包</code> 安装在真实的python环境里面。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Liunx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1001</title>
      <link href="2020/07/31/pat-jia-zu/2020/pat1001/"/>
      <url>2020/07/31/pat-jia-zu/2020/pat1001/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>Calculate <em>a</em>+<em>b</em> and output the sum in standard format — that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where −106≤<em>a</em>,<em>b</em>≤106. The numbers are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><blockquote><p>-1000000 9</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><blockquote><p>-999,991</p></blockquote></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个题难倒是不难， 就是感觉题目没讲清楚，有点坑。</p><p>题意：输入两个数，计算和，从个位开始，每三位输出一个 <code>","</code> 。</p><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>#include <string>using namespace std;int main() {  int a, b;  cin >> a >> b;  int c = a + b;  if (c < 0) {    cout << "-";    c = -c;  }  string temp = to_string(c);  int size = temp.size();  int cnt = 0;  string str = "";  for (int i = size - 1; i >= 0; --i) {    if (cnt == 3) {      cnt = 0;      str = "," + str;    }    ++cnt;    str = temp[i] + str;  }  cout << str << endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="2020/07/30/c/2020/wei-yun-suan/"/>
      <url>2020/07/30/c/2020/wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲使用位运算的一些技巧。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="位运算符号"><a href="#位运算符号" class="headerlink" title="位运算符号"></a>位运算符号</h3><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">c/cpp</th><th style="text-align:center">python</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">按位与</td><td style="text-align:center">a &amp; b</td><td style="text-align:center">a &amp; b</td><td style="text-align:center">1 &amp; 1 = 1, 1 &amp; 0 = 0, 同1为1, 有0为0</td></tr><tr><td style="text-align:center">按位或</td><td style="text-align:center">a \</td><td style="text-align:center">b</td><td style="text-align:center">a \</td><td>b</td><td>1 \</td><td>1 = 1, 1 \</td><td>0 =  1, 有1为1, 同0为0</td></tr><tr><td style="text-align:center">按位异或</td><td style="text-align:center">a ^ b</td><td style="text-align:center">a ^ b</td><td style="text-align:center">1 ^ 1 = 0, 1 ^ 0  = 1, 相同位不同为1, 相同为0</td></tr><tr><td style="text-align:center">按位取反</td><td style="text-align:center">~a</td><td style="text-align:center">~b</td><td style="text-align:center">~1 = 0, ~0 = 1</td></tr><tr><td style="text-align:center">左移</td><td style="text-align:center">a &lt;&lt; b</td><td style="text-align:center">a &lt;&lt; b</td><td style="text-align:center">把a转化为二进制后向左移b位, 高位丢弃, 低位补零</td></tr><tr><td style="text-align:center">右移</td><td style="text-align:center">a &gt;&gt; b</td><td style="text-align:center">a &gt;&gt; b</td><td style="text-align:center">把a转化为二进制后向右移b位, 去掉后b位</td></tr></tbody></table></div><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在c/cpp中优先级(只有位运算的优先级) <a href="https://baike.baidu.com/item/运算符优先级">运算符优先级</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">~</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">&lt;&lt;、&gt;&gt;</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">&amp;</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">^</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">\</td><td></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">&amp;=、^=、\</td><td>=、&lt;&lt;=、&gt;&gt;=</td></tr></tbody></table></div><h3 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h3><h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">/*判断奇偶, n & 1 if (n & 1) {    odd(奇数);} else {    even(偶数);}清空最低位的1 ---> n & (n - 1)n & (n - 1)还可以判断一个数是不是2的幂bool isPowerOfTwo(int n) {    return n > 0 ? (n & (n - 1)) == 0 : false;}得到最低位的1 ---> n & -nn & ~n = 0*/</code></pre><p><a href="https://leetcode-cn.com/problems/power-of-two/">231. 2的幂</a></p><p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a> 汉明重量</p><h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">/*x ^ 0 = x;x ^ 1 = -x;x ^ (~x) = 1;x ^ x = 0;// 交换两个数a ^= b;b ^= a;a ^= b;一个字符异或上(1 << 5)即32, 可以实现大小写转换(即大写变小写,小写变大写)char ch = 'a'; // ch = 'A'a ^= (1 << 5)cout << "a = " << a << endl;>>> a = 'A' // 'a'*/</code></pre><p>解释下其中几个</p><p><code>x ^ ~0 = ~x</code></p><p>相当于x的每一位都异或了1，那原本是1的位都变成了0，原本是0的位都变成了1。</p><p><code>x ^ ~x = ~0</code></p><p>x与~x的每一位肯定不相同，所以异或出来就是1。</p><p><code>a ^= b; b ^= a; a ^= b;</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">/*a ^= b ---> a = a ^ b;b ^= a ---> b = b ^ (a ^ b) = b ^ b ^ a = 0 ^ a = a;a ^= b ---> a = (a ^ b) ^ a = a ^ a ^ b = 0 ^ b = b;*/</code></pre><p>根据异或的性质容易得知，<code>奇数个1异或为1， 偶数个1异或为0</code></p><p>推广 —-&gt; <code>奇数个相同的数异或为这个数，偶数个相同的数异或为0</code></p><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [2,2,1]</p><p>输出: 1</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [4,1,2,1,2]</p><p>输出: 4</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/single-number">https://leetcode-cn.com/problems/single-number</a></p></blockquote><p>我们知道出现了偶数次的数字，最后肯定会抵消掉，<code>2 ^ 2 = 0</code>， 而奇数次的肯定会保留。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int singleNumber(vector<int>& nums) {        int ans = 0;        for (auto &num : nums) {            ans ^= num;        }        return ans;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></p><p><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></p><h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">/*一个数左移一位×2，左移n位×2的n次方*/</code></pre><h4 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">/*一个数字右移一位÷2，右移n位÷2的n次方取中间值 int mid = (left + right) >> 1*/</code></pre><h4 id="混合起来的一些技巧"><a href="#混合起来的一些技巧" class="headerlink" title="混合起来的一些技巧"></a>混合起来的一些技巧</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">/*将x最右边的n位清0, x & (~0 << n)获取x的第n值, (x >> n) && 1获取x的第n位的幂值, x & (1 << (n - 1))仅将第n位置为1, x | (1 << n)仅将第n位置为0, x & (~(1 << n))将x最高位至第n位(含)清0, x & ((1 << n) - 1)将第n位至第0位(含)清0, x & (~((1 << (n + 1)) - 1))*/</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位运算用好了还是挺强的，<strong>面试还挺喜欢出的</strong> ，老规矩，熟能生巧。</p><p>更多奇技淫巧可以参考 <a href="https://blog.csdn.net/zmazon/article/details/8262185">优秀程序员不得不知道的20个位运算技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer14- I. 剪绳子</title>
      <link href="2020/07/30/leetcode/2020/jian-zhi-offer14-i.jian-sheng-zi/"/>
      <url>2020/07/30/leetcode/2020/jian-zhi-offer14-i.jian-sheng-zi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个重要的函数</title>
      <link href="2020/07/30/kao-yan/2020/ji-ge-chong-yao-de-han-shu/"/>
      <url>2020/07/30/kao-yan/2020/ji-ge-chong-yao-de-han-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="几个重要的函数"><a href="#几个重要的函数" class="headerlink" title="几个重要的函数"></a>几个重要的函数</h2><h3 id="Ⅰ-绝对值函数"><a href="#Ⅰ-绝对值函数" class="headerlink" title="Ⅰ. 绝对值函数"></a>Ⅰ. 绝对值函数</h3><script type="math/tex; mode=display">f(x)=\left|x\right| = \left\{ \begin{aligned} -x, x < 0 \\ x, x \geq 0 \end{aligned} \right. = \left\{ \begin{aligned} -x, x < 0 \\ 0, x = 0 \\ -x, x < 0 \end{aligned} \right.</script><p>连续不一定可导，可导一定连续。</p><h3 id="Ⅱ-最值函数"><a href="#Ⅱ-最值函数" class="headerlink" title="Ⅱ. 最值函数"></a>Ⅱ. 最值函数</h3><script type="math/tex; mode=display">U = \max \left\{f(x), g(x)\}\right.\\ V = \min\left\{f(x), g(x)\}\right.</script><p>展开得到：</p><script type="math/tex; mode=display">U = \frac{f(x) + g(x) + \left \vert f(x) - g(x) \right\vert}{2} \\ V = \frac{f(x) + g(x) - \left \vert f(x) - g(x) \right\vert}{2}</script><p>可以推出：</p><script type="math/tex; mode=display">U + V = f(x) + g(x) \\ U - V = f(x) - g(x) \\ U \cdot V = f(x) \cdot g(x)</script><h3 id="Ⅲ-符号函数"><a href="#Ⅲ-符号函数" class="headerlink" title="Ⅲ. 符号函数"></a>Ⅲ. 符号函数</h3><script type="math/tex; mode=display">f(x) = sgn \ x = \left \{ \begin{aligned} -1, x < 0 \\ 0, x = 0 \\ 1, x > 0 \end{aligned}\right.</script><h3 id="Ⅳ-取整函数"><a href="#Ⅳ-取整函数" class="headerlink" title="Ⅳ. 取整函数"></a>Ⅳ. 取整函数</h3><script type="math/tex; mode=display">f(x) = \left \lfloor x \right \rfloor</script><p>不超过x的最大整数。</p><p>可以推出：</p><script type="math/tex; mode=display">x - 1 < \left \lfloor x\right \rfloor \leq x \\ \left \lfloor x + n\right \rfloor = \left \lfloor x \right \rfloor + n, n是整数</script><h3 id="Ⅴ-分段函数"><a href="#Ⅴ-分段函数" class="headerlink" title="Ⅴ. 分段函数"></a>Ⅴ. 分段函数</h3><script type="math/tex; mode=display">f(x) = \left \{ \begin{aligned} f(x), x \leq x_0 \\ g(x), x > x_0 \end{aligned}\right.</script><p>或</p><script type="math/tex; mode=display">f(x) = \left \{ \begin{aligned} f(x), x < x_0 \\ a, x = x_0 \\ g(x), x > x_0\end{aligned} \right.</script><h3 id="Ⅵ-狄利克雷函数"><a href="#Ⅵ-狄利克雷函数" class="headerlink" title="Ⅵ. 狄利克雷函数"></a>Ⅵ. 狄利克雷函数</h3><script type="math/tex; mode=display">D(x) = \left \{ \begin{aligned} 1 , x \in \mathbb{Q} \\ 0 , x \in \mathbb{Q}^\complement \end{aligned} \right. ,\qquad \mathbb{Q}表示有理数, \mathbb{Q}^\complement表示有理数的补集</script><h3 id="Ⅶ-幂指函数"><a href="#Ⅶ-幂指函数" class="headerlink" title="Ⅶ. 幂指函数"></a>Ⅶ. 幂指函数</h3><script type="math/tex; mode=display">f(x) = u(x)^{v(x)}, u(x) > 0, 且u(x) \neq 1</script><p>可以推出：</p><script type="math/tex; mode=display">u(x)^{v(x)} = e^{v(x) \cdot \ln u(x)}</script><p> 用于幂指函数求导。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux线程</title>
      <link href="2020/06/23/linux/2020/linux-xian-cheng/"/>
      <url>2020/06/23/linux/2020/linux-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一-线程"><a href="#一-线程" class="headerlink" title="一. 线程"></a>一. 线程</h2><p>pthread不是linux下默认的库，有可能需要安装。</p><p><code>sudo apt-get install glibc-doc</code></p><p><code>sudo apt-get install manpages-posix-dev</code></p><p>通过<code>man pthread_creat</code>查看man pages中关于pthread的手册。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);// Compile and link with -pthread.</code></pre><ul><li>参数<ul><li>thread，传出参数，线程id；</li><li>attr，线程属性，一般不用；</li><li>void <em>(</em>start_routine) (void *)函数指针，要执行的函数；</li><li>arg执行函数的参数。</li></ul></li><li>返回值<ul><li>成功返回0；</li><li>失败返回errno number。</li></ul></li></ul><p>这里讲下<code>void *</code>是什么意思：无类型指针”，可以指向任何数据类型。</p><ol><li>任何类型的指针变量都可以赋值给void *；</li><li>void *赋值给其他变量需要强制类型转换。</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">int *p1 = nullptr；void *p2;p2 = p1;p1 = (int *)p2;</code></pre><h3 id="Ⅰ-创建线程："><a href="#Ⅰ-创建线程：" class="headerlink" title="Ⅰ. 创建线程："></a>Ⅰ. 创建线程：</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>#include <stdio.h>#include <unistd.h>void *print(void *argv) {  printf("I am a thread, pid = %d, tid = %lu\n", getpid(), pthread_self());  return argv;}int main() {  pthread_t tid;  pthread_create(&tid, NULL, print, NULL);  printf("I am a main thread, pid = %d, tid = %lu\n", getpid(), pthread_self());  sleep(1);  return 0;}</code></pre><p><img src="https://static01.imgkr.com/temp/d9e5be97419f46ca8933ab98bd23297e.png" alt=""></p><p>每次写makefile很麻烦，推荐个方法。</p><pre class=" language-lang-bash"><code class="language-lang-bash"># 如果是bash就是~/.bashrc, 我用的是zsh, ~/.zshrcvim ~/.zshrc# 在最后添加这一句话，前提是你在家目录下有bin文件，bin文件下有写好的makefile文件alias echomake="cat ~/bin/makefile >> makefile"# alias有起别名的作用，把"cat ~/bin/makefile >> makefile"这个命令起别名为echomakesource ~/.zshrc# 注：要是使用的是bash, 就把zshrc换成bash</code></pre><p>这样我们每次只需要在终端输入<code>echomake</code>就会在当前目录生成一个编写好的模板makefile，编写makefile可以参考我的 <a href="https://mp.weixin.qq.com/s/0JWVjT7bSBRXvR2j1pMajQ">makefile简单使用</a> ，希望对大家有帮助。</p><p>通过<code>pthread_exit()</code>退出线程。不能用<code>exit()</code>退出，这样会导致整个线程退出。</p><h3 id="Ⅱ-线程回收"><a href="#Ⅱ-线程回收" class="headerlink" title="Ⅱ. 线程回收"></a>Ⅱ. 线程回收</h3><p>阻塞等待回收。</p><p><code>man pthread_join</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_join(pthread_t thread, void **retval);Compile and link with -pthread.</code></pre><ul><li>参数<ul><li>thread，创建线程时传入的第一个参数；</li><li>retval，传出参数，线程返回的信息。</li></ul></li><li>返回值<ul><li>成功返回0；</li><li>失败返回errno number。</li></ul></li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <malloc.h>#include <pthread.h>#include <stdio.h>#include <unistd.h>#include <iostream>void *print(void *arg) {  printf("I am a thread, tid = %lu\n", pthread_self());  int *ret = new int(100);  return (void *)ret; // 这里返回的是100的地址，不是100！！！}int main() {  pthread_t tid;  pthread_create(&tid, NULL, print, NULL);  printf("I am main thread, tid = %lu\n", pthread_self());  void *ret = NULL;  pthread_join(tid, &ret); // 这里的&ret是地址的地址了。  // 这里&ret才是二级指针变量retval的地址  // std::cout << *(int *)ret << std::endl;  printf("ret = %d\n", *(int *)ret);  return 0;}</code></pre><p>我觉得代码应该是这样子写的，还有这种写法的。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <malloc.h>#include <pthread.h>#include <stdio.h>#include <unistd.h>void *print(void *arg) {  printf("I am a thread, tid = %lu\n", pthread_self());  return (void *)100;}int main() {  pthread_t tid;  pthread_create(&tid, NULL, print, NULL);  printf("I am main thread, tid = %lu\n", pthread_self());  void *ret;  pthread_join(tid, &ret);  printf("ret = %d\n", (int)ret);  return 0;}</code></pre><p>这种还是有点问题，g++编译报错，gcc编译只是警告。</p><p>首先，<code>pthread_join()</code>的第二个参数是一个<code>void **</code>类型的，我们传递<code>void *ret</code>  的地址进去，这时，<code>ret</code>就是返回的地址了，我们要取的是地址里面的值，因为要转换成整形输出，所以<code>void *</code>要强制转换为<code>int *</code>，然后取星号，得到线程传出的值，即<code>*(int *)ret</code>，所以第二种写法，还是欠妥当的。</p><p>但是，第一种写法，要是在栈上为<code>ret</code> 分配空间，会出现段错误。这个是因为，当<code>print()</code>函数结束时，就自动释放了栈地址空间，我们在<code>main()</code>函数还要访问，就会导致段错误了，因为我们访问了一段未知的地址空间。而堆空间是由程序员释放，程序员没释放就等程序运行结束系统自动释放。</p><p>第二种写法为什么用<code>gcc</code>编译也能通过，只是有警告信息，这里是强行将地址转化为了整数，竟然和线程返回的值是一样的，奇奇怪怪。</p><p>但是，这样子想想，第二种写法，不也是泄露的内存？函数都执行完了，不释放资源？</p><p>应该还有更好的、更优秀的写法，希望大家多多指点。</p><p><a href="https://www.cnblogs.com/panfeng412/archive/2011/11/06/segmentation-fault-in-linux.html">段错误产生的原因</a></p><h3 id="Ⅲ-杀死进程"><a href="#Ⅲ-杀死进程" class="headerlink" title="Ⅲ. 杀死进程"></a>Ⅲ. 杀死进程</h3><p><code>man pthread_cancel</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_cancel(pthread_t thread);Compile and link with -pthread</code></pre><ul><li>返回值<ul><li>成功返回0；</li><li>失败返回errno number。</li></ul></li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>#include <stdio.h>#include <unistd.h>void *print(void *arg) {  while (1) {    printf("I am a thread, tid = %lu\n", pthread_self());    sleep(1);  }  return NULL;}int main() {  pthread_t tid;  pthread_create(&tid, NULL, print, NULL);  sleep(5); // 防止主线程比子线程先结束  if (pthread_cancel(tid) == 0) {    printf("success!\n");  } else {    perror("fault...");  }  pthread_join(tid, NULL);  return 0;}</code></pre><p>线程如果是被<code>pthread_cancel</code>    取消的，返回值为-1，<code>#define PTHREAD_CANCELED((void *)-1)</code></p><p>但是，这里就有个问题，用之前第一种方法 <code>*(int *)ret</code>，就会发生段错误，因为我们访问的是未知的地址空间，我也很迷惑啊~😱</p><p>注意，线程中必须有取消点才能杀死线程。查看所有取消点<code>man 7 pthreads</code>，强行设置取消点使用<code>pthread_testcancel()</code>函数。</p><h3 id="Ⅳ-线程分离"><a href="#Ⅳ-线程分离" class="headerlink" title="Ⅳ. 线程分离"></a>Ⅳ. 线程分离</h3><p><code>man pthread_detach</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_detach(pthread_t thread);Compile and link with -pthread.</code></pre><p>实现线程分离不需要<code>pthread_join()</code>回收资源，如果用了，会出问题。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>#include <stdio.h>#include <string.h>#include <unistd.h>void *print(void *arg) {  printf("I am thread, tid = %lu\n", pthread_self());  sleep(4);  return NULL;}int main() {  pthread_t tid;  pthread_create(&tid, NULL, print, NULL);  printf("I am main thread, tid = %lu\n", pthread_self());  sleep(5);  pthread_detach(tid);  int ret = 0;  if ((ret = pthread_join(tid, NULL)) > 0) {    printf("join error: %d, %s\n", ret, strerror(ret));  }  return 0;}</code></pre><p><img src="https://static01.imgkr.com/temp/3d5332aa8031405e808d50e9a41bd6be.png" alt=""></p><h3 id="Ⅴ-线程属性"><a href="#Ⅴ-线程属性" class="headerlink" title="Ⅴ. 线程属性"></a>Ⅴ. 线程属性</h3><p><code>man pthread_attr_init</code>初始化线程属性</p><p><code>man pthreaed_attr_destroy</code>销毁线程属性</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_attr_init(pthread_attr_t *attr);int pthread_attr_destroy(pthread_attr_t *attr);Compile and link with -pthread.</code></pre><p><code>man pthread_attr_setdetachstate</code>设置属性分离</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></pre><ul><li>参数<ul><li>attr，初始化的属性</li><li>detachstate<ul><li>PTHREAD_CREATE_DETACHED 线程分离</li><li>PTHREAD_CREATE_JOINABLE 允许回收</li></ul></li></ul></li></ul><h2 id="二-线程同步"><a href="#二-线程同步" class="headerlink" title="二. 线程同步"></a>二. 线程同步</h2><h3 id="Ⅰ-mutex互斥锁"><a href="#Ⅰ-mutex互斥锁" class="headerlink" title="Ⅰ. mutex互斥锁"></a>Ⅰ. mutex互斥锁</h3><p><code>man pthread_mutex_init</code></p><p>初始化锁，销毁锁。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);int pthread_mutex_destroy(pthread_mutex_t *mutex);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</code></pre><ul><li>参数<ul><li>restrict，约束该内存区域对应的数据，只能通过后面的变量进行访问和修改，mutex互斥锁</li><li>attr，互斥锁的属性，一般传NULL</li></ul></li></ul><p><code>man pthread_mutex_lock</code></p><p>给共享资源加锁。</p><p>如果未加锁，则给该线程加锁。</p><p>如果已经加锁，阻塞等待。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></pre><ul><li>参数<ul><li>mutex，init初始化的锁。</li></ul></li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>#include <stdio.h>#include <stdlib.h>#include <unistd.h>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;int sum = 0;void *print1(void *arg) {  while (1) {    pthread_mutex_lock(&mutex);    printf("1");    sleep(rand() % 3);    printf("2\n");    pthread_mutex_unlock(&mutex);    sleep(rand() % 3);  }}void *print2(void *arg) {  while (1) {    pthread_mutex_lock(&mutex);    printf("3");    sleep(rand() % 3);    printf("4\n");    pthread_mutex_unlock(&mutex);    sleep(rand() % 3);  }}int main() {  pthread_t tid[2];  pthread_create(&tid[0], NULL, print1, NULL);  pthread_create(&tid[1], NULL, print2, NULL);  pthread_join(tid[0], NULL);  pthread_join(tid[1], NULL);  return 0;}</code></pre><h3 id="Ⅱ-读写锁"><a href="#Ⅱ-读写锁" class="headerlink" title="Ⅱ. 读写锁"></a>Ⅱ. 读写锁</h3><p><code>man pthread_rwlock_rdlock</code>读锁</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></pre><p><code>man pthread_rwlock_wrlock</code>写锁</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <pthread.h>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></pre><p>使用的是否声明全局变量<code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER</code>传<code>&amp;rwlock</code>进去即可。</p><h3 id="Ⅲ-信号量"><a href="#Ⅲ-信号量" class="headerlink" title="Ⅲ. 信号量"></a>Ⅲ. 信号量</h3><p><code>man sem_init</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <semaphore.h>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></pre><ul><li>参数<ul><li>sem定义的信号量，传出参数</li><li>pshared<ul><li>0表示线程信号量</li><li>非0表示进程信号量</li></ul></li><li>value，定义信号量的个数</li></ul></li></ul><p><code>man sem_destroy</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <semaphore.h>int sem_destroy(sem_t *sem);</code></pre><ul><li>参数<ul><li>sem， 初始化信号量时的第一个参数</li></ul></li></ul><p><code>man sem_wait</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <semaphore.h>int sem_wait(sem_t *sem);int sem_trywait(sem_t *sem);int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></pre><p>申请信号量，成功value—，当信号量为0时，阻塞等待</p><p><code>man sem_post</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <semaphore.h>int sem_post(sem_t *sem);</code></pre><p>释放信号量，value++。</p><h4 id="信号量实现生产者消费者模型"><a href="#信号量实现生产者消费者模型" class="headerlink" title="信号量实现生产者消费者模型"></a>信号量实现生产者消费者模型</h4><p><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/8877236">Linux C 实现生产者消费者问题</a></p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>多线程之间的资源共享还是比进程方便些。多线程内容还有很多，还要慢慢学习。</p><p>睡眠排序：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <unistd.h>#include <ctime>#include <iostream>#include <thread>#include <vector>using namespace std;vector<int> vec;vector<int> ans;int sum = 0;template <class T>void print(const T &array) {  for (int num : array) {    cout << num << " ";  }  cout << endl;}void create_numbers(int cnt) {  for (int i = 0; i < cnt; ++i) {    int tmp = rand() % 10 + 1;    sum += tmp;    vec.emplace_back(tmp);  }  cout << "before sort: ";  print(vec);}void *func(void *arg) {  sleep(*(int *)arg);  ans.emplace_back(*(int *)arg);  return NULL;}int main() {  srand((unsigned int)time(nullptr));  int cnt = 10;  create_numbers(cnt);  pthread_t tid[cnt];  int i;  for (i = 0; i < cnt; ++i) {    int *argc = new int(vec[i]);    pthread_create(&tid[i], NULL, func, (void *)argc);    pthread_detach(tid[i]);  }  sleep(sum);  cout << "sort after: ";  print(ans);  return 0;}</code></pre><p><img src="https://static01.imgkr.com/temp/239d627b70cb4f708bcee0c8b46ce4f0.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/b89f52bd0d4a4ce299a35f3ec4bd7f03.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程下</title>
      <link href="2020/06/23/linux/2020/linux-jin-cheng-xia/"/>
      <url>2020/06/23/linux/2020/linux-jin-cheng-xia/</url>
      
        <content type="html"><![CDATA[<h2 id="一-信号"><a href="#一-信号" class="headerlink" title="一. 信号"></a>一. 信号</h2><h3 id="Ⅰ-信号的基本概念"><a href="#Ⅰ-信号的基本概念" class="headerlink" title="Ⅰ. 信号的基本概念"></a>Ⅰ. 信号的基本概念</h3><p><a href="https://baike.baidu.com/item/信号/7927794">信号</a></p><p>信号产生</p><ul><li>按键产生，<code>Ctrl + c、Ctrl + z</code>；</li><li>调用函数，<code>kill、raise、abort</code>；</li><li>定时器，<code>alarm、setitimer</code>；</li><li>命令产生，<code>kill</code>；</li><li>硬件异常，段错误，浮点型错误，总线错误，SIGPIPE。</li></ul><p>linux查看信号种类<code>man 7 signal</code></p><h3 id="Ⅱ-kill函数"><a href="#Ⅱ-kill函数" class="headerlink" title="Ⅱ. kill函数"></a>Ⅱ. kill函数</h3><p><code>man 2 kill</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <sys/types.h>#include <signal.h>int kill(pid_t pid, int sig);</code></pre><ul><li>pid &gt; 0， 要发送进程ID；</li><li>pid = 0，代表当前调用进程组内所有进程；</li><li>pid = -1，代表有权限发送的所有进程；</li><li>pid &lt; 0，代表-pid对应的组内所有进程；</li><li>sig对应信号 。</li></ul><p>简单使用，用子进程结束父进程。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main() {  int i;  for (i = 0; i < 5; ++i) {    pid_t pid = fork();    if (pid == 0) {      break;    }  }  if (i == 2) {    printf("I am a child process\n");    sleep(5);    kill(getppid(), SIGKILL);    while (1) {      ;    }  } else if (i == 5) {    printf("I am a father process\n");    sleep(1);  }  return 0;}</code></pre><h3 id="Ⅲ-raise函数"><a href="#Ⅲ-raise函数" class="headerlink" title="Ⅲ. raise函数"></a>Ⅲ. raise函数</h3><p>给自己发信号。</p><p><code>man raise</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>int raise(int sig);</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main() {  sleep(1);  raise(SIGKILL);  return 0;}</code></pre><h3 id="Ⅳ-alarm函数"><a href="#Ⅳ-alarm函数" class="headerlink" title="Ⅳ. alarm函数"></a>Ⅳ. alarm函数</h3><p> 定时给自己发送SIGALRM。</p><p><code>man 2 alarm</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <unistd.h>unsigned int alarm(unsigned int seconds);</code></pre><ul><li>参数秒，表示几秒后给自己发送信号</li><li>返回值，闹钟剩余秒数</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main() {  alarm(6);  for (int i = 0; i < 6; ++i) {    printf("i = %d\n", i);    sleep(1);  }  return 0;}</code></pre><p>程序运行可以看到，的确在第六秒发送了信号。</p><p><img src="https://static01.imgkr.com/temp/c8b7d4caf04f4350aea49d16ad958021.png" alt=""></p><h3 id="Ⅴ-捕获信号函数"><a href="#Ⅴ-捕获信号函数" class="headerlink" title="Ⅴ. 捕获信号函数"></a>Ⅴ. 捕获信号函数</h3><p>当有信号的时候调用函数。</p><p><code>man 2 signal</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>typedef void (*sighandler_t)(int); // 函数指针，返回值void，参数类型intsighandler_t signal(int signum, sighandler_t handler);</code></pre><p><code>man 2 sigaction</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></pre><ul><li>参数<ul><li>signum，传入的信号</li><li>act，传入的动作</li><li>oldact，原动作</li></ul></li></ul><p>sigaction结构体</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct sigaction {               void     (*sa_handler)(int);               void     (*sa_sigaction)(int, siginfo_t *, void *);               sigset_t   sa_mask; // 临时屏蔽的信号集               int        sa_flags; // 0使用第一个函数指针， SA_SIGINFO使用第二个函数指针               void     (*sa_restorer)(void); // 无效           };</code></pre><h3 id="Ⅵ-setitimer函数"><a href="#Ⅵ-setitimer函数" class="headerlink" title="Ⅵ. setitimer函数"></a>Ⅵ. setitimer函数</h3><p>周期性的发送信号。</p><p><code>man 2 setitimer</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <sys/time.h>int setitimer(int which, const struct itimerval *new_value, truct itimerval *old_value)</code></pre><ul><li>参数<ul><li>which<ul><li>ITIMER_REAL，自然定时，信号SIGALRM ；</li><li>TIMER_VIRTUAL，进程执行时间，信号SIGVTALRM；</li><li>ITIMER_PROF，进程执行时间+CPU调度时间，信号SIGPROF。</li></ul></li><li>new_value<ul><li>传入参数，要设置的闹钟时间。</li></ul></li><li>old_value<ul><li>传出参数，得到原来的闹钟时间。</li></ul></li></ul></li></ul><p>struct itimerval结构体定义</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct itimerval {               struct timeval it_interval; /* Interval for periodic timer 周期性时间设置*/               struct timeval it_value;    /* Time until next expiration 下次闹钟产生*/           };</code></pre><p>struct timeval结构体定义</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct timeval {               time_t      tv_sec;         /* seconds */               suseconds_t tv_usec;        /* microseconds 微秒*/           };</code></pre><p>使用：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>#include <stdio.h>#include <sys/time.h>#include <unistd.h>void catch_signal(int num) { printf("catch a %d signal\n", num); }int main() {  signal(SIGALRM, catch_signal);  struct itimerval myit = {{3, 0}, {5, 0}};// it_interval.tv_sec = 3, it_interval.tv_usec = 0...  setitimer(ITIMER_REAL, &myit, NULL);  while (1) {    printf("...\n");    sleep(1);  }  return 0;}</code></pre><p><img src="https://static01.imgkr.com/temp/da7e159158f146e895f7bbcbf183ecaf.png" alt=""></p><p>  通过运行结果，我们可以看到，程序的确是按照我们的预期跑的，5秒后闹钟产生，之后每隔3秒发送一次信号。</p><h3 id="Ⅶ-信号集函数"><a href="#Ⅶ-信号集函数" class="headerlink" title="Ⅶ. 信号集函数"></a>Ⅶ. 信号集函数</h3><p><code>man 3 sigemptyset</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>int sigemptyset(sigset_t *set); //清空信号集函int sigfillset(sigset_t *set); // 填充信号集int sigaddset(sigset_t *set, int signum); //添加某个信号到信号集int sigdelset(sigset_t *set, int signum); //从集合中删除某个信号int sigismember(const sigset_t *set, int signum); //是否为集合里的成员</code></pre><p>sigismember()返回1表示signum在集合中，0表示不在，-1失败，设置error。</p><p>其余返回0表示成功，-1表示失败，设置error。</p><p>设置阻塞或解除阻塞信号集。</p><p><code>man 3 sigprocmask</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);</code></pre><ul><li>参数<ul><li>how<ul><li>SIG_BLOCK 设置阻塞；</li><li>SIG_UNBLOCK 解除阻塞；</li><li>SIG_SETMASK 设置set为新的阻塞信号集。</li></ul></li><li>set传入的信号集</li><li>oset传出参数，旧的信号集</li></ul></li><li>返回0表示成功，-1失败，设置error。</li></ul><p>获取未决信号集。</p><p><code>man 3 sigpending</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>int sigpending(sigset_t *set);</code></pre><p>利用SIGCHLD回收子进程</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <signal.h>#include <stdio.h>#include <sys/wait.h>#include <unistd.h>void catch_sig(int num) {  pid_t wpid = waitpid(-1, NULL, WNOHANG);  if (wpid > 0) {    printf("wait child %d ok\n", wpid);  }}int main() {  int i = 0;  pid_t pid;  // 在创建子进程之前屏蔽SIGCHLD信号  sigset_t myset, oldset;  sigemptyset(&myset);  sigaddset(&myset, SIGCHLD);  // oldset保护现场，阻塞信号SIGCHLD，得到阻塞前的信号SIGCHLD  sigprocmask(SIG_BLOCK, &myset, &oldset);  for (i = 0; i < 10; ++i) {    pid = fork();    if (pid == 0) {      break;    }  }  if (i == 10) {    struct sigaction act;    act.sa_flags = 0;    sigemptyset(&act.sa_mask);    act.sa_handler = catch_sig;    sigaction(SIGCHLD, &act, NULL);    sigprocmask(SIG_SETMASK, &oldset, NULL);    while (1) {      sleep(1);    }  } else if (i < 10) {    printf("I am %d child, pid = %d\n", i, getpid());    sleep(i);  }  return 0;}</code></pre><p><img src="https://static01.imgkr.com/temp/b7c7a62dd8c74443bfd06284f4a5c303.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/ac2af8418636437ab490cff7baaaa2b1.png" alt=""></p><p>通过<code>ps -ajx</code>可以看到，的确杀死了子进程。</p><h2 id="二-守护进程"><a href="#二-守护进程" class="headerlink" title="二. 守护进程"></a>二. 守护进程</h2><p>个人理解守护进程，<strong>不用占用终端，程序可以一直进行下去</strong> ，守护进程一般以d结尾，linux下有systemd系统工具来启动守护进程。</p><p>创建守护进程步骤：</p><ol><li>创建子进程，kill父进程；</li><li>子进程调用setsid当会话组长和进程组长，失去终端；</li><li>忽略SIGHUP信号；</li><li>切换工作目录；</li><li>用umask设置掩码；</li><li>关闭文件描述符0、1、2，避免资源浪费；</li><li>执行核心逻辑；</li><li>守护进程退出，通过<code>kill pid</code>。</li></ol><p>创建守护进程：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <signal.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/stat.h>#include <sys/time.h>#include <sys/types.h>#include <unistd.h>int i = 0;void print(int num) { printf("i = %d\n", i++); }int main() {  // 创建子进程，父进程退出  pid_t pid = fork();  if (pid > 0) {    exit(1);  }  // 当会长  setsid();  // 设置掩码  umask(0);  // 切换目录  chdir(getenv("HOME"));  // 关闭文件描述符  // close(1);  // close(2);  // close(3);  // 执行核心逻辑  struct itimerval myit = {{1, 0}, {1, 0}};  setitimer(ITIMER_REAL, &myit, NULL);  struct sigaction act;  act.sa_flags = 0;  sigemptyset(&act.sa_mask);  act.sa_handler = print;  sigaction(SIGALRM, &act, NULL);  while (1) {    sleep(1);  }  // 退出  return 0;}// 每隔一秒打印一个数字，为了方便，没有关闭文件描述符</code></pre><p><img src="https://static01.imgkr.com/temp/8fbe402a77164e009c426dbfc9da45db.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/7052c334ff7840f78b30112f42513829.png" alt=""></p><p>可以看到，守护进程创建成功。</p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>本来还打算用信号和线程写一个睡眠排序，发现好像有点困难，就放弃了。</p><p>linux下的进程就算粗略学习完了，绝知此事要躬行，还有很多要学习的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用selenium自动完成教学质量测评</title>
      <link href="2020/06/20/python/2020/li-yong-selenium-zi-dong-wan-cheng-jiao-xue-zhi-liang-ce-ping/"/>
      <url>2020/06/20/python/2020/li-yong-selenium-zi-dong-wan-cheng-jiao-xue-zhi-liang-ce-ping/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li>selenium<ul><li><code>sudo pip3 install seletinum</code></li></ul></li><li>chromedriver<ul><li><code>https://chromedriver.chromium.org/downloads</code></li><li>放到<code>/usr/local/bin</code>目录下，代码可以不指定位置</li></ul></li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>selenium</strong> 可以通过许多方法定位页面元素，这里简单列举下。</p><p><code>driver = webdrriver.Chrome()</code></p><ol><li>通过id定位</li></ol><p><code>driver.find_element_by_id()</code></p><ol><li>通过name定位</li></ol><p><code>driver.find_element_by_name()</code></p><ol><li>通过tag_name定位</li></ol><p><code>driver.find_element_by_tag_name()</code></p><ol><li>通过class_name定位</li></ol><p><code>driver.find_element_by_class_name()</code></p><ol><li>通过css定位</li></ol><p><code>driver.find_element_by_css_selector</code></p><ol><li>通过xpath定位</li></ol><p><code>driver.find_element_by_xpath</code></p><p>xpath简单语法</p><div class="table-container"><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">概述</th></tr></thead><tbody><tr><td style="text-align:center">//div</td><td style="text-align:center">选取所有的div元素</td></tr><tr><td style="text-align:center">//div[@class=”blog-content-box”]</td><td style="text-align:center">选取class为cblog-content-box的元素</td></tr><tr><td style="text-align:center">//div/link/@href</td><td style="text-align:center">选取所有div标签下的link标签的链接</td></tr><tr><td style="text-align:center">//div/h2/text()</td><td style="text-align:center">选取 所有div标签下的h2标签之间的内容</td></tr><tr><td style="text-align:center">//div[1]/p</td><td style="text-align:center">选取第一个div标签下的p标签的内容</td></tr><tr><td style="text-align:center">//div[1]/p[last()]</td><td style="text-align:center">选取第一个div标签下的p标签的最后一个内容</td></tr><tr><td style="text-align:center">//div[@class^=”blog”]</td><td style="text-align:center">选取所有以blog开头的div标签</td></tr><tr><td style="text-align:center">etree.HTML(html).xpath(‘count(//div/form)’)</td><td style="text-align:center">计算所有的div标签下的form标签数量</td></tr></tbody></table></div><ol><li>通过link定位</li></ol><p><code>driver.find_element_by_link_text()</code>取链接中的所有元素</p><p><code>driver.find_element_by_partial_link_text()</code>取链接中的部分元素</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="frame处理"><a href="#frame处理" class="headerlink" title="frame处理"></a>frame处理</h3><p>frame是一个十分大的坑了，如果不注意当前页面的frame，很有可能通过selenium定位不到元素。</p><p>frame切换<code>driver.switch_to_frame(driver.find_element_by_tag_name("iframe"))</code></p><h3 id="延时处理"><a href="#延时处理" class="headerlink" title="延时处理"></a>延时处理</h3><p>有可能我们的代码跑的太快了，但是当前html页面还没完全加载出来，导致定位不到元素。</p><ol><li>利用sleep延时，绝对延时</li></ol><p><code>time.sleep(秒数)</code></p><ol><li>隐性延时</li></ol><p>最长是30秒，如果30秒内，资源全部加载完成，那么执行后续的代码，30秒内没有加载完成，也会继续执行后续代码。</p><p>  <code>driver.implicitly_wait(秒数)</code></p><ol><li>显性等待</li></ol><p>等待时长20秒，间隔0.5秒去查询一次目标元素是否加载完成，20秒内加载完成后，执行后续的代码，最长等待20秒，没有加载也会继续执行。</p><p><code>WebDriverWait(driver,20,0.5).until(EC.presence_of_element_located(要草找的元素))</code></p><p>注意这里要查找的元素是元组。</p><h3 id="alter弹窗处理"><a href="#alter弹窗处理" class="headerlink" title="alter弹窗处理"></a>alter弹窗处理</h3><p>接受<code>driver.switch_to.alert.accept()</code></p><p>忽略<code>driver.switch_to.alert.dismiss()</code></p><p>发送文本<code>driver.switch_to.alert.send_keys(文本内容)</code></p><p>获取文本内容<code>driver.switch_to.alert.text</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-lang-python"><code class="language-lang-python">#! /usr/bin/python3.8import requestsimport sysfrom selenium import webdriverimport timefrom lxml import etreeclass Table:    def __init__(self, number_id, passwd):        self.url = "学校官网地址"        self.number_id = number_id        self.passwd = passwd    def simulate(self):        # 启动        driver = webdriver.Chrome()        # 最大化        driver.maximize_window()        # 地址请求        driver.get(self.url)        # 登录        driver.find_element_by_id("username").send_keys(self.number_id)        driver.find_element_by_id("password").send_keys(self.passwd)        driver.find_element_by_class_name("btn_dl").click()        time.sleep(1)        # 进入教务系统        driver.find_element_by_id("157889684646655577").click()        # 切换到最新的页面        windows = driver.window_handles        driver.switch_to.window(windows[-1])        time.sleep(1)        # 切换到测评页面        driver.find_element_by_xpath(            "/html/body/div[1]/div[1]/div[2]/ul/li[4]/a/span").click()        driver.find_element_by_xpath(            "/html/body/div[1]/div[1]/div[2]/ul/li[4]/ul/li[1]/a").click()        time.sleep(1)        # 有frame，需要转换        driver.switch_to_frame(driver.find_element_by_tag_name("iframe"))        time.sleep(1)        # 计算有多少门课要测评        html = etree.HTML(driver.page_source)        size = html.xpath(            'count(/html/body/form/div[3]/div/div[2]/div/div[1]/select/option)')        size = int(size)        # 利用js完成选项        commond = "document.getElementById('{}').options[{}].selected = true;"        for j in range(size):            # 找到每一门课程有多少个评价            time.sleep(1)            html = etree.HTML(driver.page_source)            id_lists = html.xpath("//td/select/@id")            for i in id_lists:                # 防止评价重复                if i == "DataGrid1_JS1_14" or i == "DataGrid1_JS2_14":                    end = commond.format(i, 2)                else:                    end = commond.format(i, 1)                driver.implicitly_wait(7)                # time.sleep(1)                driver.execute_script(end)            try:                time.sleep(2)                driver.find_element_by_name("Button1").click()            except Exception as e:                driver.refresh()                time.sleep(2)                driver.find_element_by_name("Button1").click()            else:                print("success")        time.sleep(1)        driver.switch_to.alert.accept()        time.sleep(1)        driver.find_element_by_name("Button2").click()        time.sleep(5)        driver.quit()        print("---end----")    def run(self):        print("---start----")        self.simulate()if __name__ == "__main__":    if len(sys.argv) == 3:        number_id = sys.argv[1]        passwd = sys.argv[2]    else:        print("./文件名 学籍号 密码")        sys.exit()    table = Table(number_id, passwd)    table.run()</code></pre><p>注：每个学校的官网不同，需要自己定位到元素操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是直接用js舒服，哈哈哈，js太强了。</p><p>js代码：copy 龙哥</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">setInterval(function(){    var select = document.getElementById("iframeautoheight").contentWindow.document.getElementsByTagName('select');    for (var j = 1; j < select.length; j++) {        if (j != select.length - 1) {            select[j].options[1].selected = true;        } else {            select[j].options[2].selected = true;        }    }    if(select.length>16){        select[10].options[2].selected = true;    }    setTimeout(function() {        var elements = document.getElementById("iframeautoheight").contentWindow.document.getElementsByTagName('input');        for (var i = 0; i < elements.length; i++) {            if(elements[i].value == "保  存"){                elements[i].click();            }        }    }, 1000)},5000);setTimeout(function(){    var element = document.getElementById("iframeautoheight").contentWindow.document.getElementsByTagName('input');    for (var i = 0; i < element.length; i++) {        if(element[i].value == " 提  交 "){            element[i].click();        }    }},62000)</code></pre><p>最后还搞了个html输入学籍号和密码，通过post发送给服务器，最后调用自动教学质量测评代码完成，没学过框架，代码写的很烂，就不贻笑大方了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer12. 矩阵中的路径</title>
      <link href="2020/06/02/leetcode/2020/jian-zhi-offer12.ju-zhen-zhong-de-lu-jing/"/>
      <url>2020/06/02/leetcode/2020/jian-zhi-offer12.ju-zhen-zhong-de-lu-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],</p><p>[“s”,”f”,”c”,”s”],</p><p>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>示例1：</p><blockquote><p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”</p><p>输出：true</p></blockquote><p>示例2：</p><blockquote><p>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”</p><p>输出：false</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= board.length &lt;= 200</p><p>1 &lt;= board[i].length &lt;= 200</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题第一感觉就是 <a href="https://baike.baidu.com/item/深度优先搜索/5224976?fromtitle=深度优先遍历&amp;fromid=9796166">深度优先遍历</a> </p><p>深度优先搜索就要递归的去找所有可能的情况。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iNDBkZjA4Yy0wMzhlLTQ3MjItODI2MS05ZGU0OThmZWFmM2QuZ2lm" alt=""></p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>结束条件<ul><li>当递归的层数等于word的长度时，递归结束。</li></ul></li><li>递工作<ul><li>上下左右四个方向搜索二维vector，判断是否和word中要匹配的字符相等，如果相等，把当前匹配成功的字符设置为*，表示已经访问过了。</li></ul></li><li>归工作<ul><li>还原当前矩阵。</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:  // 本身、上下左右五个方向，  int mvDistance[5][2] = {{0, 0}, {-1, 0}, {1, 0}, {0, 1}, {0, -1}};public:  bool exist(vector<vector<char>> &board, string word) {    int rows = board.size(), cols = board[0].size();    for (int i = 0; i < rows; ++i) {      for (int j = 0; j < cols; ++j) {        // 开始搜索        if (dfs(i, j, board, 0, word)) {          return true;        }      }    }    return false;  }  bool dfs(int x, int y, vector<vector<char>> &board, int cnt, string &word) {    // 搜索完毕返回    if (cnt == word.size()) {      return true;    }    for (int i = 0; i < 5; ++i) {      int mx = x + mvDistance[i][0], my = y + mvDistance[i][1];      // 判断当前位置有没有越界和是否被访问过      if (0 <= mx && mx < board.size() && 0 <= my && my < board[0].size() && board[mx][my] != '*') {        // 如果当前位置满足条件        if (word[cnt] == board[mx][my]) {          // 标记已经搜索          board[mx][my] = '*';          // 继续搜索          if (dfs(mx, my, board, cnt + 1, word)) {            return true;          }          // 递归返回          board[mx][my] = word[cnt];        }      }    }    return false;  }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def exist(self, board: List[List[str]], word: str) -> bool:        mvDistance = [[0, 0], [-1, 0], [1, 0], [0, 1], [0, -1]]        def dfs(x, y, board, cnt, word):            if cnt == len(word):                return True            for i in range(5):                mx, my = x + mvDistance[i][0], y + mvDistance[i][1]                if 0 <= mx and mx < len(board) and 0 <= my and my < len(board[0]) and board[mx][my] != '*':                    if word[cnt] == board[mx][my]:                        board[mx][my] = '*'                        if dfs(mx, my, board, cnt + 1, word):                            return True                        board[mx][my] = word[cnt]            return False        for i in range(len(board)):            for j in range(len(board[0])):                if dfs(i, j, board, 0, word):                    return True        return False</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer13. 机器人的运动范围</title>
      <link href="2020/06/02/leetcode/2020/jian-zhi-offer13.ji-qi-ren-de-yun-dong-fan-wei/"/>
      <url>2020/06/02/leetcode/2020/jian-zhi-offer13.ji-qi-ren-de-yun-dong-fan-wei/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><blockquote><p>输入：m = 2, n = 3, k = 1</p><p>输出：3</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：m = 3, n = 1, k = 0</p><p>输出：1</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题很容易误解， <strong>直接遍历整个二维数组，判断是否小于k，小于就说明满足条件</strong> ，这样子做就不对了。</p><p>因为有些格子他的行坐标和列坐标的数位之和小于k，但是，机器人也到不了这里。因为机器人只能上下左右移动，有些满足小于k的格子被挡住了。</p><p>看到 <strong>上、下、左、右</strong> 四个方向就要马上想到搜索，这题是一道比较典型的搜索题目。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/12caa81dac294f7194440e51cacb9ab3.gif" alt=""></p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    int movDistance[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};    int flag[101][101] = {0};    int ans = 0;    void dfs(int x, int y, int m, int n, int k) {        flag[x][y] = 1;        for (int i = 0; i < 4; ++i) {            int mx = x + movDistance[i][0], my = y + movDistance[i][1];            if (0 <= mx && mx < m && 0 <= my && my < n && !flag[mx][my] && sum(mx, my) <= k) {                ++ans;                dfs(mx, my, m, n, k);            }        }    }    int sum(int x, int y) {        return (x % 10 + x / 10) + (y % 10 + y / 10); // 因为题目说了0 <= n, m <= 100, 所以这里简化写法了。    }public:    int movingCount(int m, int n, int k) {        dfs(0, 0, m, n, k);        return ans + 1;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def __init__(self):        self.ans = 0        self.mvDistance = [[-1, 0], [1, 0], [0, -1], [0, 1]]        self.flag = [[0] * 101 for i in range(102)]    def movingCount(self, m: int, n: int, k: int) -> int:        def my_sum(x, y):            return (x // 10 + x % 10) + (y // 10 + y % 10)        def dfs(x, y, m, n, k):            self.flag[x][y] = 1            for i in range(4):                mx, my = x + self.mvDistance[i][0], y + self.mvDistance[i][1]                if 0 <= mx < m and 0 <= my < n and not self.flag[mx][my] and my_sum(mx, my) <= k:                    self.ans += 1                    dfs(mx, my, m, n, k)        dfs(0, 0, m, n, k)        return self.ans + 1</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>搜索之类的题目，基本上都是有模板可以套的，千万不要去人肉递归，这样之会越搞越糊涂，要是不理解，画个递归树还是可以的。真正掌握这种题，还是要多刷，刷多了就有感觉了。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer11. 旋转数组的最小数字</title>
      <link href="2020/06/01/leetcode/2020/jian-zhi-offer11.xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/"/>
      <url>2020/06/01/leetcode/2020/jian-zhi-offer11.xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p><strong>示例 1：</strong></p><blockquote><p>输入：[3,4,5,1,2]</p><p>输出：1</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：[2,2,2,0,1]</p><p>输出：0</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道二分查找的变种题，数组被分成了两个部分，每个部分都是有序的，要求查找数组的最小值，时间复杂度 $O(\log n)$</p><p>当然 $O(n)$ 肯定可以做，但是目前那么卷，面试估计悬~</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>这道题还是有意思的，题目并没有说数组中不包含重复元素，那就是可能存在重复元素，加上这个题目就不那么简单了。</p><p>我们定义 $left, right$ 指向 $numbers$ 的两端，$mid = left + (right - left) / 2$，现在我们用二分查找的主要的一个目标就是判断最小值在哪一个数组中。</p><p>任何一个旋转数组，肯定会被 $mid$ 分成两个部分(这两个部分，有一部分是有序的，另一部分是无序的，或者这两部分都是有序的)。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/offer11-1.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/offer11-2.png" alt=""></p><p>我们怎么判断这这个旋转数组哪个部分有序呢？通过比较 $numbers[mid]$ 与 $numbers[right]$ 的大小来判断。</p><ul><li>如果 $numbers[mid] &lt; numbers[right]$， 说明 $mid$ 右边有序；</li><li>如果 $numbers[mid] &gt; numbers[right]$， 说明 $mid$ 左边有序；</li><li>如果 $numbers[mid] == numbers[right]$，我们无法判断 $mid$ 哪边的数组有序。<ul><li>例如$[2, 2, 2, 0, 2]$， 此时$mid = 2, numbers[4] == numbers[2]$， 此时 $mid$ 的左边数组有序。</li><li>$[2, 0, 2, 2, 2]$， 此时$mid = 2, numbers[4] == numbers[2]$， 此时 $mid$ 的右边数组有序。</li><li>对于这两种情况，我们都无法判断最小元素在哪边。</li></ul></li></ul><p>还剩下几个问题：</p><ol><li>为什么需要判断 $mid$ 数组的左右两边的哪边是有序的呢？</li></ol><blockquote><p>如果 $numbers[mid] &lt; numbers[right]$ 说明右边有序，所以我们可以判断最小值肯定在 $[left, mid]$，因为 $mid$ 后面的元素肯定都比 $mid$ 大，但是，为什么不能说 $numbers[mid]$ 就是最小元素呢？如果我只搬0个元素到元素末尾，那样整个数组都是有序的，$mid$ 前面的元素肯定比 $mid$ 小。缩小范围 $right = mid$ </p><p>如果 $numbers[mid] &gt; numbers[right]$ 说明左边有序，但是因为题目给的旋转数组的定义( <strong>把一个数组最开始的若干个元素搬到数组的末尾</strong> )，我们可以肯定最小元素在数组右边 $[mid + 1, right]$， $numbers[mid] &gt; numbers[right]$ 说明 $mid$ 不可能是最小元素。缩小范围 $left = mid + 1$ </p></blockquote><ol><li>我们为什么要把 $numbers[high]$ 和 $numbers[mid]$ 比较，而不是 $numbers[left]$ 和 $numbers[mid]$ 比较；</li></ol><blockquote><p>如果我们用 $numbers[left]$ 和 $numbers[mid]$ 比较，会遇到多个情况。</p><p>比如：$mid = 2, i = 0$，此时通过 $numbers[mid] &gt; numbers[i]$， 产生的数组就有 $[4, 5, 6, 2, 3]$ 和 $[2, 3, 4, 5, 6]$，都满足条件，就说明这两个数组都产生在 $mid = 2, i = 0$ 时，对不同数组，我们采取同一个方法，最终得到的结果肯定有一个是错的。</p></blockquote><ol><li>当 $numbers[mid] == numbers[right]$ 后我们应该怎么处理。</li></ol><blockquote><p>当$numbers[mid] == numbers[right]$时，我们通过缩小判断范围来解决，即 $—right$</p></blockquote><p>参考 <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/">面试题11. 旋转数组的最小数字（二分法，清晰图解）</a></p><p><img src="https://gitee.com/incipe-win/images/raw/master/offer11-3.png" alt=""></p><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int minArray(vector<int>& numbers) {        int size = numbers.size();        int left = 0, right = size - 1;        while (left < right) {            int mid = left + (right - left) / 2;            if (numbers[mid] < numbers[right]) {                right = mid;            } else if (numbers[mid] > numbers[right]) {                left = mid + 1;            } else {                --right;            }        }        return numbers[left];    }};// 这样写也是可以的~// class Solution {// public://     int findMin(vector<int>& nums) {//         int size = nums.size();//         int left = 0, right = size - 1;//         int ans = INT_MAX;//         while (left <= right) {//             int mid = left + (right -left) / 2;//             if (nums[mid] < nums[right]) {//                 ans = min(ans, nums[mid]);//                 right = mid - 1;//             } else if (nums[mid] > nums[right]) {//                 left = mid + 1;//             } else {//                 --right;//             }//         }//         return min(ans, nums[left]);//     }// };</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def minArray(self, numbers: List[int]) -> int:        left, right = 0, len(numbers) - 1        while left < right:            mid = (left + right) // 2            if numbers[mid] < numbers[right]:                right = mid            elif numbers[mid] > numbers[right]:                left = mid + 1            else:                right -= 1        return numbers[left]</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个题还是比较难的，值得思考，初次遇到估计很难想到，细节太多了。</p><h3 id="相似的题"><a href="#相似的题" class="headerlink" title="相似的题"></a>相似的题</h3><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></p><p>如果理解了怎么压缩边界，缩小范围，这两道题肯定就是很简单的了。这两道题都是数组中不包含重复元素的！！！</p><ol><li>搜索旋转排序数组参考代码：</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int search(vector<int>& nums, int target) {        int size = nums.size();        int left = 0, right = size - 1;        while (left <= right) {            int mid = left + (right - left) / 2;            if (nums[mid] == target) {                return mid;            } else if (nums[mid] > nums[right]) {                // 说明左边有序，看看要查找的target在不在左边，因为是有序的，所以只要满足 nums[left] <= target < nums[mid]                // 就能确定target在左边了，否则，就不在左边，要去右边找。                if (nums[mid] > target && target >= nums[left]) {                    right = mid - 1;                } else {                    left = mid + 1;                }            } else {                // 说明右边有序，同左边有序，判断target在不在右边，在右边就在右边找，不在就在左边找。                if (nums[mid] < target && target <= nums[right]) {                    left = mid + 1;                } else {                    right = mid - 1;                }            }        }        return -1;    }};</code></pre><ol><li>寻找旋转排序数组中的最小值参考代码：</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findMin(vector<int>& nums) {        int size = nums.size();        int left = 0, right = size - 1;        while (left < right) {            int mid = left + (right - left) / 2;            if (nums[mid] < nums[right]) {                right = mid;            } else {                left = mid + 1;            }        }        return nums[left];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer10- II. 青蛙跳台阶问题</title>
      <link href="2020/05/31/leetcode/2020/jian-zhi-offer10-ii.qing-wa-tiao-tai-jie-wen-ti/"/>
      <url>2020/05/31/leetcode/2020/jian-zhi-offer10-ii.qing-wa-tiao-tai-jie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><blockquote><p>输入：n = 2</p><p>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 7</p><p>输出：21</p></blockquote><p>提示：</p><blockquote><p>0 &lt;= n &lt;= 100</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这类题一般具有递推关系。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8wMTEwZjc5Zi01NWRmLTQxYTQtYmExMy1jNTVhYzNhMWI4MjYucG5n?x-oss-process=image/format,png" alt=""></p><p>通过分析，我们容易得知，我们走上$n$阶台阶的种数就是我们走上$n-1$阶和$n-2$阶的种数和。</p><blockquote><p><em>假设我们要走上第四阶台阶，我们已知走上第一级台阶有1种走法，第二级有2种走法，第三级有3种走法。</em></p><p>我们要走上第四级台阶， <strong>因为一次只能走一级或两级</strong> ，所以，我们可以 <strong>从第二级台阶走 <code>两阶</code> 来到第四阶台阶</strong> ，<strong>也可以从第三级台阶走  <code>一阶</code> 来到第四级台阶。</strong> </p></blockquote><p>这样我们发现，就是一个 <strong>斐波那契数列</strong> ，只不过起始数字不同。</p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int numWays(int n) {        int a = 1, b = 1;        for (int i = 0; i < n; ++i) {           int sum = (a + b) % 1000000007;           a = b;           b = sum;        }        return a;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def numWays(self, n: int) -> int:        a, b = 1, 1        for _ in range(n):            a, b = b, a + b        return a % 1000000007</code></pre><p>更详细的 <a href="https://incipe-win.github.io/views/Leetcode/2020/剑指offer10- II. 青蛙跳台阶问题.html">斐波那契数列</a> 解析。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer10- I. 斐波那契数列</title>
      <link href="2020/05/30/leetcode/2020/jian-zhi-offer10-i.fei-bo-na-qi-shu-lie/"/>
      <url>2020/05/30/leetcode/2020/jian-zhi-offer10-i.fei-bo-na-qi-shu-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p><blockquote><p>F(0) = 0,   F(1) = 1</p><p>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p></blockquote><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：n = 2</p><p>输出：1</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：n = 5</p><p>输出：5</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Ⅰ-斐波那契数列"><a href="#Ⅰ-斐波那契数列" class="headerlink" title="Ⅰ. 斐波那契数列"></a>Ⅰ. 斐波那契数列</h3><ul><li><a href="https://baike.baidu.com/item/斐波那契数列">斐波那契数列</a>定义 $f(n + 1) = f(n) + f(n - 1)$</li></ul><h3 id="Ⅱ-题目分析"><a href="#Ⅱ-题目分析" class="headerlink" title="Ⅱ. 题目分析"></a>Ⅱ. 题目分析</h3><p>此题一般都当作动态规划(Dynamic programming)入门题。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>我们可以直接用递归来解此题， 应该会超时。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84MjU2ZmQwZi0yMzRiLTQwNjYtYmY1Mi1hNmRmODZkMDU0OWEucG5n?x-oss-process=image/format,png" alt=""></p><p>我们看到，每一次递归都产生了大量的重复计算值，而这些值理论上我们只要计算一次。</p><p>时间复杂度$O(2^n)$，空间复杂度$O(n)$</p><h4 id="记忆保存"><a href="#记忆保存" class="headerlink" title="记忆保存"></a>记忆保存</h4><p>我们用一个数组保存，计算过的每个值，遇到了直接用就好了。</p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:  long long vec[102];public:  Solution() { fill_n(vec, 102, -1); }  int fib(int n) {    if (n == 0) {      return 0;    }    if (n == 1 || n == 2) {      return 1;    }    if (vec[n] != -1) {      return vec[n];    }    vec[n] = (fib(n - 1) + fib(n - 2)) %  1000000007;    return vec[n];  }};</code></pre><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>我们以斐波那契数列性质$f(n + 1) = f(n) + f(n - 1)$为转移方程，写出代码即可。</p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int n) {        vector<int> vec(n + 2);        vec[0] = 0;         vec[1] = 1;        for (int i = 2; i <= n; ++i) {            vec[i] = vec[i - 1] + vec[i - 2];            vec[i] %= 1000000007;        }        return vec[n];    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def fib(self, n: int) -> int:        vec = [-1 for i in range(n + 2)]        vec[0] = 0        vec[1] = 1        for i in range(2, n + 1):            vec[i] = vec[i - 1] + vec[i - 2]            vec[i] %= 1000000007        return vec[n]</code></pre><p>记忆保存和DP时间复杂度和空间复杂度都是$O(n)$</p><h2 id="Ⅲ-优化"><a href="#Ⅲ-优化" class="headerlink" title="Ⅲ. 优化"></a>Ⅲ. 优化</h2><p>我们可不可以把空间复杂度优化成$O(1)$</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80M2Q2YTNiMy01OWMyLTQ2YWEtYTY1OC1mMzU4OWM1ODQ5YTQuZ2lm" alt=""></p><p>因为C++可能会导致溢出，所以我们要找个变量。</p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int n) {        int a = 0, b = 1;        for (int i = 0; i < n; ++i) {            int sum = (a + b) % 1000000007;            a = b;            b = sum;        }        return a;    }};</code></pre><ul><li>python代码</li></ul><p>python整型数字没有限制，取决于计算机内存，应该可以理解为无限大。</p><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def fib(self, n: int) -> int:        a, b = 0, 1        for _ in range(n):            a, b = b, a + b        return a % 1000000007</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer09. 用两个栈实现队列</title>
      <link href="2020/05/29/leetcode/2020/jian-zhi-offer09.yong-liang-ge-zhan-shi-xian-dui-lie/"/>
      <url>2020/05/29/leetcode/2020/jian-zhi-offer09.yong-liang-ge-zhan-shi-xian-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<br><br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br><br>[[],[3],[],[]]<br><br>输出：[null,null,3,-1]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<br><br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br><br>[[],[],[5],[2],[],[]]<br><br>输出：[null,-1,null,null,5,2]</p></blockquote><p><strong>提示：</strong></p><blockquote><p>1 &lt;= values &lt;= 10000<br><br>最多会对 appendTail、deleteHead 进行 10000 次调用</p></blockquote><p>来源：力扣（LeetCode）<br><br>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Ⅰ-知识回顾"><a href="#Ⅰ-知识回顾" class="headerlink" title="Ⅰ. 知识回顾"></a>Ⅰ. 知识回顾</h3><ol><li>栈，先进后出，我们不能直接操作栈底元素，只能</li><li>队列，先进先出。</li></ol><h3 id="Ⅱ-题目分析"><a href="#Ⅱ-题目分析" class="headerlink" title="Ⅱ. 题目分析"></a>Ⅱ. 题目分析</h3><p>我们设计两个栈，把其中一个栈的元素依次压出第二个栈，再把第二个栈的内容依次压入第一个栈，由于栈的“先进后出”性质，这时我们按照栈的方法操作第一个栈，就可以实现队列的“先进先出”功能了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8yMjZiYjM1My02MWY0LTQwNzAtODhkNi1hODVkOTFlMWE0ZTUuZ2lm" alt=""></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>在插入元素方法中<ol><li>如果，第一个栈不为空，把第一个栈的所有元素压入第二个栈</li><li>在第一个栈插入元素</li><li>如果第二个栈不为空，把第二个栈的所有元素压入第一个栈</li></ol></li><li>删除元素方法中<ol><li>因为第一个栈的元素已经是按照队列的“先进先出”存储好了，所以直接操作第一个栈即可。</li></ol></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class CQueue {private:        stack<int> s1;        stack<int> s2;public:    CQueue() {    }    void appendTail(int value) {        while (!s1.empty()) {            s2.push(s1.top());            s1.pop();        }        s1.push(value);        while (!s2.empty()) {            s1.push(s2.top());            s2.pop();        }    }    int deleteHead() {        if (s1.empty()) {            return -1;        }        int ret = s1.top();        s1.pop();        return ret;    }};/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj->appendTail(value); * int param_2 = obj->deleteHead(); */</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class CQueue:    def __init__(self):        self.s1, self.s2 = [], []    def appendTail(self, value: int) -> None:        while self.s1:            self.s2.append(self.s1.pop())        self.s1.append(value);        while self.s2:            self.s1.append(self.s2.pop())    def deleteHead(self) -> int:        if not self.s1:            return -1        return self.s1.pop()# Your CQueue object will be instantiated and called as such:# obj = CQueue()# obj.appendTail(value)# param_2 = obj.deleteHead()</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>插入元素</p><ul><li>时间复杂度$O(N)$，插入元素时，对于已有元素，每个元素都要弹出栈两次，压入栈两次。</li><li>空间复杂度$O(N)$， 需要使用额外空间。</li></ul><p>删除元素</p><ul><li>时间复杂度$O(1)$</li><li>空间复杂度$O(1)$</li></ul><h3 id="Ⅲ-优化"><a href="#Ⅲ-优化" class="headerlink" title="Ⅲ. 优化"></a>Ⅲ. 优化</h3><p>上面的代码尽管插入元素的时间复杂度已经是$O(N)$了，但是跑起来的效率相对比较慢。</p><p>通过分析我们知道，每次我们插入元素的时候，都要把栈1的所有元素都压入栈2，再把栈2的元素压入栈1，能不能优化下。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8wYWE0ZWIwNC03Y2EwLTQ4ZWQtOTIzMi1jNjE0N2NjODM4ZjUuZ2lm" alt=""></p><p>具体问题具体分析，结果不是最优，肯定还有好的方法。</p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class CQueue {private:    stack<int> s1, s2;public:    CQueue() {    }    void appendTail(int value) {        s1.push(value);    }    int deleteHead() {        if (s1.empty() && s2.empty()) {            return -1;        } else if (s2.empty() && !s1.empty()) {            while (!s1.empty()) {                s2.push(s1.top());                s1.pop();            }        }        int ret = s2.top();        s2.pop();        return ret;    }};/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj->appendTail(value); * int param_2 = obj->deleteHead(); */</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class CQueue:    def __init__(self):        self.s1, self.s2 = [], []    def appendTail(self, value: int) -> None:        self.s1.append(value)    def deleteHead(self) -> int:        if not self.s1 and not self.s2:            return -1        elif self.s1 and not self.s2:            while self.s1:                self.s2.append(self.s1.pop())        return self.s2.pop()# Your CQueue object will be instantiated and called as such:# obj = CQueue()# obj.appendTail(value)# param_2 = obj.deleteHead()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer07. 重建二叉树</title>
      <link href="2020/05/28/leetcode/2020/jian-zhi-offer07.chong-jian-er-cha-shu/"/>
      <url>2020/05/28/leetcode/2020/jian-zhi-offer07.chong-jian-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><blockquote><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p></blockquote><p>返回如下的二叉树：</p><blockquote><p>​    3</p><p>   / \<br>  9  20<br>    /  \<br>   15   7</p></blockquote><p><strong>限制：</strong></p><p>0 &lt;= 节点个数 &lt;= 5000</p><p>来源：力扣（LeetCode）<br><br>链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Ⅰ-先回顾下二叉树的遍历"><a href="#Ⅰ-先回顾下二叉树的遍历" class="headerlink" title="Ⅰ. 先回顾下二叉树的遍历"></a>Ⅰ. 先回顾下二叉树的遍历</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lMzdiNWJmMS0wNTYzLTQ2MzYtOWExYy04YTIxMTI1NTFkZGUucG5n?x-oss-process=image/format,png" alt=""></p><ul><li>前序遍历：根左右<ul><li>$3-&gt;9-&gt;20$</li><li>$9-&gt;1-&gt;4$</li><li>$20-&gt;15-&gt;7$</li><li>$3-&gt;9-&gt;1-&gt;4-&gt;20-&gt;15-&gt;7$</li></ul></li><li><p>中序遍历：左根右</p><ul><li>$9-&gt;3-&gt;20$</li><li>$1-&gt;9-&gt;4$</li><li>$15-&gt;20-&gt;7$</li><li>$1-&gt;9-&gt;4-&gt;3-&gt;15-&gt;20-&gt;7$</li></ul></li><li><p>后序遍历：左右根</p><ul><li>$9-&gt;20-&gt;3$</li><li>$1-&gt;4-&gt;9$</li><li>$15-&gt;7-&gt;20$</li><li>$1-&gt;4-&gt;9-&gt;15-&gt;7-&gt;20-&gt;3$</li></ul></li></ul><h3 id="Ⅱ-解题思路"><a href="#Ⅱ-解题思路" class="headerlink" title="Ⅱ. 解题思路"></a>Ⅱ. 解题思路</h3><p>根据二叉树的遍历特点可知，我们通过先序遍历找到当前层的根节点，通过中序遍历找到当前层根节点的左子树和右子树。</p><p>很明显，可以通过递归来实现。</p><h4 id="递归流程"><a href="#递归流程" class="headerlink" title="递归流程"></a>递归流程</h4><ul><li><p>终止条件</p><ul><li>当左子树左边界不小于左子树右边界或者右子树左边界不小于右子树右边界，递归结束。</li></ul></li><li><p>递归流程</p><ol><li>通过先序遍历找到当前层的根节点；</li><li>定位中序遍历根节点位置，得到当前层左子树和右子树(根节点左边的就是左子树，右边的就是右子树)；</li><li>通过当前层的根节点构造二叉树；</li><li>递归构建当前层的根节点的左子树和右子树。</li></ol></li><li>返回值<ul><li>返回当前层构建的二叉树</li></ul></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jOTk3MjU0Mi0zNzdmLTQ3MDEtODU4Ni0zM2EyNzc4MzdlOTMuZ2lm" alt=""></p><h3 id="Ⅲ-代码"><a href="#Ⅲ-代码" class="headerlink" title="Ⅲ. 代码"></a>Ⅲ. 代码</h3><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        return recursive(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);    }    TreeNode *recursive(vector<int> &preorder, int preorder_left, int preorder_right, vector<int> &inorder, int inorder_left, int inorder_right) {        // prerder_left先序遍历的左边界，preorder_right先序遍历的右边界，inorder_left中序遍历的左边界，inorder_right中序遍历的右边界        if (preorder_left > preorder_right || inorder_left > inorder_right) {            return nullptr;        }        // 先序遍历的第一个节点就是根节点        int root = preorder[preorder_left];        // 我们要找到中序遍历的根节点        int mid = 0;        for (int i = inorder_left; i <= inorder_right; ++i) {            if (inorder[i] == root) {                mid = i;                break;            }        }        // 构造二叉树        auto ans = new TreeNode(root);        // 左子树，preorder_left + 1先序遍历左子树的左边界， preorder_left + mid - inorder_left先序遍历的左子树的右边界， inorder_left中序遍历左子树左边界，mid-1中序遍历左子树右边界        ans->left = recursive(preorder, preorder_left + 1, preorder_left + mid - inorder_left, inorder, inorder_left, mid - 1);        // 右子树，preorder_left + mid - inorder_left + 1先序遍历右子树左边界， preorder_right先序遍历右子树右边界， mid+1中序遍历右子树左边界， inorder_right中序遍历右子树右边界        ans->right = recursive(preorder, preorder_left + mid - inorder_left + 1, preorder_right, inorder, mid + 1, inorder_right);        return ans;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:        def recursive(preorder, preorder_left, preorder_right, inorder, inorder_left, inorder_right):            if preorder_left > preorder_right or inorder_left > inorder_right:                return None            root = preorder[preorder_left]            for i in range(inorder_left, inorder_right + 1, 1):                if inorder[i] == root:                    mid = i                    break            ans = TreeNode(root)            ans.left = recursive(preorder, preorder_left + 1, preorder_left + mid - inorder_left, inorder, inorder_left, mid - 1)            ans.right = recursive(preorder, preorder_left + mid - inorder_left + 1, preorder_right, inorder, mid + 1, inorder_right)            return ans        return recursive(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer06. 从头到尾打印链表</title>
      <link href="2020/05/27/leetcode/2020/jian-zhi-offer06.cong-wei-dao-tou-da-yin-lian-biao/"/>
      <url>2020/05/27/leetcode/2020/jian-zhi-offer06.cong-wei-dao-tou-da-yin-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p></blockquote><p>限制：</p><blockquote><p>0 &lt;= 链表长度 &lt;= 10000</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Ⅰ-反转链表"><a href="#Ⅰ-反转链表" class="headerlink" title="Ⅰ. 反转链表"></a>Ⅰ. 反转链表</h3><p>得到反转后的链表，遍历链表即可。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84NTg0NTg1Yy1lMzdlLTRkOWQtYmRhOC1lYjIzOWI5ZDAxMmUuZ2lm" alt=""></p><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    vector<int> reversePrint(ListNode* head) {        vector<int> ans;        ListNode* res = nullptr, *tmp = head;        while (head != nullptr) {            tmp = head->next;            head->next = res;            res = head;            head = tmp;        }        while (res != nullptr) {            ans.emplace_back(res->val);            res = res->next;        }        return ans;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reversePrint(self, head: ListNode) -> List[int]:        ans = []        res = None        while head:            tmp = head.next            head.next = res            res = head            head = tmp        while res:            ans.append(res.val)            res = res.next        return ans</code></pre><h3 id="Ⅱ-栈"><a href="#Ⅱ-栈" class="headerlink" title="Ⅱ. 栈"></a>Ⅱ. 栈</h3><p>利用栈的先进后出性质，易解。</p><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    vector<int> reversePrint(ListNode* head) {        stack<int> s;        vector<int> ans;        while (head) {            s.push(head->val);            head = head->next;        }        while (!s.empty()) {            ans.emplace_back(s.top());            s.pop();        }        return ans;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reversePrint(self, head: ListNode) -> List[int]:        s = []        while head:            s.append(head.val)            head = head.next        return s[::-1]</code></pre><h3 id="Ⅲ-递归"><a href="#Ⅲ-递归" class="headerlink" title="Ⅲ. 递归"></a>Ⅲ. 递归</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8xNWVlZWU2NC01ODA2LTRlOTctOTYyMy01ZDEwNzU5Yjg0NzguZ2lm" alt=""></p><ul><li>C++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {private:    vector<int> ans;public:    vector<int> reversePrint(ListNode* head) {        if (head == nullptr) {            return {};        }        ans = reversePrint(head->next);        ans.push_back(head->val);        return ans;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reversePrint(self, head: ListNode) -> List[int]:        if head is None:            return []        s = self.reversePrint(head.next)        s.append(head.val)        return s</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer05. 替换空格</title>
      <link href="2020/05/22/leetcode/2020/jian-zhi-offer-ti-huan-kong-ge/"/>
      <url>2020/05/22/leetcode/2020/jian-zhi-offer-ti-huan-kong-ge/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><p><strong>限制：</strong></p><blockquote><p>0 &lt;= s 的长度 &lt;= 10000</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题感觉就十分简单了，但是，我竟然会想到按照空格拆分字符串再重新拼装，钻洞中💀</p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  string replaceSpace(string s) {    int size = s.size();    vector<string> vec;    string str;    int j = 0;    for (int i = 0; i < size; ++i) {      if (s[i] == ' ') {        vec.emplace_back(s.substr(j, i - j));        j = i + 1;      }    }    vec.emplace_back(s.substr(j, size));    for (decltype(vec.size()) i = 0; i < vec.size(); ++i) {      if (i != vec.size() - 1) {        str += vec[i] + "%20";      } else {        str += vec[i];      }    }    return str;  }};</code></pre><p>是不是被我这个想法吓到了😂</p><p>我们重新定义一个字符串，遇到空格，就添加 <code>%20</code>，不是空格就把原来的字符加进去就好了。</p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string replaceSpace(string s) {        string ans;        for (auto &i : s) {            if (i == ' ') {                // ans.push_back('%');                // ans.push_back('2');                // ans.push_back('0');                ans.append("%20");            } else {                // ans.push_back(i);                ans.append(1, i);            }        }        return ans;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def replaceSpace(self, s: str) -> str:        return s.replace(" ", "%20")</code></pre><p>python轮子还是多，但是涉及到底层感觉就没有c/c++那么顺手了~</p><p>时间复杂度$O(N)$， 空间复杂度$O(N)$</p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer04. 二维数组中的查找</title>
      <link href="2020/05/21/leetcode/2020/jian-zhi-offer-er-wei-shu-zu-zhong-de-cha-zhao/"/>
      <url>2020/05/21/leetcode/2020/jian-zhi-offer-er-wei-shu-zu-zhong-de-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下</p><blockquote><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p></blockquote><p>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>限制：</p><p>0 &lt;= n &lt;= 1000</p><p>0 &lt;= m &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Ⅰ-暴力解决"><a href="#Ⅰ-暴力解决" class="headerlink" title="Ⅰ. 暴力解决"></a>Ⅰ. 暴力解决</h3><p>直接遍历整个二维数组，找到target返回。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {        for (auto i = matrix.begin(); i != matrix.end(); ++i) {            for (auto j = i->begin(); j != i->end(); ++j) {                if (*j == target) {                    return true;                }            }        }        return false;    }};</code></pre><p>时间复杂度$O(n * m)$，空间复杂度$O(1)$</p><h3 id="Ⅱ-优化"><a href="#Ⅱ-优化" class="headerlink" title="Ⅱ. 优化"></a>Ⅱ. 优化</h3><p>通过题目我们知道，这是一个特殊的矩阵。</p><ul><li><strong>右上角元素：</strong> 所在列为最小元素，所在行为最大元素</li><li><strong>左下角元素：</strong> 所在列为最大元素，所在行为最小元素</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8zODI3YTUzNC1hY2E2LTQ0NTItYWU4Ni04YWZlMjU2NDQ4MjMuZ2lm" alt=""></p><ul><li>算法流程（从右上角开始）<ul><li>如果当前$matrix[i][j] &gt; target$，说明当前列都大于$target$，消除当前列；</li><li>如果当前$matrix[i][j] &lt; target$， 说明当前行都小于$target$，消除当前行；</li><li>如果当前$matrix[i][j] == target$， 说明二维数组中有$target$，返回；</li><li>如果遍历完整个数组，都没有满足$matrix[i][j] == target$， 说明当前二维数组不存在一个数等于$target$。</li></ul></li><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {        int rows = matrix.size();        if (rows == 0) {            return false;        }        int cols = matrix[0].size();        int n = 0, m = cols - 1;        while (n < rows && m >= 0) {            if(matrix[n][m] > target) {                --m;            } else if (matrix[n][m] < target) {                ++n;            } else {                return true;            }        }        return false;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -> bool:        if len(matrix) == 0:            return False        rows = len(matrix)        cols = len(matrix[0])        n, m = 0, cols - 1        while n < rows and m >= 0:            if matrix[n][m] < target:                n += 1            elif matrix[n][m] > target:                m -= 1            else:                return True        return False</code></pre><p>时间复杂度$O(n + m)$ ,  n,  m为二维数组的行数和列数​， 空间复杂度$O(1)$</p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer03. 数组中重复的数</title>
      <link href="2020/05/20/leetcode/2020/jian-zhi-offer-shu-zu-zhong-chong-fu-de-shu/"/>
      <url>2020/05/20/leetcode/2020/jian-zhi-offer-shu-zu-zhong-chong-fu-de-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><blockquote><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]</p><p>输出：2 或 3 </p></blockquote><p>限制：</p><blockquote><p>2 &lt;= n &lt;= 100000</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题乍一看，好像不难😂</p><h3 id="Ⅰ-排序"><a href="#Ⅰ-排序" class="headerlink" title="Ⅰ. 排序"></a>Ⅰ. 排序</h3><p>有点耍流氓的感觉~</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {      sort(nums.begin(), nums.end());      int size = nums.size();      for (int i = 0; i < size; ++i) {        if (nums[i] == nums[i + 1]) {          return nums[i];        }      }      return -1;    }};</code></pre><p>时间复杂度 $O(nlogn)$， 空间复杂度$O(1)$</p><h3 id="Ⅱ-哈希"><a href="#Ⅱ-哈希" class="headerlink" title="Ⅱ. 哈希"></a>Ⅱ. 哈希</h3><p>哈希是不存重复值的，所以，每当我们遇到重复值后，把hash的value加一即可。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {        unordered_map<int, int> mp;        int size = nums.size();        for (int i = 0; i < size; ++i) {            ++mp[nums[i]];        }        for (unordered_map<int, int>::iterator it = mp.begin(); it != mp.end(); ++it) {            if (it->second != 1) {                return it->first;            }        }        return -1;    }};</code></pre><p>还要单独遍历一遍hash，不太好，优化下。</p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {        unordered_map<int, int> mp;        int size = nums.size();        for (int i = 0; i < size; ++i) {            ++mp[nums[i]];            if (mp[nums[i]] > 1) {                return nums[i];            }        }        return 0;    }};</code></pre><p>这题hash貌似不太强，可能是因为索引冲突太严重了，直接用个vector快多了。</p><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def findRepeatNumber(self, nums: List[int]) -> int:        size = len(nums)        res = [0 for i in range(size)]        for i in range(size):            res[nums[i]] += 1            if res[nums[i]] > 1:                return nums[i]        return -1</code></pre><p>时间复杂度$O(n)$，空间复杂度$O(n)$</p><p>接下来是本题的重头戏了！</p><h3 id="Ⅲ-抽屉原理-鸽巢原理"><a href="#Ⅲ-抽屉原理-鸽巢原理" class="headerlink" title="Ⅲ. 抽屉原理(鸽巢原理)"></a>Ⅲ. 抽屉原理(鸽巢原理)</h3><p><a href="https://baike.baidu.com/item/抽屉原理/233776?fromtitle=鸽巢原理&amp;fromid=731656">抽屉原理</a></p><ul><li>c++代码</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {        int size = nums.size();        for (int i = 0; i < size; ++i) {            while (i != nums[i]) {                if (nums[i] == nums[nums[i]]) {                    return nums[i];                }                int tmp = nums[i];                nums[i] = nums[tmp];                nums[tmp] = tmp;            }        }        return -1;    }};</code></pre><ul><li>python代码</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def findRepeatNumber(self, nums: List[int]) -> int:        size = len(nums)        for i in range(size):            while i != nums[i]:                if nums[i] == nums[nums[i]]:                    return nums[i]                tmp = nums[i]                nums[i] = nums[tmp]                nums[tmp] = tmp        return -1</code></pre><p>时间复杂度$O(n)$， 空间复杂度$O(1)$</p><p>由于笔者本身水平有限，鸽巢原理解释起来还是有点牵强，故暂时没有给详细的解析原理。</p><p>看到此代码就懂什么意思，但是自己写出来还是做不到。见谅🙏</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三人行，必有我师焉，一起看看其他大牛的代码，学会阅读源码，也是一项必备的技能。</p><p><a href="https://krahets.gitee.io/views/sword-for-offer/2020-02-20-sword-for-offer-03.html#解题思路：">数组中重复的数字</a></p><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def findRepeatNumber(self, nums: [int]) -> int:        i = 0        while i < len(nums):            if nums[i] == i:                i += 1                continue            if nums[nums[i]] == nums[i]: return nums[i]            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]        return -1</code></pre><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/o1kong-jian-fei-jiao-huan-shu-zu-zuo-ha-xi-by-ray-/">O(1)空间 非交换，数组做哈希</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {        int len=nums.size();        for(int i=0;i<len;i++){            if(nums[abs(nums[i])]<0)                return abs(nums[i]);            nums[abs(nums[i])]*=-1;        }        return find(nums.begin(),nums.end(),0)-nums.begin();    }};</code></pre><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/tong-de-si-xiang-by-liweiwei1419/">把数组视为哈希表，找到重复的数就是发生了哈希冲突</a></p><pre class=" language-lang-java"><code class="language-lang-java">import java.util.Arrays;public class Solution {    public int findRepeatNumber(int[] nums) {        int len = nums.length;        for (int i = 0; i < len; i++) {            // 如果当前的数 nums[i] 没有在下标为 i 的位置上，就把它交换到下标 i 上            // 交换过来的数还得做相同的操作，因此这里使用 while            // 可以在此处将数组输出打印，观察程序运行流程            // System.out.println(Arrays.toString(nums));            while (nums[i] != i) {                if (nums[i] == nums[nums[i]]) {                    // 如果下标为 nums[i] 的数值 nums[nums[i]] 它们二者相等                    // 正好找到了重复的元素，将它返回                    return nums[i];                }                swap(nums, i, nums[i]);            }        }        throw new IllegalArgumentException("数组中不存在重复数字！");    }    private void swap(int[] nums, int index1, int index2) {        int temp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = temp;    }}</code></pre><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>天净沙·夏</center><center>白朴</center><center>云收雨过波添，楼高水冷瓜甜，绿树阴垂画檐。</center><center>沙厨藤簟(diàn)，玉人罗扇轻缣(jiān)。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102. 二叉树的层次遍历</title>
      <link href="2020/05/16/leetcode/2020/102-er-cha-shu-de-ceng-ci-bian-li/"/>
      <url>2020/05/16/leetcode/2020/102-er-cha-shu-de-ceng-ci-bian-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>世界以痛吻我，我却报之以歌</p><p align="right">--泰戈尔</p></blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">原题链接</a></p><p>二叉树构造：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> /** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</code></pre><p>要求层次遍历二叉树，用一个二维数组存放每一层的数值！</p><p>层次遍历，一层一层的，所以很容易想到bfs，广度搜索遍历。</p><p>既然是bfs，肯定就想到递归。递归就是把复杂问题简单化！</p><p>我一直觉得打代码就是把自己想的换一种语言描述，可是做到这点很难！</p><p>话不多说，直接上代码，代码有注释，还有自己添加的辅助理解的语句。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector<vector<int>> levelOrder(TreeNode* root) {        //我一直觉得代码就是做人之所想，可是要做到这一点很难！        vector<vector<int>> res;        if(root == nullptr)            return res;        bfs(root, res);        return res;    }    void bfs(TreeNode* root, vector<vector<int>>& res) {        //既然是层次遍历，就是一层一层的！        queue<TreeNode*> que;        que.push(root);//压入整个二叉树！        while(!que.empty()) {            vector<int> ans;            int len = que.size();//根节点下有多少个子树            //std::cout << "长度:" << len << std::endl;            for(int i = 0; i < len; i++) {                TreeNode* node = que.front();                //std::cout << "树结构:";                //Print(node);                //std::cout << std::endl;                que.pop();                ans.push_back(node->val);                if(node->left) {                    //std::cout << "///////" << std::endl;                    que.push(node->left);                }                if(node->right) {                    //std::cout << "///////" << std::endl;                    que.push(node->right);                }            }            res.push_back(ans);        }    }    // void Print(TreeNode* T) {    //     if(T) {    //         Print(T->left);    //         std::cout << T->val <<" ";    //         Print(T->right);    //     }    //     else {    //         std::cout << "";    //     }    // }};</code></pre><p>代码本身没什么不好理解的，可是一到自己做就不会，还是缺乏练习导致！</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">同类题</a></p><p><strong>才疏学浅，望雅正*</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 广度优先搜索遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="2020/05/16/leetcode/2020/11-sheng-zui-duo-shui-de-rong-qi/"/>
      <url>2020/05/16/leetcode/2020/11-sheng-zui-duo-shui-de-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8yY2Q1NTk5OC0yNjcwLTRmNTItOWYzNS02ZjlkNmQ3NzFiMTkucG5n?x-oss-process=image/format,png" alt=""></p><center>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</center><p><strong>示例：</strong></p><blockquote><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>这题貌似挺简单的🙋‍🙋‍🙋‍</p><p>把所有容纳的水都求出来，取个最大值不就好了吗？</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int maxArea(vector<int> &height) {    int size = height.size();    int maxCapaticy = 0;    for (int i = 0; i < size; ++i) {      for (int j = i + 1; j < size; ++j) {        int length = j - i;        int high = min(height[i], height[j]);        int tmp = length * high;        if (tmp > maxCapaticy) {          maxCapaticy = tmp;        }      }    }    return maxCapaticy;  }};</code></pre><p>结果你知道的🤷，不过我记得之前是可以勉强过的（小声bb，哈哈）</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>这题很明显的双指针，在用了暴力法超时后，优化立马就想到了双指针👇</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int maxArea(vector<int> &height) {    int size = height.size();    // 双指针low， high    int low = 0;    int high = size - 1;    // 最大容水量    int maxCapacity = 0;    while (low < high) {      int length = high - low;      int tmp;      if (height[low] > height[high]) {        tmp = height[high] * length;        --high;      } else {        tmp = height[low] * length;        ++low;      }      maxCapacity = max(tmp, maxCapacity);    }    return maxCapacity;  }};</code></pre><p>自己做了个图解，第一次做，不喜勿喷🙅‍♀️，真是解题十分钟，画题几小时啊🆒</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hNDhlN2FmYS04MzZiLTQ0OGItYjRiMC1lNWQ5NDljMGI5M2EucG5n?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iYjJjMmUxNi03MDdlLTQxYWQtOGI0Ni00YzExYjkyZGFiMTIucG5n?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8zOTM5ZTZhOS1iZTAyLTRmOGItYTA0OC1lYTMxY2FjN2UxNTUucG5n?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lMTI4NDgzNi03NDMwLTQ5ODUtODUwZi03OWI0ZmUxMDE3MTcucG5n?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mZjAxY2JmYy0zYjc1LTQzYzktYjNkYi1kYjcxNzcxMDQzNzAucG5n?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hYzUyNWRjZC1kYmZkLTQ4N2QtOTJhYi03NmRmZjNiMjQ1YzQucG5n?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83ZGQzZmRjOS1mYWY1LTRmNTktOTg2Zi1jYjg2MDgyYjkzM2EucG5n?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85NmU5MDNlZC03NmUxLTQ5MjQtOGU5YS02OGEzNTBiY2U1NTEucG5n?x-oss-process=image/format,png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次尝试了用 <strong>ppt</strong> 做动画，但是技术好像还没到家，就只能用图片展示了~👏👏👏</p><p>有空还是要多尝试新事物。</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>蝶恋花</center><center>柳永</center><center>伫倚危楼风细细，望极春愁，黯黯生天际。</center><center>草色烟光残照里，无言谁会凭阑意。</center><center>拟把疏狂图一醉，对酒当歌，强乐还无味。</center><center>衣带渐宽终不悔，为伊消得人憔悴。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 三数之和</title>
      <link href="2020/05/16/leetcode/2020/15-san-shu-zhi-he/"/>
      <url>2020/05/16/leetcode/2020/15-san-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p> 示例：</p><blockquote><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/3sum">https://leetcode-cn.com/problems/3sum</a></p></blockquote><h2 id="原始想法"><a href="#原始想法" class="headerlink" title="原始想法"></a>原始想法</h2><p>三重循环，暴力解决，必然超时</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> ans;        int size = nums.size();        for (int i = 0; i < size - 2; ++i) {            for (int j = i + 1; j < size - 1; ++j) {                for (int k = j + 1; k < size; ++k) {                    if (nums[i] + nums[j] + nums[k] == 0) {                        ans.push_back({nums[i], nums[j], nums[k]});                    }                }            }        }        for (decltype(ans.size()) i = 0; i < ans.size(); ++i) {            sort(ans[i].begin(), ans[i].end());        }        sort(ans.begin(), ans.end());        ans.erase(unique(ans.begin(), ans.end()), ans.end());        return ans;    }};</code></pre><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>排序 + 双指针</p><p>还是超时！！！</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> ans;        int size = nums.size();        if (size <= 2) {            return ans;        }        sort(nums.begin(), nums.end());        for (int i = 0; i < size; ++i) {            if (nums[i] > 0) {                break;            }            int low = i + 1;            int high = size - 1;            while (low < high) {                int sum = nums[i] + nums[low] + nums[high];                if (sum == 0) {                    ans.push_back({nums[i], nums[low], nums[high]});                    ++low;                    --high;                } else if (sum > 0) {                    --high;                } else {                    ++low;                }            }        }        for (decltype(ans.size()) i = 0; i < ans.size(); ++i) {            sort(ans[i].begin(), ans[i].end());        }        sort(ans.begin(), ans.end());        ans.erase(unique(ans.begin(), ans.end()), ans.end());        return ans;    }};</code></pre><p>导致超时的原因应该是后面的去重！</p><p>试试在查找时去重。</p><h2 id="再次优化"><a href="#再次优化" class="headerlink" title="再次优化"></a>再次优化</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> ans;        int size = nums.size();        if (size <= 2) {            return ans;        }        sort(nums.begin(), nums.end());        for (int i = 0; i < size; ++i) {            if (nums[i] > 0) {                break;            }            if (i > 0 && nums[i] == nums[i - 1]) {                continue;            }            int low = i + 1;            int high = size - 1;            while (low < high) {                int sum = nums[i] + nums[low] + nums[high];                if (sum == 0) {                    ans.push_back({nums[i], nums[low], nums[high]});                    ++low;                    --high;                    while (low < high && nums[low] == nums[low - 1]) {                        ++low;                    }                    while (low < high && nums[high] == nums[high + 1]) {                        --high;                    }                } else if (sum > 0) {                    --high;                } else {                    ++low;                }            }        }        return ans;    }};</code></pre><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>199. 二叉树的右视图</title>
      <link href="2020/05/16/leetcode/2020/199-er-cha-shu-de-you-shi-tu/"/>
      <url>2020/05/16/leetcode/2020/199-er-cha-shu-de-you-shi-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><blockquote><p>输入: [1,2,3,null,5,null,4]</p><p>输出: [1, 3, 4]</p><p>解释:</p><p>1            &lt;—-</p><p>/   \</p><p>2     3         &lt;—-</p><p>\     \</p><p>5     4       &lt;—-</p></blockquote><p>来源：力扣（LeetCode）<br><br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view">https://leetcode-cn.com/problems/binary-tree-right-side-view</a></p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>二叉树题目，个人感觉要么 <strong>dfs</strong> ，要么 <strong>bfs</strong>。</p><p><strong>dfs</strong> 就是前序遍历，后序遍历，中序遍历，<strong>bfs</strong> 就是层次遍历。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:  vector<int> rightSideView(TreeNode *root) {    vector<int> ans;    if (root == nullptr) {      return ans;    }    dfs(root, ans, 0);    return ans;  }  void dfs(TreeNode *root, vector<int> &ans, int high) {    if (root == nullptr) {      return;    }    if (high == ans.size()) {      ans.emplace_back(root->val);    }    dfs(root->right, ans, high + 1);    dfs(root->left, ans, high + 1);  }};</code></pre><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:  vector<int> rightSideView(TreeNode *root) {    vector<int> ans;    if (!root) {      return ans;    }    queue<TreeNode *> que;    que.push(root);    while (!que.empty()) {      int size = que.size();      TreeNode *node = que.front();      ans.emplace_back(node->val);      while (size--) {        TreeNode *temp = que.front();        que.pop();        if (temp->right) {          que.push(temp->right);        }        if (temp->left) {          que.push(temp->left);        }      }    }    return ans;  }};</code></pre><p><strong>BFS</strong> 貌似都是套路步骤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是要多刷题，刷多了很多都可以直接套板子。</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>爱莲说</center><center>周敦颐</center><center>水陆草木之花，可爱者盛蕃。晋陶渊明独爱菊；自李唐来，世人甚爱牡丹；予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清，亭亭净植，可远观而不可亵玩焉。</center><center>予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。噫！菊之爱，陶后鲜有闻；莲之爱，同予者何人？牡丹之爱，宜乎众矣。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 两数之和</title>
      <link href="2020/05/16/leetcode/2020/1-liang-shu-zhi-he/"/>
      <url>2020/05/16/leetcode/2020/1-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p></blockquote><h2 id="一-两数之和"><a href="#一-两数之和" class="headerlink" title="一.两数之和"></a>一.两数之和</h2><h4 id="1-最初想法"><a href="#1-最初想法" class="headerlink" title="1. 最初想法"></a>1. 最初想法</h4><p>直接暴力求解</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        vector<int> vec;        for (decltype(nums.size()) i = 0; i < nums.size(); ++i) {            for (decltype(i) j = i + 1; j < nums.size(); ++j) {                if ((nums[i] + nums[j]) == target) {                    vec.emplace_back(i);                    vec.emplace_back(j);                    return vec;                }            }        }        return vec;    }};</code></pre><p>暴力不一定是最慢的，但是最慢的暴力应该可占一席！</p><p>时间复杂度：O(n^2^)</p><p>空间复杂度：O(1)</p><h4 id="2-参考后解法"><a href="#2-参考后解法" class="headerlink" title="2. 参考后解法"></a>2. 参考后解法</h4><p>哈希表（ <strong>unordered_map</strong> ）</p><p>我们知道 <strong>map</strong> 有两个键值对，我们第一遍把 <strong>nums</strong> 的索引及内容放 <strong>unordered_map</strong> 里面，第二次遍历的时候从 <strong>unordered_map</strong> 里面找是否有满足条件的内容，如有，保存索引即可！</p><p>抛出一种错误解法😂</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<int> twoSum(vector<int> &nums, int target) {    unordered_map<int, int> mp;    int size = nums.size();    for (int i = 0; i < size; ++i) {      mp[nums[i]] = i;    }    for (int i = 0; i < size; ++i) {      int temp = target - nums[i];      if (mp.count(temp) == 1) {        return {mp[temp], i};      }    }    return {};  }};</code></pre><p>示例：</p><blockquote><p>输入：<strong>[3,2,4] <br>             6</strong></p><p>输出：<strong>[0,0]</strong></p><p>预期：<strong>[1,2]</strong></p></blockquote><p>错误原因</p><p>当循环遍历到 <strong>i = 0</strong> 时， <strong>temp = 3，正好unordered_map里有这个3，索引为0，直接返回</strong></p><p>这不是我们期望看到了！</p><p>当然，这也不是题目所允许的！</p><blockquote><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></blockquote><p>解决办法</p><p>保证每次取得 <strong>‘i’，’j’</strong> 不相等即可！</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<int> twoSum(vector<int> &nums, int target) {    unordered_map<int, int> mp;    int size = nums.size();    for (int i = 0; i < size; ++i) {      mp[nums[i]] = i;    }    for (int i = 0; i < size; ++i) {      int temp = target - nums[i];      if (mp.count(temp) == 1 && mp[temp] != i) {        return {mp[temp], i};      }    }    return {};  }};</code></pre><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h4 id="3-再次优化"><a href="#3-再次优化" class="headerlink" title="3. 再次优化"></a>3. 再次优化</h4><p>事实上，我们可以插入查找同时进行！</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<int> twoSum(vector<int> &nums, int target) {    unordered_map<int, int> mp;    int size = nums.size();    for (int i = 0; i < size; ++i) {      int temp = target - nums[i];      if (mp.count(temp) == 1 && mp[temp] != i) {        return {mp[temp], i};      }      mp[nums[i]] = i;    }    return {};  }};</code></pre><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二. 总结"></a>二. 总结</h2><p>此题比较简单，如果用暴力解法AC完便草草了事，显然是不够的。</p><p>笔者认为此题可以当作哈希入门题，以此大致了解哈希的用途！</p><p>进阶：</p><p><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>望岳<center>杜甫</center><center>岱宗夫如何？齐鲁青未了。<br>造化钟神秀，阴阳割昏晓。<br>荡胸生层云，决眦入归鸟。<br>    会当凌绝顶，一览众山小。</center></center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. 岛屿数量</title>
      <link href="2020/05/16/leetcode/2020/200-dao-yu-shu-liang/"/>
      <url>2020/05/16/leetcode/2020/200-dao-yu-shu-liang/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:</p><blockquote><p>输入:</p><p>11110</p><p>11010</p><p>11000</p><p>00000</p><p>输出: 1</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入:</p><p>11000</p><p>11000</p><p>00100</p><p>00011</p><p>输出: 3</p><p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>我估摸着扣哥还是放水了吧~</p><p>这怕是每个人入门 <strong>dfs</strong> 的题目了吧？</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//可以寻找的方向，左右上下int mvDistance[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};class Solution {public:  int numIslands(vector<vector<char>> &grid) {    int res = 0;    int rows = grid.size(); // grid的行    if (rows == 0) {      return res;    }    int cols = grid[0].size(); // grid的列    for (int i = 0; i < rows; ++i) {      for (int j = 0; j < cols; ++j) {        // 从1开始找        if (grid[i][j] == '1') {          dfs(i, j, grid, rows, cols);          // 把所有的1都找完了，说明找到了一块连着的1，就要加1          ++res;        }      }    }    return res;  }  void dfs(int x, int y, vector<vector<char>> &grid, int rows, int cols) {    // 这个1我已经用过了，以后我不能再用了。    grid[x][y] = '0';    for (int i = 0; i < 4; ++i) {      //左右上下移动      int mx = x + mvDistance[i][0], my = y + mvDistance[i][1];      //如果左右上下有满足条件的1，就从当前1作为起点开始找      if (0 <= mx && mx < rows && 0 <= my && my < cols && grid[mx][my] == '1') {        dfs(mx, my, grid, rows, cols);      }    }  }};</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是要多刷题，曾几何时，这种题我看都不敢看，虽然现在也还是很菜，但至少我敢看题目了。</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>蝶恋花</center><center>晏殊</center><center>槛菊愁烟兰泣露，罗慕轻寒，燕子双飞去。明月不谙离恨苦，斜光到晓穿朱户。</center><center>昨夜西风凋碧树，独上高楼，望尽天涯路。欲寄彩笺兼尺素，山长水阔知何处？</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复的字符串的最长子串</title>
      <link href="2020/05/16/leetcode/2020/3-wu-chong-fu-zi-fu-chuan-de-zui-chang-zi-chuan/"/>
      <url>2020/05/16/leetcode/2020/3-wu-chong-fu-zi-fu-chuan-de-zui-chang-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: “abcabcbb” </p><p>输出: 3 </p><p>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: “bbbbb”</p><p>输出: 1</p><p>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: “pwwkew”</p><p>输出: 3</p><p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a></p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int lengthOfLongestSubstring(string s) {    int size = s.size(), ans = 0, k, i, j;    // 本质还是滑动窗口！    for (i = 0; i < size; ++i) {      for (j = i + 1; j < size; ++j) {        for (k = i; k < j; ++k) {          /**           * 比如：a b c a b c b b           * i = 0， j = 1, 我们要找的是 i 到 j 之间的最长无重复子串           */          if (s[k] == s[j]) {            // 有重复，就退出            break;          }        }        if (k != j) {          /* 如果，中间有重复，第三层 for 会通过 break 退出，这里也要退出，要使           * i + 1           */          break;        }      }      int tmp = j - i;      // 求出最长的无重复子串      if (ans < tmp) {        ans = tmp;      }    }    return ans;  }};</code></pre><p><strong><em>python代码</em></strong></p><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def lengthOfLongestSubstring(self, s: str) -> int:        size = len(s)        if size == 1:            return 1        ans = 0        i = 0        j = i + 1        k = i        for i in range(0, size, 1):            for j in range(i + 1, size, 1):                for k in range(i, j, 1):                    if s[k] == s[j]:                        break                else:                    k += 1                if k != j:                    break            else:                j += 1            tmp = j - i            if ans < tmp:                ans = tmp        return ans</code></pre><p><strong><em>python暴力必超时啊😱</em></strong></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>不用 <strong><em>unordered_set</em></strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int lengthOfLongestSubstring(string s) {    //三指针, mid指针用来判断left ~ right中间是否有重复元素,    // left跟right指针用来计算元素个数    int len = s.size(), max = 1, left = 0, right, mid;    if (len == 0) {      return 0;    }    for (right = 1; right < len; ++right) {      // 判断left ~ right中间有没有重复元素      for (mid = left; mid < right; ++mid) {        if (s[mid] == s[right]) {          // 如果有重复元素, 一切作废!          /**比如:           * a   b   c   a   b   c   b   b           *            left  mid        right           * 此时s[mid] == s[right]           * 说明不满足条件, left指针此时应该指向c元素, 即left = mid + 1           * 跳出判断子串重复循环!           */          left = mid + 1;          break;        }      }      if (right - left + 1 > max) {        /**比如:         * 0   1   2   3   4   5   6   7         * a   b   c   a   b   c   b   b         * left    right         * 此时满足题意, 子串长度为 2 - 0 + 1, 即right - left + 1         * 更新max即可         */        max = right - left + 1;      }    }    return max;  }};</code></pre><p><strong><em>python代码</em></strong></p><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def lengthOfLongestSubstring(self, s: str) -> int:        size = len(s)        maxValue = 1        low = 0        high = 1        mid = low        if size == 0:            return 0        for high in range(1, size, 1):            for mid in range(low, high, 1):                if s[mid] == s[high]:                    low = mid + 1                    break            if high - low + 1 > maxValue:                maxValue = high - low + 1        return maxValue</code></pre><p>使用 <strong><em>unordered_set</em></strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int lengthOfLongestSubstring(string s) {    unordered_set<char> appear;    int size = s.size();    int right = -1, ans = 0;    for (int i = 0; i < size; ++i) {      if (i != 0) {        appear.erase(s[i - 1]);      }      while (right + 1 < size && !appear.count(s[right + 1])) {        appear.insert(s[right + 1]);        ++right;      }      ans = max(ans, right - i + 1);    }    return ans;  }};</code></pre><p><strong><em>python代码</em></strong></p><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def lengthOfLongestSubstring(self, s: str) -> int:        appear = set()        n = len(s)        right, ans = -1, 0        for i in range(n):            if i != 0:                appear.remove(s[i - 1])            while right + 1 < n and s[right + 1] not in appear:                appear.add(s[right + 1])                right += 1            ans = max(ans, right - i + 1)        return ans</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多刷题，做多了都是套路，哈哈哈🤣🤣🤣</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>卜算子·咏梅</center><center>陆游</center>驿外断桥边，寂寞开无主。已是黄昏独自愁，更着风和雨。<center>无意苦争春，一任群芳妒。零落成泥碾作尘，只有香如故。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>372. 超级次方</title>
      <link href="2020/05/16/leetcode/2020/372.chao-ji-ci-fang/"/>
      <url>2020/05/16/leetcode/2020/372.chao-ji-ci-fang/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/super-pow/">超级次方</a></p><p>一开始直接用快速幂，结果直接超时。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">long long FastPow(long long a,long long c){    long long res=1;    while(c)    {        if(c&1)        {            res*=a;            res%=1337;        }        a*=a;        a%=1337;        c>>=1;    }    return res;}int superPow(int a, int* b, int bSize){    long long count,c=0;    for(int i=0;i<bSize;i++)        c+=(b[i]*pow(10,(bSize-i-1)));    //printf("%d ",c);    count=FastPow(a,c);    return count;}</code></pre><p>欧拉降幂公式：</p><p><img src="https://img-blog.csdnimg.cn/20190818155329442.png" alt="在这里插入图片描述"></p><p>Φ（c）是欧拉函数</p><p>详情请看：<a href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</a></p><p>求法如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int eular(int n){    int ret=1,i;    for(i=2; i*i<=n; i++)    {        if(n%i==0)        {            n/=i;            ret*=i-1;            while(n%i==0)            {                n/=i;                ret*=i;            }        }    }    if(n>1)        ret*=n-1;    return ret;}</code></pre><p>欧拉函数求出来了，直接A题，代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">long long FastPow(long long a,long long c){    long long res=1;    a%=1337;    while(c)    {        if(c&1)        {            res*=a;            res%=1337;        }        a*=a;        a%=1337;        c>>=1;    }    return res;}int eular(int n){    int ret=1,i;    for(i=2; i*i<=n; i++)    {        if(n%i==0)        {            n/=i;            ret*=i-1;            while(n%i==0)            {                n/=i;                ret*=i;            }        }    }    if(n>1)        ret*=n-1;    return ret;}int superPow(int a, int* b, int bSize){    int n = 0,temp;    temp=eular(1337);    if(bSize==0){        return 0;    }    for(int i=0;i<bSize;i++){        n*=10;        n+=b[i];        n%=temp;        n+=temp;    }    return FastPow(a,n);}</code></pre><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. 括号生成</title>
      <link href="2020/05/16/leetcode/2020/22-gua-hao-sheng-cheng/"/>
      <url>2020/05/16/leetcode/2020/22-gua-hao-sheng-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：</p><blockquote><p>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses">https://leetcode-cn.com/problems/generate-parentheses</a></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们看下当<strong>n = 3</strong>时的二叉树结构</p><p><img src="https://gitee.com/incipe-win/images/raw/master/20200409124356384.png" alt=""></p><p>由此二叉树结构图我们可以得知的信息：</p><ul><li>当<strong>左括号小于n</strong>时：<ul><li>先产生<strong>左分支(左括号小于n)</strong>；</li><li><strong>左分支(左括号小于n)且当前左分支已经产生</strong>这两个条件不满足时，产生<strong>右分支(左括号大于右括号)</strong>；</li><li>当产生<strong>左分支条件(左括号小于n)</strong>和<strong>右分支条件(左括号大于右括号)</strong>不满足时，回溯到可以继续产生分支的节点。</li></ul></li><li>结束寻找的条件是左括号个数等于<strong>n</strong>并且右括号个数等于<strong>n</strong></li></ul><p>思路就是不断搜索，显然跟二叉树的<strong>深度遍历</strong>有点像。</p><p><strong>深度遍历</strong>一般用递归，显然我们已经分析出了递归结束的条件<strong><em>(左括号个数等于n并且右括号个数等于n)</em></strong></p><pre class=" language-lang-c++"><code class="language-lang-c++">if (左括号个数 == n && 右括号个数 == n) {    vec.emplace_back(当前满足条件的括号匹配);    return;}</code></pre><p>由此可得知，我们的递归函数需要的变量<strong>左括号个数left</strong>，<strong>右括号个数right</strong>，题目给的<strong>n</strong>，保存<strong>当前满足条件的括号匹配str</strong>，还有一个<strong>返回给测评机的字符串向量vec</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<string> generateParenthesis(int n) {    vector<string> vec;    if (n == 0) {      return vec;    }    recursion(vec, "", 0, 0, n);    return vec;  }  void recursion(vector<string> &vec, string str, int left, int right, int n) {    //递归结束条件    if (left == n && right == n) {      vec.emplace_back(str);      return;    }    if (left < n) {      recursion(vec, str + "(", left + 1, right, n);    }    if (left > right) {      recursion(vec, str + ")", left, right + 1, n);    }  }};</code></pre><p>因为，最开始的时候<strong>左括号和右括号都没有，所以传0进去，满足要求的括号匹配也没有，传空字符串就好了</strong>。</p><p>深搜题：<a href="https://leetcode-cn.com/problems/permutations/">全排列</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以后遇到，类似 <strong><em><code>所有可能，全排列……</code></em></strong> 这种题，首先要想到的是递归！</p><p>既然要用递归，画个二叉树，递归结构就搞的清清楚楚了。</p><p>感觉题解写的挺烂的，毕竟本人也是个菜鸟，多多担待。</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>南乡子·登京口北固亭有怀</center><center>辛弃疾</center><center>何处望神州？满眼风光北固楼。千古兴亡多少事？悠悠。不尽长江滚滚流。</center><center>年少万兜鍪，坐断东南战未休。天下英雄谁敌手？曹刘。生子当如孙仲谋。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. 接雨水</title>
      <link href="2020/05/16/leetcode/2020/42-jie-yu-shui/"/>
      <url>2020/05/16/leetcode/2020/42-jie-yu-shui/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:</p><blockquote><p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water">https://leetcode-cn.com/problems/trapping-rain-water</a></p></blockquote><h2 id="一-接雨水"><a href="#一-接雨水" class="headerlink" title="一. 接雨水"></a>一. 接雨水</h2><h3 id="最初想法"><a href="#最初想法" class="headerlink" title="最初想法"></a>最初想法</h3><p>想要接到雨水就要，就要保证是个“凹”形状的容器，而接到的雨水的多少，就要看“凹”形容器的最短边。</p><p>那么我们就找这样一个“尽可能大“的“凹”形就好了。</p><p>怎样找到这个最大的“凹”形？</p><p>我们找到当前位置左边最高的柱子，再找到右边最高的柱子，这不就是最大的“凹”吗？</p><p>当然不是每次都能找到这个“凹”形的！</p><p>例1：</p><p><code>当我们遍历到第二个柱子的高度(1)时,我们找当前柱子左边的最高柱子,是本身,找当前柱子右边的最高柱子(3),是第八根柱子,显然,没有构成"凹"形.</code></p><p>例2：</p><p><code>当我们遍历到第三根柱子的高度(0)时,左边最高的柱子是第二根(1),右边最高的柱子是第四根(2),显然,构成了一个"凹"形.</code></p><p>当我们找到了“凹”形，就可以计算可以接多少雨水了。</p><p>按照例2，我们可以接到的雨水为 <strong>min(左边最高柱子高度, 右边最高柱子高度)</strong> </p><p>但是，这个好像还是有点问题！</p><p>例3：</p><p><code>当我们遍历到第五根柱子高度(1)时,左边最高柱子是第四根(2),右边最高柱子是第八根(3),显然构成"凹"形</code></p><p>但是这个能接到的雨水是 <strong>min(左边最高柱子高度, 右边最高柱子高度)</strong> 吗？</p><p>显然不是的。</p><p>综上得知：</p><p><strong>接到的雨水 = min(左边最高柱子高度, 右边最高柱子高度) - 当前柱子的高度</strong></p><p>根据得出的结论，我们容易写出代码。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int trap(vector<int> &height) {    int size = height.size();    int ans = 0;    for (int i = 0; i < size; ++i) {      int max_left = 0, max_right = 0;      for (int j = 0; j <= i; ++j) {        max_left = max(height[j], max_left);      }      for (int j = i; j < size; ++j) {        max_right = max(height[j], max_right);      }      ans += min(max_left, max_right) - height[i];    }    return ans;  }};</code></pre><p>但是，这个貌似超时了。</p><p>我们试下可不可以“卡”过去，第一根柱子和最后一根柱子，我们不需要遍历，因为这两根柱子不可能构成“凹”形的！</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int trap(vector<int> &height) {    int size = height.size();    int ans = 0;    for (int i = 1; i < size - 1; ++i) {      int max_left = 0, max_right = 0;      for (int j = 0; j <= i; ++j) {        max_left = max(height[j], max_left);      }      for (int j = i; j < size; ++j) {        max_right = max(height[j], max_right);      }      ans += min(max_left, max_right) - height[i];    }    return ans;  }};</code></pre><blockquote><p>执行结果：通过</p><p>执行用时 :848 ms, 在所有 C++ 提交中击败了5.03%的用户</p><p>内存消耗 :7 MB, 在所有 C++ 提交中击败了100.00%的用户</p></blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p>好了，勉强过了，这么慢的代码，怎么符合大家的形象呢？</p><h3 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h3><p>想法挺好的，也是正确的。但是，我们容易看到每次遍历柱子时，都要找一遍左边最高柱子，右边最高柱子。</p><p>为什么我们不能把 <strong>每个位置对应的左右最高的两个柱子存起来</strong> ，要用拿来用就行了，这样我们就不要每次去找了。</p><p>这就是所谓的 <strong>空间换时间！</strong> </p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int trap(vector<int> &height) {    if (height.size() == 0) {      return 0;    }    int ans = 0;    int size = height.size();    vector<int> left_max(size), right_max(size);    left_max[0] = height[0];    for (int i = 1; i < size; ++i) {      left_max[i] = max(height[i], left_max[i - 1]);    }    right_max[size - 1] = height[size - 1];    for (int i = size - 2; i >= 0; --i) {      right_max[i] = max(height[i], right_max[i + 1]);    }    print(left_max);    print(right_max);    for (int i = 1; i < size - 1; ++i) {      ans += min(left_max[i], right_max[i]) - height[i];    }    return ans;  }  void print(vector<int> &nums) {    int len = nums.size();    for (auto i : nums) {      cout << i << " ";    }    cout << endl;  }};</code></pre><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h2 id="二-总结"><a href="#二-总结" class="headerlink" title="二. 总结"></a>二. 总结</h2><p>试试用栈做这道题？</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><center>南园十三首·其五</center><center>李贺</center><center>男儿何不带吴钩，收取关山五十州。</center><center>请君暂上凌烟阁，若个书生万户侯？</center><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>455. 两数相加Ⅱ</title>
      <link href="2020/05/16/leetcode/2020/445-liang-shu-xiang-jia-ii/"/>
      <url>2020/05/16/leetcode/2020/445-liang-shu-xiang-jia-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：</p><blockquote><pre><code>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre></blockquote></blockquote><h2 id="思路及解法"><a href="#思路及解法" class="headerlink" title="思路及解法"></a>思路及解法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题跟<a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>基本一样。</p><p>一个是正着算，另一个是倒着算。</p><p>那么我们只要把这两个链表翻转就好了！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:  ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {    l1 = reverse(l1);    l2 = reverse(l2);    int carry = 0;    ListNode *ans = nullptr;    while (l1 != nullptr || l2 != nullptr || carry != 0) {      int a = (l1 != nullptr) ? l1->val : 0;      int b = (l2 != nullptr) ? l2->val : 0;      int sum = a + b + carry;      carry = sum / 10;      sum %= 10;      auto cur = new ListNode(sum);      cur->next = ans;      ans = cur;      if (l1 != nullptr) {        l1 = l1->next;      }      if (l2 != nullptr) {        l2 = l2->next;      }    }    return ans;  }  ListNode *reverse(ListNode *head) {    ListNode *node = nullptr;    while (head) {      ListNode *cur = head->next; //保存head->next结点信息      head->next = node;          //反转指向      node = head;                //后移node      head = cur;                 //后移head    }    return node;  }};</code></pre><p>个人觉得最难的是这几行代码，初次写代码也是不易想到的。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">      auto cur = new ListNode(sum);      cur->next = ans;      ans = cur;</code></pre><p>注意：这里的 <strong><em>new ListNode(sum)</em></strong> 不是指开辟一个大小为 <strong>sum</strong> 的链表！</p><hr><p><strong><em>new ListNode(sum)</em></strong>不仅仅为对象 <strong>ListNode</strong>在堆上分配了空间， 而且还调用了  <strong>ListNode</strong> 的默认拷贝构造函数，生成了这个对象。</p><p>而 <strong><em>new List Node[sum]</em></strong> 仅仅分配了空间。</p><hr><p>题目要求不翻转链表，那么我们用栈来实现即可！</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:  ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {    stack<int> s1, s2;    while (l1) {      s1.push(l1->val);      l1 = l1->next;    }    while (l2) {      s2.push(l2->val);      l2 = l2->next;    }    int carry = 0;    ListNode *ans = nullptr;    while (!s1.empty() || !s2.empty() || carry != 0) {      int a = (!s1.empty()) ? s1.top() : 0;      int b = (!s2.empty()) ? s2.top() : 0;      int sum = a + b + carry;      carry = sum / 10;      sum %= 10;      auto cur = new ListNode(sum);      cur->next = ans;      ans = cur;      if (!s1.empty()) {        s1.pop();      }      if (!s2.empty()) {        s2.pop();      }    }    return ans;  }};</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>许多的链表题目都可以用递归来实现。</p><p>何时使用递归(笔者的一点点看法)</p><ol><li>能把问题拆解的；</li><li>不用递归，用循环不好解决的；</li><li>递归基数不算太大的（递归次数太多可能挤爆栈）；</li><li>明显的 <strong><em>dfs</em></strong> 搜索。</li></ol><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>陋室铭</center><center>刘禹锡</center><p></p><center>山不在高，有仙则名。</center> <p></p><p></p><center>水不在深，有龙则灵。</center> <p></p><p></p><center>斯是陋室，唯吾德馨。</center><p></p><p></p><center>苔痕上阶绿，草色入帘青。</center><p></p><p></p><center>谈笑有鸿儒，往来无白丁。</center><p></p><p></p><center>可以调素琴，阅金经。</center><p></p><p></p><center>无丝竹之乱耳，无案牍之劳形。</center><p></p><p></p><center>南阳诸葛庐，西蜀子云亭。</center><p></p><p></p><center>孔子云：何陋之有？<p></p></center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. 全排列</title>
      <link href="2020/05/16/leetcode/2020/46-quan-pai-lie/"/>
      <url>2020/05/16/leetcode/2020/46-quan-pai-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><blockquote><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations">https://leetcode-cn.com/problems/permutations</a></p></blockquote></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="1-直接调库"><a href="#1-直接调库" class="headerlink" title="1. 直接调库"></a>1. 直接调库</h3><p>C++的STL提供了 <strong>next_permutation()</strong>和<strong>prev_permutation()</strong></p><p><strong>next_permutation()作用是寻找所有比当前排列大的排列，顺序是从小到大。</strong></p><p><strong>prev_permutation()作用是寻找所有比当前排列小的排列，顺序是从大到小。</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<vector<int>> permute(vector<int> &nums) {    sort(nums.begin(), nums.end());    vector<vector<int>> vec;    vec.emplace_back(nums);    while (next_permutation(nums.begin(), nums.end())) {      vec.emplace_back(nums);    }    return vec;  }};</code></pre><p>当然，直接用库还是不太好的🙅。</p><p>顺便我们看下 <strong>next_permutation()</strong> 的实现。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">template<class BidirIt>bool next_permutation(BidirIt first, BidirIt last){    if (first == last) return false;    BidirIt i = last;    if (first == --i) return false;    while (true) {        BidirIt i1, i2;        i1 = i;        if (*--i < *i1) {            i2 = last;            while (!(*i < *--i2))                ;            std::iter_swap(i, i2);            std::reverse(i1, last);            return true;        }        if (i == first) {            std::reverse(first, last);            return false;        }    }}</code></pre><h3 id="2-递归解决"><a href="#2-递归解决" class="headerlink" title="2.递归解决"></a>2.递归解决</h3><p>以 <strong><em>[1, 2, 3]</em></strong> 为例：</p><p>以 <strong><em>1</em></strong> 开头的排列：<code>[1, 2, 3], [1, 3, 2]</code>;</p><p>以 <strong><em>2</em></strong>开头的排列：<code>[2, 1, 3], [2, 3, 1]</code>;</p><p>以 <strong><em>3</em></strong>开头的排列：<code>[3, 1, 2], [3, 2, 1]</code>;</p><p>我们得出这样一颗树：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lZGNjZjQ2YS1hYTJhLTQ4OTctODVkNC1lNWNjNGIwZTk2YmYucG5n?x-oss-process=image/format,png" alt="结构"></p><p>我们根据这颗树，可以写出如下代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<vector<int>> permute(vector<int> &nums) {    vector<vector<int>> vec;    int size = nums.size();    for (int i = 0; i < size; ++i) {      for (int j = 0; j < size; ++j) {        for (int k = 0; k < size; ++k) {          if (nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]) {            vec.push_back({nums[i], nums[j], nums[k]});          }        }      }    }    print(vec);    return vec;  }  void print(vector<vector<int>> &vec) {    for (decltype(vec.size()) i = 0; i < vec.size(); ++i) {      for (decltype(i) j = 0; j < vec[i].size(); ++j) {        cout << vec[i][j] << " ";      }      cout << endl;    }  }};</code></pre><p>好了，我们解决了数组长度为 <strong>3</strong> 的全排列，有三重循环，那么如果数组长度为 <strong>4，5，……</strong> ，又该怎么做？因为数组长度是不定的，所以这种方法不能用了，而且，也没人会去<em>傻傻的</em>写超级多重循环吧！</p><p>我们发现这个过程好像跟 <strong>“深搜”</strong> 挺相似的，没错，就是 <strong><em>dfs</em></strong> ，那么我们就写个<strong><em>dfs</em></strong>不就好了吗？</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<vector<int>> permute(vector<int> &nums) {    vector<vector<int>> vec;    int size = nums.size();    vector<bool> flag(size, false);    vector<int> temp;    recusive(size, nums, temp, vec, flag, 0);    return vec;  }  /**   * size是nums的长度,   * temp做临时vector, 保存每次搜索结束后全排列的结果,   * vec返回给测评机的二维vector,   * flag记录当前搜索过程中该数据是否使用了,   * cnt记录搜索的深度。   **/  void recusive(int size, vector<int> &nums, vector<int> &temp,                vector<vector<int>> &vec, vector<bool> &flag, int cnt) {    if (cnt == size) {      vec.emplace_back(temp);      return;    }    for (int i = 0; i < size; ++i) {      // 如果没有使用过      if (!flag[i]) {        temp.emplace_back(nums[i]);        flag[i] = true;        // recusive之前是 “递”        recusive(size, nums, temp, vec, flag, cnt + 1);        // recusive之后是 “归”        flag[i] = false;        temp.erase(temp.end() - 1); // 回溯      }    }  }};</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到网上的一种写法，就想起了 <strong>荀子《劝学》</strong> 中的一句名言 <strong><em>故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。</em></strong></p><p>附带解法：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<vector<int>> permute(vector<int> &nums) {    vector<vector<int>> res;    dfs(res, 0, nums);    return res;  }  void dfs(vector<vector<int>> &res, int start, vector<int> &nums) {    if (start == nums.size()) {      res.push_back(nums);      return;    }    for (int i = start; i < nums.size(); i++) {      swap(nums[start], nums[i]);      dfs(res, start + 1, nums);      swap(nums[start], nums[i]);    }    return;  }};</code></pre><p>我肯定是想不到这样子写的👀</p><p>不断学习，任重而道远。</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>满江红·写怀</center><center>岳飞</center><center>怒发冲冠，凭栏处，潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！</center><center>靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山阙。壮士饥餐胡虏肉，笑谈渴饮匈奴血。待从头，收拾旧山河，<br>朝天阙。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. 跳跃游戏</title>
      <link href="2020/05/16/leetcode/2020/55-tiao-yue-you-xi/"/>
      <url>2020/05/16/leetcode/2020/55-tiao-yue-you-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [2,3,1,1,4] </p><p>输出: true</p><p>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [3,2,1,0,4]</p><p>输出: false</p><p>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/jump-game">https://leetcode-cn.com/problems/jump-game</a></p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>一开始好像没什么思路。</p><p>先来模拟下这个游戏：</p><p><code>[2, 3, 1, 1, 4]</code></p><p>我们在 <strong>2，nums[0]</strong> 处最多可以跳两个，跳最远距离( <strong>2</strong> )来到 <strong>1， nums[2]</strong>，接着跳最远的距离( <strong>1</strong> )来到 <strong>1，nums[3]</strong> ，最后到达最后一个位置 <strong>4，nums[4]</strong>。</p><p>再来个例子试试：</p><p><code>[3, 3, 1, 0, 4]</code></p><p>我们按照我们第一次模拟的方法，直接跳到 <strong>0，nums[4]</strong> ，直接完蛋。</p><p>但是，我们第一次可以 <strong>不跳</strong> 最远距离( <strong>3</strong> ) ，只跳一步不就可以到 <strong>3，nums[1]</strong> ，然后又可以到达最后一个位置了吗？</p><p>思路不就来了吗？</p><p>我们遍历每个位置，如果前一个位置的能跳到的最远距离大于当前位置，说明我们可以跳到当前位置，我们为了防止出现第二个例子的情况，我们把当前位置能跳到的最远距离和前一个位置能跳到的最远距离比较，如果大，说明我们可以跳到更远的地方。如果能跳到的最远距离大于最后一个位置的距离，返回结果。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  bool canJump(vector<int> &nums) {    int size = nums.size();    int maxDistance = 0;    /* i表示当前位置，nums[i] + i 表示可以跳到的最远的位置 */    for (int i = 0; i < size; ++i) {      if (i <= maxDistance) {        maxDistance = max(nums[i] + i, maxDistance);      }    }    return maxDistance >= size - 1;  }};</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉贪心就是人的一种本能，所以做贪心题目时，或许可以联系下生活。</p><p>这题也折腾挺久的，一开始把每个位置所能到达的最远的距离用向量保存起来，然后遍历该向量，如果下一个位置能跳到的最远距离大于上一个位置的，就更新最远位置。仔细想想，这样做很明显不对。</p><p>这题感觉应该还可以加大难度，求最少步数。</p><p>看了下相似题目，果然有个Ⅱ。</p><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏Ⅱ</a></p><p>附跳跃游戏Ⅱ代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  int jump(vector<int> &nums) {    int size = nums.size();    if (size == 1) {      return 0;    }    int maxDistance = 0; // 能跳的最远距离    int cnt = 0;         // 步数    int board = 0;       // 能跳的最远距离的位置    for (int i = 0; i < size - 1; ++i) {      maxDistance = max(nums[i] + i, maxDistance);      if (i == board) {        board = maxDistance;        ++cnt;        if (board >= size - 1) {          return cnt;        }      }    }    return cnt;  }};</code></pre><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>青玉案·元夕</center><center>辛弃疾</center><center>东风夜放花千树，更吹落，星如雨。宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。</center><center>蛾儿雪柳黄金缕，笑语盈盈暗香去。众里寻他千百度，蓦然回首，那人却在，灯火阑珊处。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. 合并区间</title>
      <link href="2020/05/16/leetcode/2020/56-he-bing-qu-jian/"/>
      <url>2020/05/16/leetcode/2020/56-he-bing-qu-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><blockquote><pre><strong>输入:</strong> [[1,3],[2,6],[8,10],[15,18]]<strong>输出:</strong> [[1,6],[8,10],[15,18]]<strong>解释:</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</pre></blockquote><p><strong>示例 2:</strong></p><blockquote><pre><strong>输入:</strong> [[1,4],[4,5]]<strong>输出:</strong> [[1,5]]<strong>解释:</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre></blockquote></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>此题，难度不算很大。</p><p>我们要合并两个区间，必须满足：</p><ol><li>第一个区间左边的数字肯定要小于第二个区间左边的数字；</li><li>第一个区间右边的数字肯定要大于第二个区间左边的数字；</li></ol><p>合并区间：</p><ol><li>满足合并区间的条件后；</li><li>新的区间左边的数字为原第一个区间左边的数字，新区间右边的数字为 <strong>原第一个区间右边数字和原第二个区间右边数字的最大值。</strong></li></ol><p>举例：</p><p><code>[0, 4], [3, 5]</code></p><ol><li>0 &lt;= 3</li><li>4 &gt;= 3</li></ol><p>新区间为[0, 5]。</p><p><code>[0, 5], [3, 4]</code></p><ol><li>0 &lt;= 3</li><li>5 &gt;= 3</li></ol><p>新区间为[0, 5]</p><p>第一个条件很好满足，我们把二维向量按照第一个数字排序就好了。</p><p>第二个条件需要我们自己判断。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:  vector<vector<int>> merge(vector<vector<int>> &intervals) {    int size = intervals.size();    vector<vector<int>> ans;    sort(intervals.begin(), intervals.end());    int i;    for (i = 0; i < size; ++i) {      // 保存当前区间左边的数字和右边的数字      int left = intervals[i][0], right = intervals[i][1];      while (i < size - 1 && right >= intervals[i + 1][0]) {        // 我们要找到一个最新区间右边的数字        right = max(right, intervals[i + 1][1]);        ++i;      }      ans.push_back({left, right});    }    return ans;  }};</code></pre><p><strong><em>特别注意的是：我们的目的是合并所有可以合并的区间，不是找到两个区间可以合并就直接先合并这两个区间！</em></strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一开始写的时候，自己绕进去了，只想着遇到区间可以合并，合并以后就把新的区间保存。</p><p>关键是，自己用来测试的数据偏偏又是那么的 <strong>巧合</strong> ，都是连续的两个区间合并，没有比两个多区间可以合并，结果折腾了半天。</p><p>多看题目，多想题目，在做题之前把集中自己的精力，毕竟磨刀不误砍柴功。</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>使至塞上</center><center>王维</center><center>单车欲问边，属国过居延。</center><center>征蓬出汉塞，归雁入胡天。</center><center>大漠孤烟直，长河落日圆。</center><center>萧关逢侯骑，都护在燕然。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo搭载博客</title>
      <link href="2020/05/15/software/2020/github-hexo-da-zai-bo-ke/"/>
      <url>2020/05/15/software/2020/github-hexo-da-zai-bo-ke/</url>
      
        <content type="html"><![CDATA[<p><em>很久就想搞个自己的博客了，就从Github Pages练练手吧！</em></p><h2 id="1-创建Github账户"><a href="#1-创建Github账户" class="headerlink" title="1. 创建Github账户"></a>1. 创建Github账户</h2><p><img src="F:\Repositories\cpp\md\_posts\images/2020-03-13_194655.png" alt=""></p><p><img src="F:\Repositories\cpp\md\_posts\images/2020-03-13_194952.png" alt=""></p><p>接下来，直接通过 <strong>username.github.io</strong> 就可以打开Github Pages了！</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><p>这个就是一个软件的安装，不多讲了。</p><p><strong><em>注：如果不需要用Hexo搭载静态博客框架的，直接在github上操作就好了！</em></strong></p><p>在settings里面可以更改主题(是仓库里面的设置)</p><p><img src="F:\Repositories\cpp\md\_posts\images/2020-03-13_195705.png" alt=""></p><p><img src="F:\Repositories\cpp\md\_posts\images/2020-03-13_195835.png" alt=""></p><p>点击②修改主题，接着点提交就好了，请注意①处的地址是你所期望的</p><p><em>ps:有可能出现 <a href="https://username.github.io/username.github.io">https://username.github.io/username.github.io</a> 这样的url</em></p><p>Github还可以绑定自己购买的域名！</p><p>配置<em>Github</em>的教程可以参考<a href="https://blog.csdn.net/qq_43826212/article/details/100023631">传送门</a></p><p>接下来用Hexo搭载静态博客框架！</p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h2><h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><p>Hexo是一款基于Node.js的静态博客框架。 Hexo 使用 <a href="https://link.zhihu.com/?target=http%3A//daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><p>安装Hexo之前，我们需要安装Node.js。Git上文已经安装好了。</p><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p><a href="https://nodejs.org/en/download/">官网传送门</a></p><p>安装好后cmd输入 <strong>node -v</strong> 会出现node.js的版本号</p><p><strong>npm -v</strong> 会出现npm版本号</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在计算机本地创建一个文件夹，专门用来保存博客。</p><p>比如在F盘创建一个study/blog</p><p>右键该文件夹，输入</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">npm install hexo-cli -g</code></pre><p>有WARN没事的。</p><pre class=" language-lang-bash"><code class="language-lang-bash">$ npm install hexo-cli -gC:\Users\theigrams\AppData\Roaming\npm\hexo -> C:\Users\theigrams\AppData\Roaming\npm\node_modules\hexo-cli\bin\hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\hexo-cli\node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})+ hexo-cli@2.0.0updated 1 package in 25.401s</code></pre><p>这样子应该是安装成功了，不放心用</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">npm install hexo --save</code></pre><p>再来一次继续安装！</p><p>最后输入</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo -v</code></pre><p><img src="F:\Repositories\cpp\md\_posts\images/2020-03-13_201451.png" alt=""></p><p>有如下信息就说明安装成功！</p><p>继续输入</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo init</code></pre><p>会在blog文件夹下生成配置信息。</p><p>接着输入 <strong>npm install</strong> 安装必备组件。</p><p>如果报错:</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm WARN deprecated core-js@1.2.7: core-js@<2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.npm ERR! Unexpected end of JSON input while parsing near '...":{"accepts":"~1.0.7"'npm ERR! A complete log of this run can be found in:npm ERR!     C:\Users\theigrams\AppData\Roaming\npm-cache\_logs\2019-06-08T12_56_37_486Z-debug.log</code></pre><p>输入以下指令清除缓存</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm cache clean --force</code></pre><p>再输入 <strong>npm install</strong> ，有WARN没关系的。</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm WARN deprecated core-js@1.2.7: core-js@<2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.npm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})added 420 packages from 506 contributors and audited 4697 packages in 58.891sfound 2 low severity vulnerabilities  run `npm audit fix` to fix them, or `npm audit` for details</code></pre><p>执行 <strong>hexo s</strong> 后</p><p>打开链接<a href="https://link.zhihu.com/?target=http%3A//localhost%3A4000/">http://localhost:4000</a>，能看到网页就成功了！</p><p>Github+Hexo静态博客框架搭建好了，接下来就进行博客初始配置了！</p><h2 id="4-博客初始配置"><a href="#4-博客初始配置" class="headerlink" title="4. 博客初始配置"></a>4. 博客初始配置</h2><h4 id="配置Deployment"><a href="#配置Deployment" class="headerlink" title="配置Deployment"></a>配置Deployment</h4><p>首先要明确两个概念</p><blockquote><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录<code>study\blog</code>下，主要包含 Hexo 本身的配置；另一份位于主题目录<code>study\blog\themes\landscape</code>下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。</p></blockquote><p>打开 <strong>站点配置文件_config.yml</strong> </p><p>定位最后一行，改为如下配置：</p><pre class=" language-lang-bash"><code class="language-lang-bash">deploy:  type: git  repo: 你的仓库地址  branch: master</code></pre><p><img src="F:\Repositories\cpp\md\_posts\images/2020-03-13_204815.png" alt=""></p><p>完成后保存，右键blog文件，选择 <strong>Git Bush Here</strong> </p><p>执行执行以下指令来安装所需的插件：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">npm install hexo-deployer-git --save</code></pre><p>有警告没关系！</p><p>输入 <strong>hexo d</strong> </p><p>打开 <strong>username.github.io</strong> 访问你的个人博客！</p><h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><p>在Git窗口用命令：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new post "article title"</code></pre><p>或者直接在F:\study\blog\source_posts(这个就是本地博客的路径)建立.md文件即可。</p><p>推荐几个markdown好用的编辑器</p><p><a href="https://mdnice.com/">mdnice</a></p><p><a href="https://typora.io/">typora</a></p><h4 id="网站的渲染和发布"><a href="#网站的渲染和发布" class="headerlink" title="网站的渲染和发布"></a>网站的渲染和发布</h4><p>修改完 <strong>站点</strong> 配置文件<code>_config.yml</code>或增添新文章后，在终端中依次执行如下代码:</p><ul><li><code>hexo clean</code> 清理缓存</li><li><code>hexo generate</code> 进行渲染 简写 <code>hexo g</code></li><li><code>hexo server</code> 部署到本地(调试使用) 简写 <code>hexo s</code>。然后浏览器输入 <code>http://localhost:4000</code> 就可以看到你博客的效果啦，不过这是本地调试用，其他人是看不到的。(调试完毕后记得 <code>control + C</code> 关闭本地端口，不然下次就进不去啦)</li><li>调试完毕后使用 <code>hexo deploy</code> 简写为 <code>hexo d</code>来部署到git服务器。</li></ul><h4 id="个性化修改"><a href="#个性化修改" class="headerlink" title="个性化修改"></a>个性化修改</h4><p>在站点配置文件修改即可！</p><p><img src="F:\Repositories\cpp\md\_posts\images\2020-03-13_205915.png" alt=""></p><h4 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h4><p>主题很多种，笔者用的是<a href="https://github.com/theme-next/hexo-theme-next"> hexo-theme-next</a></p><p>进入官网<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/INSTALLATION.md">安装说明</a></p><p>进行安装即可。</p><p>然后将 <strong>站点</strong> 配置文件<code>_config.yml</code>中的<code>theme: landscape</code>修改为<code>theme: next</code></p><p>再运行以下指令：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo cleanhexo ghexo shexo d</code></pre><p>即可看到新主题。</p><p>如果报错</p><pre class=" language-lang-bash"><code class="language-lang-bash">Error: UNKNOWN: unknown error, stat 'F:\study\blog\themes\next\languages\default.yml'</code></pre><p>根据提示把default.yml删除即可解决问题</p><p>最后，祝大家学习愉快！</p><p><strong>才疏学浅，望雅正！</strong></p><blockquote id="fn_1"><sup>1</sup>. <a href="https://zhuanlan.zhihu.com/p/68625591">参考文章</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Settings Sync使用设置(亲测有效)</title>
      <link href="2020/05/15/software/2020/settings-sync-shi-yong-she-zhi-qin-ce-you-xiao/"/>
      <url>2020/05/15/software/2020/settings-sync-shi-yong-she-zhi-qin-ce-you-xiao/</url>
      
        <content type="html"><![CDATA[<p><strong><em>会当凌绝顶，一览众山小</em></strong></p><p>网上看了很多关于Sync的教程，感觉好像已经过时了，可读性不高，按照步骤也设置不好，结合自己的理解，和对他人的参考，<code>在这里插入代码片</code>写了个简单实用的教程！</p><h2 id="1-首先安装Seetings-Sync"><a href="#1-首先安装Seetings-Sync" class="headerlink" title="1.首先安装Seetings Sync"></a>1.首先安装Seetings Sync</h2><p>安装完毕后，打开Sync设置<br><em>方法：F1-&gt;Sync:Advanced Options-&gt;Sync:打开设置</em><br>我们只要配置这两个地方就好了!</p><p><img src="https://img-blog.csdnimg.cn/20191222232059953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-打开Github"><a href="#2-打开Github" class="headerlink" title="2.打开Github"></a>2.打开Github</h2><p><img src="https://img-blog.csdnimg.cn/20191222232258999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191222232504633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191222232639170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点Generate token(生成令牌,在最下方)</p><p>然后你会得到一串令牌,复制下来到Sync的Global Settings里面!</p><p><img src="https://img-blog.csdnimg.cn/20191222233009585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>创建gists</p><p><img src="https://img-blog.csdnimg.cn/20191222233159557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>好了之后，点击去创建的gists</p><p><img src="https://img-blog.csdnimg.cn/20191222233536475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后在地址栏最后一串字符就是Gists ID</p><p><img src="https://img-blog.csdnimg.cn/20191222234059997.png" alt="在这里插入图片描述"></p><p>复制填到Sync的Gists ID里面即可！</p><p>然后，Alt + Shift + U上传</p><p>Alt + Shift + D下载即可！</p><p>不仅上传插件，所有的配置文件也会上传，以后换电脑只要下载这个插件，填好令牌和ID，用Alt + Shift + D就可以使用原来自己配好了的Vscode了，大大提升了效率！</p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio 2019设置自定义背景及特效插件</title>
      <link href="2020/05/15/software/2020/visual-studio-2019-she-zhi-zi-ding-yi-bei-jing-ji-te-xiao-cha-jian/"/>
      <url>2020/05/15/software/2020/visual-studio-2019-she-zhi-zi-ding-yi-bei-jing-ji-te-xiao-cha-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装插件："><a href="#1-安装插件：" class="headerlink" title="1.安装插件："></a>1.安装插件：</h1><p>Background（ClaudiaIDE）</p><p>Color Theme Editor for Visual Studio 2019</p><p>路径：【工具】-&gt;【扩展和更新】-&gt;【联机】</p><h1 id="2-设置："><a href="#2-设置：" class="headerlink" title="2.设置："></a>2.设置：</h1><p>【工具】-&gt;【选项】-&gt;【ClaudiaIDE】</p><p>然后可以设置图片背景。</p><p>记得把Expand to IED该为true。</p><p>【工具】-&gt;【选项】-&gt;【字体和颜色】</p><p>可以更换好看的字体。</p><p>自定义主题：</p><p>【工具】-&gt;【Customsize Colors】</p><p>进去，Dark</p><p><img src="https://img-blog.csdnimg.cn/20190821150418840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击那个Creat Copy of Theme</p><p><img src="https://img-blog.csdnimg.cn/20190821150529386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后选择“Show All Elements”</p><p>把下面这些的Color改为：<strong>2A252526</strong></p><p>Ctrl+F可以搜索。</p><p><img src="https://img-blog.csdnimg.cn/20190821150730349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后，点保存就可以了。</p><p>上张图：</p><p><img src="https://img-blog.csdnimg.cn/20190821151012842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><a href="https://blog.csdn.net/easylovecsdn/article/details/86601309">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode设置个性化背景教程</title>
      <link href="2020/05/15/software/2020/vscode-she-zhi-ge-xing-hua-bei-jing-jiao-cheng/"/>
      <url>2020/05/15/software/2020/vscode-she-zhi-ge-xing-hua-bei-jing-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>Vscode都配置好了，接下来设置一个有趣的个性化背景。</p><p>如果没有安装好C++编译环境可以参考：<a href="https://blog.csdn.net/qq_43826212/article/details/99955837">Visual Studio Code配置C/C++环境(win10)</a></p><h2 id="1-搜索插件background"><a href="#1-搜索插件background" class="headerlink" title="1.搜索插件background"></a>1.搜索插件background</h2><p>安装好了以后会出现插件破损的提示，别理，设置为不再提醒。</p><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>打开全局配置，添加如下内容：</p><pre class=" language-lang-json"><code class="language-lang-json">"background.enabled": true,"background.useDefault": false,//是否使用默认图片"background.customImages": [    "file://D:/2345Downloads/png/Live.png",    "file://D:/2345Downloads/png/Live2D1.png",    "file://D:/2345Downloads/png/Live2D2.png",    //"file://D:/2345Downloads/png/1.jpg",//图片路径],"background.style": {    "content": "''",    "pointer-events": "none",    "position": "absolute",    "z-index": "99999",    "width": "100%",    "height": "100%",    "background-position": "100% 100%",    "background-repeat": "no-repeat",    "opacity": 0.35}</code></pre><p>然后就好了。上张图：</p><p><img src="https://img-blog.csdnimg.cn/2019082114544836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio Code配置C/C++环境(win10)</title>
      <link href="2020/05/15/software/2020/visual-studio-code-pei-zhi-cc-huan-jing/"/>
      <url>2020/05/15/software/2020/visual-studio-code-pei-zhi-cc-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="Ⅰ-安装编辑器Vscode"><a href="#Ⅰ-安装编辑器Vscode" class="headerlink" title="Ⅰ. 安装编辑器Vscode"></a>Ⅰ. 安装编辑器Vscode</h2><p><a href="https://code.visualstudio.com/download">vscode</a> 选择适合自己系统的版本。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018153821432.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018153855021.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018153922249.png" alt=""></p><h2 id="Ⅱ-安装编译器mingw64"><a href="#Ⅱ-安装编译器mingw64" class="headerlink" title="Ⅱ. 安装编译器mingw64"></a>Ⅱ. 安装编译器mingw64</h2><p>在 <strong>windows</strong> 下安装 <strong>mingw64</strong> 编译器有点麻烦，不过，我都准备好了，直接下载直接使用就好了。</p><p>链接: <a href="https://pan.baidu.com/s/1-MhgLjwG0xHtFtyNy-M_Fg">https://pan.baidu.com/s/1-MhgLjwG0xHtFtyNy-M_Fg</a> </p><p>提取码: 3ia5</p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018155124641.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018155200209.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018155353309.png" alt=""></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018155507888.png" alt=""></p><p>如图，点击新建，把 <code>mingw64</code> 的 <code>bin</code> 文件夹添加到 <code>path</code> 确定退出。</p><h3 id="查看环境变量是否添加成功"><a href="#查看环境变量是否添加成功" class="headerlink" title="查看环境变量是否添加成功"></a>查看环境变量是否添加成功</h3><p><code>win + r</code> 输入 <code>cmd</code></p><p>再输入 <code>g++ -v</code> </p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018155650825.png" alt=""></p><p>如果出现这个就是成功了。</p><h2 id="Ⅲ-给vscode添加插件"><a href="#Ⅲ-给vscode添加插件" class="headerlink" title="Ⅲ. 给vscode添加插件"></a>Ⅲ. 给vscode添加插件</h2><p>这步的主要目的是方便代码运行和提高编写代码效率~</p><p>快捷键 <code>Ctrl + Shift + X</code></p><p>或者鼠标点击下图红色框框</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018153725271.png" alt=""></p><p>上图是笔者在 <code>C/C++</code> 环境下使用的插件，具体作用可以百度，也可以查看官方文档。</p><h2 id="Ⅳ-配置vscode调试环境"><a href="#Ⅳ-配置vscode调试环境" class="headerlink" title="Ⅳ. 配置vscode调试环境"></a>Ⅳ. 配置vscode调试环境</h2><p>完成了前三步，跑代码是没问题的了，但是需要 <code>debug</code> 的同学看过来🙋‍</p><p>为了使 <code>vscode</code> 能够顺利进行 <code>debug</code> 我们还需要添加一些配置信息。</p><h3 id="创建开发工作区："><a href="#创建开发工作区：" class="headerlink" title="创建开发工作区："></a>创建开发工作区：</h3><p>创建一个代码工作区。</p><blockquote><p>工作区所在路径仅由字母、数字、下划线组成，不要包含其他的符号；</p><p>绝对不能有中文，中文路径调试时会报错的。</p></blockquote><p>点击 <code>vscode</code> 左上角的 <code>file</code> 打开文件夹。</p><h3 id="添加配置信息"><a href="#添加配置信息" class="headerlink" title="添加配置信息"></a>添加配置信息</h3><p>在工作区的文件夹建立一个 <code>.vscode</code> 文件夹。</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018160620665.png" alt=""></p><p><code>.vscode</code> 文件夹包含如下内容：</p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018160729324.png" alt=""></p><p>特别注意：下面所有出现 <code>mingw64</code> 的地方都要改成你电脑 <code>mingw64</code> 的目录。</p><p><code>c_cpp_properties.json</code> 内容：</p><pre class=" language-lang-json"><code class="language-lang-json">{  "configurations": [    {      "name": "Win64",      "includePath": [        "${workspaceFolder}/**"      ],      "defines": [        "_DEBUG",        "UNICODE",        "_UNICODE"      ],      "compilerPath": "E:\\mingw64\\bin\\gcc.exe",      "cStandard": "c11",      "cppStandard": "gnu++20",      "intelliSenseMode": "gcc-x64"    }  ],  "version": 4}</code></pre><p><code>launch.json</code> 内容：</p><pre class=" language-lang-json"><code class="language-lang-json">{  "version": "0.2.0",  "configurations": [    {      "name": "g++.exe build and debug active file",      "type": "cppdbg",      "request": "launch",      "program": "${fileDirname}\\${fileBasenameNoExtension}.exe",      "args": [],      "stopAtEntry": false,      "cwd": "${workspaceFolder}",      "environment": [],      "externalConsole": false,      "MIMode": "gdb",      "miDebuggerPath": "E:\\mingw64\\bin\\gdb.exe",      "setupCommands": [        {          "description": "Enable pretty-printing for gdb",          "text": "-enable-pretty-printing",          "ignoreFailures": true        }      ],      "preLaunchTask": "g++.exe build active file"    }  ]}</code></pre><p><code>tasks.json</code> 内容：</p><pre class=" language-lang-json"><code class="language-lang-json">{  "version": "2.0.0",  "tasks": [    {      "type": "shell",      "label": "g++.exe build active file",      "command": "E:\\mingw64\\bin\\g++.exe",      "args": [        "-g",        "-Wall",        "-fexec-charset=GBK",        "-std=c++17",        "${file}",        "-o",        "${fileDirname}\\${fileBasenameNoExtension}.exe"      ],      "options": {        "cwd": "E:\\mingw64\\bin"      },      "problemMatcher": [        "$gcc"      ],      "group": {        "kind": "build",        "isDefault": true      }    }  ]}</code></pre><p>参考：<a href="https://code.visualstudio.com/docs/cpp/config-mingw">GCC on Windows</a></p><h2 id="Ⅴ-编写第一个程序："><a href="#Ⅴ-编写第一个程序：" class="headerlink" title="Ⅴ. 编写第一个程序："></a>Ⅴ. 编写第一个程序：</h2><pre><code>#include &lt;stdio.h&gt;int main() {  printf("Helo World\n");  return 0;}</code></pre><p>点击右边的三角形符号，可以运行代码，或者直接用快捷键 <code>ctrl + alt + n</code></p><p> 设置断点，点击工具栏运行，进行调试即可。</p><p>再次强调一遍，上面的三个配置文件出现了 <code>mingw64</code> 的路径，都要改成你电脑实际的路径。</p><h2 id="Ⅵ-进阶"><a href="#Ⅵ-进阶" class="headerlink" title="Ⅵ. 进阶"></a>Ⅵ. 进阶</h2><p>我们可以通过对 <code>vscode</code> 进行全局配置，实现我们想要的配置，也可以进行局部配置，但推荐全局配置。</p><p><code>File-&gt;preferences-&gt;settings</code> 快捷键 <code>ctrl +,</code></p><p><img src="https://gitee.com/incipe-win/images/raw/master/image-20201018161950419.png" alt=""></p><p>点击这个图标就打开了 <code>vscode</code> 的全局配置区域。</p><p>笔者配置如下：</p><pre class=" language-lang-json"><code class="language-lang-json">{  "code-runner.executorMap": {    "c": "cd $dir && gcc $fileName -Wall -fexec-charset=GBK -o $fileNameWithoutExt && $dir$fileNameWithoutExt",    "cpp": "cd $dir && g++ $fileName -Wall -std=c++2a -fexec-charset=GBK -o $fileNameWithoutExt && $dir$fileNameWithoutExt",    "cc": "cd $dir && g++ $fileName -Wall -std=c++2a -fexec-charset=GBK -o $fileNameWithoutExt && $dir$fileNameWithoutExt",  },  "editor.cursorStyle": "line",  "editor.mouseWheelZoom": true,  "editor.formatOnSave": true,  "files.autoSave": "onFocusChange",  "editor.fontFamily": "Consolas",  "editor.fontLigatures": true,  "editor.fontSize": 15,  "editor.lineHeight": 19,  "editor.lineNumbers": "on",  "editor.minimap.enabled": true,  "editor.renderIndentGuides": false,  "editor.rulers": [    120  ],  "editor.fontWeight": "normal",  "terminal.integrated.fontFamily": "Consolas",  "editor.formatOnPaste": false,  "editor.suggestFontSize": 0,  "editor.wordWrap": "on",  "editor.tabSize": 2,  "code-runner.runInTerminal": true,  "workbench.colorCustomizations": {    "editor.selectionBackground": "#aa0000"  },  "workbench.iconTheme": "vscode-icons",  "files.autoGuessEncoding": true,  "files.autoSaveDelay": 100,  "task.autoDetect": "off",  "code-runner.ignoreSelection": true,  "code-runner.saveFileBeforeRun": true,  "code-runner.preserveFocus": false,  "editor.tabCompletion": "on",  "editor.suggestSelection": "first",  "C_Cpp.intelliSenseEngine": "Default",  "C_Cpp.errorSquiggles": "Enabled",  "C_Cpp.clang_format_sortIncludes": true,  "terminal.integrated.rendererType": "dom",  "C_Cpp.default.cStandard": "c99",  "C_Cpp.default.intelliSenseMode": "gcc-x64",  "C_Cpp.clang_format_style": "Google",  "workbench.sideBar.location": "right",  "C_Cpp.clang_format_fallbackStyle": "Google",  "editor.detectIndentation": false,  "[c]": {    "editor.defaultFormatter": "ms-vscode.cpptools"  },  "[cpp]": {    "editor.defaultFormatter": "ms-vscode.cpptools"  },  "vim.useSystemClipboard": true,  "explorer.confirmDelete": false,  "markdown.preview.breaks": true,  "markdown.preview.fontFamily": "Fira Code",  "editor.tokenColorCustomizations": {    "comments": "#82e0aa", // 注释    "keywords": "#0a0", // 关键字    "variables": "#f00", // 变量名    "strings": "#e2d75dbd", // 字符串    "functions": "#5b99fcc9", // 函数名    "numbers": "#AE81FF", // 数字    "textMateRules": [      {        "name": "italic font",        "scope": [          "comment",          "keyword",          "storage",          "keyword.control",          "keyword.control.from",          "keyword.control.flow",          "keyword.operator.new",          "keyword.control.import",          "keyword.control.export",          "keyword.control.default",          "keyword.control.trycatch",          "keyword.control.conditional",          "storage.type",          "storage.type.class",          "storage.modifier.tsx",          "storage.type.function",          "storage.modifier.async",          "variable.language",          "variable.language.this",          "variable.language.super",          "meta.class",          "meta.var.expr",          "constant.language.null",          "support.type.primitive",          "entity.name.method.js",          "entity.other.attribute-name",          "punctuation.definition.comment",          "text.html.basic entity.other.attribute-name",          "tag.decorator.js entity.name.tag.js",          "tag.decorator.js punctuation.definition.tag.js",          "source.js constant.other.object.key.js string.unquoted.label.js",        ],        "settings": {          "fontStyle": "italic",        }      },    ]  },  "workbench.colorTheme": "One Dark Pro",  "explorer.confirmDragAndDrop": false,}</code></pre><p>具体某一句的功能就不解释了，需要知道的把鼠标放到相应行，就会有提示的。</p><h2 id="Ⅶ-总结"><a href="#Ⅶ-总结" class="headerlink" title="Ⅶ. 总结"></a>Ⅶ. 总结</h2><p>使用 <code>vscode</code> 一年多了，越用越爽，特别是 <code>wsl2</code> 出来后，在 <code>win</code> 上进行 <code>linux</code> 开发还是非常方便的。</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keil简单实用</title>
      <link href="2020/05/15/software/2020/keil-jian-dan-shi-yong/"/>
      <url>2020/05/15/software/2020/keil-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>注：本文适合绝对0基础，如果有一定的基础，可以移步。</p><h3 id="一-keil简单介绍"><a href="#一-keil简单介绍" class="headerlink" title="一. keil简单介绍"></a>一. keil简单介绍</h3><p><strong>Keil</strong> 提供了包括C<a href="https://baike.baidu.com/item/编译器/8853067">编译器</a>、宏汇编、链接器、库管理和一个功能强大的仿真调试器等在内的完整开发方案，通过一个<a href="https://baike.baidu.com/item/集成开发环境/298524">集成开发环境</a>（μVision）将这些部分组合在一起。</p><p>更多请戳 <a href="https://baike.baidu.com/item/Keil">百度百科</a></p><h3 id="二-安装"><a href="#二-安装" class="headerlink" title="二. 安装"></a>二. 安装</h3><p><a href="https://www.keil.com/download/product/">Download Products</a></p><p><img src="https://imgkr.cn-bj.ufileos.com/57af1f52-e355-42a6-b6cd-5bfce14aacac.png" alt="keil产品"></p><p><strong>MDK-Arm(Microcontroller Development Kit)</strong> </p><ul><li><strong>MDK</strong> 的设备数据库中有很多厂商的芯片，是专为微控制器开发的工具，为满足基于 <strong>MCU</strong> 进行嵌入式软件开发的工程师需求而设计，支持 <strong>ARM7，ARM9，Cortex-M4/M3/M1，Cortex-R0/R3/R4</strong> 等 <strong>ARM</strong> 微控制器内核。</li></ul><p><strong>C51</strong></p><ul><li><strong>KEIL</strong> 公司开发的基于 <strong>uVision IDE</strong> ，支持绝大部分8051内核的微控制器开发工具。</li></ul><p><strong>C251</strong></p><ul><li><strong>KEIL</strong> 公司开发的基于 <strong>uVision IDE</strong> ，支持绝大部分基于251核的微控制器的开发工具。</li></ul><p><strong>C166</strong></p><ul><li><strong>KEIL</strong> 公司开发的基于 <strong>uVision IDE</strong> ，支持绝大部分 <strong>XC16x，C16x</strong> 和 <strong>ST10</strong> 系列的微控制器开发工具。</li></ul><p><a href="https://www.mr-wu.cn/keil-mdk-uvision-5-crack/">破解移步</a></p><h3 id="三-使用教程"><a href="#三-使用教程" class="headerlink" title="三. 使用教程"></a>三. 使用教程</h3><h4 id="1-建立文件"><a href="#1-建立文件" class="headerlink" title="1. 建立文件"></a>1. 建立文件</h4><p>在你找的找的到的任何地方建立一个新的文件夹，专门用来保存 <strong>keil</strong> 工程文件。比如 <strong>D://MCU/</strong> </p><h4 id="2-建立工程文件"><a href="#2-建立工程文件" class="headerlink" title="2. 建立工程文件"></a>2. 建立工程文件</h4><p>在 <strong>MCU</strong> 文件里建立再建立一个文件夹，作为 <strong>keil</strong> 工程文件，比如 <strong>D://MCU/experiment1/</strong> </p><h4 id="3-建立工程"><a href="#3-建立工程" class="headerlink" title="3. 建立工程"></a>3. 建立工程</h4><p>打开桌面的 <strong>keil uVision</strong> </p><p><img src="https://imgkr.cn-bj.ufileos.com/b179aa98-23ab-40f0-9ef0-30c73bfccb81.png" alt=""></p><ol><li>点击工具栏的 <strong>Project</strong> ，选择 <strong>New uVision Project</strong> </li></ol><p><img src="https://imgkr.cn-bj.ufileos.com/261b2a09-c4a6-4d6a-8246-7cc46b584159.png" alt=""></p><p>定位到刚刚建立的文件夹下面 <strong>D://MCU/experiment</strong> </p><p><img src="https://imgkr.cn-bj.ufileos.com/e4c294eb-7574-4da2-aebf-c2f5bf06b896.png" alt=""></p><p>①是当前路径，我们在②处填上我们要建立的 <strong>keil</strong> 工程名字： <strong>experiment1</strong>，点击③保存。</p><p><img src="https://imgkr.cn-bj.ufileos.com/8f7ea78e-1052-45c2-8e34-691017023f79.png" alt=""></p><p>选择 <strong>Atmel</strong> ，点击前面的 <strong>+</strong> 号。</p><p><img src="https://imgkr.cn-bj.ufileos.com/341976cb-3aa3-4803-84b3-3002c56bd33d.png" alt=""></p><p>找到 <strong>AT89C51</strong> 点击②， <strong>OK</strong>。</p><p>有可能会出来一个弹窗，点否就行了。</p><h4 id="4-建立源文件"><a href="#4-建立源文件" class="headerlink" title="4. 建立源文件"></a>4. 建立源文件</h4><p>找到刚刚建立的 <strong>D://MCU/experiment</strong> </p><p>右键，建立文本文档，双击改名字，记得打开文件后缀名。</p><p><img src="https://imgkr.cn-bj.ufileos.com/dd735005-111b-49dd-bb46-a5f39e35afb5.png" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/442d0677-9881-4717-9721-70c42e9b38a0.png" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/408eaf89-6d6a-4037-8b4a-a9aed83c564a.png" alt=""></p><p>最后得到 <strong>C</strong> 语言源文件。</p><p><img src="https://imgkr.cn-bj.ufileos.com/02dc2064-83a9-4ca7-8dd8-4ee740d5a00c.png" alt=""></p><h4 id="5-添加源文件"><a href="#5-添加源文件" class="headerlink" title="5. 添加源文件"></a>5. 添加源文件</h4><p>打开 <strong>keil uVision</strong> </p><p><img src="https://imgkr.cn-bj.ufileos.com/eebdad8b-6833-4cbf-8e4c-930ffa85d663.png" alt=""></p><p>右键，<strong>Source Group 1</strong> ，选择刚刚的 <strong>C语言</strong> 源文件。</p><p><img src="https://imgkr.cn-bj.ufileos.com/3fe06aea-5390-4e75-86ae-4e934835a4e2.png" alt=""></p><p>点击②添加，③关闭。</p><p>这时 <strong>Source Group 1</strong> 多了个 <strong>+</strong> </p><p><img src="https://imgkr.cn-bj.ufileos.com/55a4d50d-5345-47c0-a2f4-d8219db2f540.png" alt=""></p><p>展开，双击源文件，就可以编写源文件了。</p><h4 id="6-生成hex二进制文件"><a href="#6-生成hex二进制文件" class="headerlink" title="6. 生成hex二进制文件"></a>6. 生成hex二进制文件</h4><p>编写好源文件后，右键 <strong>Target 1</strong> ，选择图中的 <strong>Options for Target 1…</strong> 。</p><p><img src="https://imgkr.cn-bj.ufileos.com/cc69eddb-5bf6-4b1c-bf71-72023d406c9c.png" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/0d87fc0e-4b36-4ac0-ab07-6ba60081f184.png" alt=""></p><p>选择 <strong>Output</strong> ，把 <strong>Create HEX File</strong> 打上 <strong><em>√</em></strong> ，默认是没有 <strong><em>√</em></strong> 的。然后点击OK，即可。</p><h4 id="7-编译文件"><a href="#7-编译文件" class="headerlink" title="7. 编译文件"></a>7. 编译文件</h4><p>找到工具栏</p><p><img src="https://imgkr.cn-bj.ufileos.com/4965f55a-de21-4360-a129-d07a6d6bab7a.png" alt=""></p><p>①是转换和编译按钮，一般通过①的第一个按钮检查自己的代码有没有错，第二个按钮生成HEX文件。</p><p>②是调试按钮，设置好段点后，就可以对代码进行调试了。</p><h4 id="8-检查是否生成HEX文件"><a href="#8-检查是否生成HEX文件" class="headerlink" title="8. 检查是否生成HEX文件"></a>8. 检查是否生成HEX文件</h4><p>如果代码没有报错。</p><p><img src="https://imgkr.cn-bj.ufileos.com/98fc074e-6583-4558-b7c6-5d18ecffa5be.png" alt=""></p><p>打开建立的文件 <strong>D://MCU/experiment/</strong> 这是我们会看到该目录下有个 <strong>experiment.hex</strong> 文件。</p><p>在 <strong>ISIS</strong> 中双击 <strong>AT89C51</strong> 芯片，找到这个 <strong>experiment.hex</strong> 文件，即可进行仿真了。</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h3><p>多练习，熟能生巧，不熟悉就谈不上进步。</p><h3 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h3><blockquote><center>浣溪沙</center><center>晏殊</center><center>一曲新词酒一杯，去年天气旧亭台。夕阳西下几时回？</center><center>无可奈何花落去，似曾相识燕归来。小园香径独徘徊。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mingw-w64安装</title>
      <link href="2020/05/15/software/2020/mingw-w64-an-zhuang/"/>
      <url>2020/05/15/software/2020/mingw-w64-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="Ⅰ-离线安装"><a href="#Ⅰ-离线安装" class="headerlink" title="Ⅰ. 离线安装"></a>Ⅰ. 离线安装</h2><p>如果在线安装的话，可能不会成功。</p><p>可以直接去 <a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/sjlj/x86_64-8.1.0-release-posix-sjlj-rt_v6-rev0.7z/download">sourcegorge</a> 下载离线包</p><p>也可以用百度网盘下载：</p><p>链接: <a href="https://pan.baidu.com/s/1-MhgLjwG0xHtFtyNy-M_Fg">https://pan.baidu.com/s/1-MhgLjwG0xHtFtyNy-M_Fg</a></p><p>提取码: 3ia5</p><p><strong>安装好后解压，添加环境变量即可。怎么添加环境变量下面的方法有介绍！</strong></p><h2 id="Ⅱ-通过msys2安装"><a href="#Ⅱ-通过msys2安装" class="headerlink" title="Ⅱ. 通过msys2安装"></a>Ⅱ. 通过msys2安装</h2><p>这里讲下具体讲下用 <code>msys2</code>安装 <code>mingw64</code></p><p>首先安装 <code>msys2</code>，可以去 <a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/">开源镜像站</a> 下载 。</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>安装好后，还是先换源吧，不然太慢了。</p><p>换源网上很多教程，我这里简单讲下：</p><p>找到 <code>\msys64\etc\pacman.d</code>（安装目录下的）：</p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20190820101545412.png" alt="在这里插入图片描述"></p><p>对于 <code>mirrorlist.msys</code>，贴上如下内容：</p><pre class=" language-lang-bash"><code class="language-lang-bash">#### MSYS2 repository mirrorlist#### Primary## msys2.orgServer = http://mirrors.ustc.edu.cn/msys2/msys/$arch/Server = http://repo.msys2.org/msys/$archServer = http://downloads.sourceforge.net/project/msys2/REPOS/MSYS2/$archServer = http://www2.futureware.at/~nickoe/msys2-mirror/msys/$arch/</code></pre><p><code>mirrorlist.mingw64</code></p><pre><code>#### 64-bit Mingw-w64 repository mirrorlist#### Primary## msys2.orgServer = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/Server = http://repo.msys2.org/mingw/x86_64Server = http://downloads.sourceforge.net/project/msys2/REPOS/MINGW/x86_64Server = http://www2.futureware.at/~nickoe/msys2-mirror/x86_64/Server = http://mirror.bit.edu.cn/msys2/REPOS/</code></pre><p><code>mirrorlist.mingw32</code></p><pre class=" language-lang-bash"><code class="language-lang-bash">#### 32-bit Mingw-w64 repository mirrorlist#### Primary## msys2.orgServer = http://mirrors.ustc.edu.cn/msys2/mingw/i686/Server = http://repo.msys2.org/mingw/i686Server = http://downloads.sourceforge.net/project/msys2/REPOS/MINGW/i686Server = http://www2.futureware.at/~nickoe/msys2-mirror/i686/</code></pre><h3 id="安装mingw64"><a href="#安装mingw64" class="headerlink" title="安装mingw64"></a>安装mingw64</h3><p><code>msys2</code> 是依赖 <code>pacman</code>的。</p><p>1.更新 <code>msys2</code> 的系统环境：</p><pre class=" language-lang-bash"><code class="language-lang-bash">pacman -Sy#更新源pacman -Syupacman -Su</code></pre><p>安装 <code>MinGW-w64</code> 和 <code>MinGW-x86</code> 版本：</p><p>一个是64位，另一个是32位。</p><p>简单讲下，<code>x86，i686</code> 是32位的，<code>x86，x86_64</code> 是64位的。</p><pre class=" language-lang-bash"><code class="language-lang-bash">pacman -S  mingw-w64-i686-toolchainpacman -S  mingw-w64-x86_64-toolchain</code></pre><p>其它有需求者自装。</p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>为 <code>mingw-w64</code> 添加环境变量：</p><p>安装成功后，在你的 <code>msys2</code> 的安装路径下会有 <code>mingw64</code> 文件夹的。</p><p>进去找到bin文件夹，复制整个bin文件夹的目录：<code>D:\msys64\mingw64\bin</code></p><p>找到我的电脑（此电脑），右键属性：</p><p><img src="https://img-blog.csdnimg.cn/20190820103721186.png" alt="在这里插入图片描述"></p><p>点击高级系统设置：</p><p><img src="https://img-blog.csdnimg.cn/20190820103800170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击环境变量，进去之后发现有个用户的变量，还有一个系统变量，简单讲就是：<strong>系统环境变量，对所有用户起作用,而用户环境变量只对当前用户起作用。</strong> </p><p>一般添加系统环境变量，找到 <code>Path</code>，新建，把刚刚复制的路径粘贴进去就好了。</p><p>然后检查是否成功，<code>win+r</code>，输入 <code>cmd</code>，键入 <code>g++ -v</code></p><p><img src="https://img-blog.csdnimg.cn/20190820104430821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如上显示就是成功了。</p><p>如果是直接安装的 <code>mingw64</code></p><p>则是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20191215173208208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="安装gdb调试器"><a href="#安装gdb调试器" class="headerlink" title="安装gdb调试器"></a>安装gdb调试器</h3><p>一般用 <code>msys2</code> 安装的 <code>mingw64</code> 不带 <code>gdb</code></p><p>用<code>pacman -S gdb</code>就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同时推送代码至github和gitee</title>
      <link href="2020/05/15/software/2020/tong-shi-tui-song-dai-ma-zhi-github-he-gitee/"/>
      <url>2020/05/15/software/2020/tong-shi-tui-song-dai-ma-zhi-github-he-gitee/</url>
      
        <content type="html"><![CDATA[<p>1.注册github和gitee账号</p><p>这就不说了，很简单，然后创建仓库。github仓库的英文名是：Repository 。</p><p>2.下载git</p><p>git是分布式版本控制系统，官网下载地址：</p><p>选择版本下载安装，安装的时候没特别需求一路next就好了。</p><p>3.获取公钥</p><p>鼠标右键，选择Git Bash here，输入<code>ssh-keygen -t rsa -C “邮箱”</code></p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20190822203737221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我的已经安装好了，遇到停顿一路回车就好了。</p><p>产生的公钥在C:/用户(user)/admin(每个电脑不一样的相当于电脑的username)/.ssh/id_rsa.pub</p><p>复制下来.。</p><p>或者直接用<code>cat ~/.ssh/id_rsa.pub</code>查看。</p><p>可用<code>ssh -T git@github.com</code>查看是否成功生成公钥。</p><p>4.上传公钥</p><p><img src="https://img-blog.csdnimg.cn/20190822204532424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击右上角的头像，点击settings</p><p><img src="https://img-blog.csdnimg.cn/20190822204712208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击SSH and GPG keys</p><p>添加SSH keys，不需要添加GPG keys</p><p><img src="https://img-blog.csdnimg.cn/20190822205007546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如图即可。</p><p>gitee一样的步骤。</p><p>5.绑定用户名跟邮箱</p><p>在git界面输入：</p><pre class=" language-lang-bash"><code class="language-lang-bash">git config --global user.name "github的用户名"git config --global user.email "绑定github的邮箱"</code></pre><p>到了这一步就差不多了。</p><p>新建一个文件夹，专门用来传代码。</p><p>右键该文件夹。</p><p>选择Git Bash here</p><p>初始化，同步该文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">git initgit remote add origin 仓库地址（如下图）git pull origin master</code></pre><p><img src="https://img-blog.csdnimg.cn/20190822210452256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后现在就可以上传代码到github上面了。</p><pre class=" language-lang-bash"><code class="language-lang-bash">git add . git commit -m "理由"git push origin master</code></pre><p>要修改，只需要在本地进行修改，再同步即可，当然也有其他方法。</p><p>6.同时推送代码至github和gitee</p><p>找到刚刚新建的文件夹，打开显示隐藏项目，会看到<code>.git</code>的文件夹</p><p>右键<code>.git</code>文件夹，Git Bash here</p><p>输入<code>vim config</code></p><p>接下来你进入的是vim编辑器，号称编辑器之神。</p><p>这里不讲怎么使用。点击<code>i/a/o</code>j进入插入模式</p><p>增加如下内容</p><pre class=" language-lang-bash"><code class="language-lang-bash">[remote "gitee"]    url = 你的gitee项目地址    fetch = +refs/heads/*:refs/remotes/gitee/*[branch "master"]    remote = gitee    merge = fefs/heads/master</code></pre><p>可以看到前面已经有内容了，那是上传到github的配置。</p><p>然后按ESC键，多按几次没事的，按<code>Shift+:wq</code></p><p>vim编辑器会在最下面一行显示如下内容，按Enter就可以了</p><p><img src="https://img-blog.csdnimg.cn/20190822211814756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最后就可以上传代码了。</p><pre class=" language-lang-bash"><code class="language-lang-bash">git add .git commit -m "理由"</code></pre><p>上传至github</p><pre class=" language-lang-bash"><code class="language-lang-bash">git origin origin master</code></pre><p>上传至gitee</p><pre class=" language-lang-bash"><code class="language-lang-bash">git push gitee master</code></pre><p>然后就可以享受代码托管，开源的乐趣了。</p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装BurpSuite_Pro</title>
      <link href="2020/05/15/software/2020/an-zhuang-burpsuite-pro/"/>
      <url>2020/05/15/software/2020/an-zhuang-burpsuite-pro/</url>
      
        <content type="html"><![CDATA[<p><strong>如果是jdk最新版的环境，建议用用BurpSuiteV1.6破解版，授权日期到2099-12-3。</strong></p><p><a href="https://pan.baidu.com/s/1yDFoMd9gGcfMpo6xWcYmhA">下载地址</a></p><p>提取码：q6yd </p><p>否则，请参考以下步骤安装最新版burp！</p><p>首先安装java环境，还要有jre（ <strong>很重要</strong> ）</p><p>下载burp-loader-keygen-2_1_05资源</p><p>链接：<a href="https://pan.baidu.com/s/13hzi9RjRi74lxYw5jlpE4g">传送门</a> </p><p>提取码：gots</p><p>如果双击打不开jar文件，找到注册表</p><p><strong>计算机\HKEY_CLASSES_ROOT\Applications\javaw.exe\shell\open\command</strong></p><p>修改文件，改成如下（加个-jar即可，注意前后要有空格）</p><p><img src="https://img-blog.csdnimg.cn/20191130115335952.png" alt="在这里插入图片描述"></p><p>然后选择打开默认方式为javaw.exe就好了。</p><p>这个文件在jdk的bin文件夹内！</p><p>比如： <strong>D:\Java\jdk-13\bin</strong> </p><p>弄好了之后，会发现打开 <strong>burp-loader-keygen-2_1_05.jar</strong> 后点击 <strong>run</strong> 没用的情况，我们把 <strong>burp-loader-keygen-2_1_05.jar</strong> 的命令拷贝下来，打开cmd，输入该命令即可！</p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20191130115804433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后根据以下步骤：</p><p><img src="https://img-blog.csdnimg.cn/20191130120008375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191130120031276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191130120041703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt=""></p><p>完美解决！</p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美解决wamp的MySQL和MySQL冲突问题及wamp无法打开localhost问题</title>
      <link href="2020/05/15/software/2020/wan-mei-jie-jue-wamp-de-mysql-he-mysql-chong-tu-wen-ti-ji-wamp-wu-fa-da-kai-localhost-wen-ti/"/>
      <url>2020/05/15/software/2020/wan-mei-jie-jue-wamp-de-mysql-he-mysql-chong-tu-wen-ti-ji-wamp-wu-fa-da-kai-localhost-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>当我们使用wamp时，如果系统之前已经安装了MySQL，会发现wamp的MySQL和原来的MySQL只有一个可以使用，原因就是因为端口冲突。可能还会经常遇到的一个问题，就是安装了wamp后无法打开localhost，原因也是因为端口冲突。下面这篇文章将带大家解决这两个问题。</p><h1 id="解决MySQL端口冲突问题"><a href="#解决MySQL端口冲突问题" class="headerlink" title="解决MySQL端口冲突问题"></a>解决MySQL端口冲突问题</h1><p>我们需要修改则两个文件。</p><p>路径：</p><blockquote><p>D:\wamp64\bin\mysql\mysql5.7.26\my.ini<br>D:\wamp64\apps\phpmyadmin4.8.5\config.inc.php</p></blockquote><h2 id="打开my-ini"><a href="#打开my-ini" class="headerlink" title="打开my.ini"></a>打开my.ini</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">[client];password = your_passwordport = 8081socket = /tmp/mysql.sock; Here follows entries for some specific programs; The MySQL server[wampmysqld64];skip-grant-tablesdefault_authentication_plugin=mysql_native_passwordport = 8081socket = /tmp/mysql.sockkey_buffer_size = 256Mmax_allowed_packet = 1M...及最后一部分[mysqld]default_authentication_plugin=mysql_native_passwordport = 8081</code></pre><p>把以上的port = 后的端口号改为自己想要的即可(我这里改为了8081，原先是3306的)。</p><h2 id="打开config-inc-php"><a href="#打开config-inc-php" class="headerlink" title="打开config.inc.php"></a>打开config.inc.php</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">if($mariaFirst) $i++;    $cfg['Servers'][$i]['verbose'] = 'MySQL';    $cfg['Servers'][$i]['host'] = 'localhost';    $cfg['Servers'][$i]['port'] = '8081';            //这里改为你的端口号    $cfg['Servers'][$i]['extension'] = 'mysqli';    $cfg['Servers'][$i]['auth_type'] = 'cookie';    $cfg['Servers'][$i]['user'] = 'root';    $cfg['Servers'][$i]['password'] = '这里填写你的MySQL密码';</code></pre><p>保存退出，重启就好了。<br><strong>（控制台设置wamp的MySQL密码时，如果输入【update user set password=PASSWORD(‘root’) where user=’root’;】报错【ERROR 1054 (42S22): Unknown column ‘password’ in ‘field list’】命令改为update mysql.user set authentication_string=password(‘root’) where user=’root’；即可解决问题<br>）</strong> </p><h1 id="解决localhost无法打开问题"><a href="#解决localhost无法打开问题" class="headerlink" title="解决localhost无法打开问题"></a>解决localhost无法打开问题</h1><p>找到几个文件</p><blockquote><p>D:\wamp64\bin\apache\apache2.4.39\conf\httpd.conf<br>D:\wamp64\wampmanager.tpl</p></blockquote><h2 id="打开httpd-conf"><a href="#打开httpd-conf" class="headerlink" title="打开httpd.conf"></a>打开httpd.conf</h2><p>Ctrl + F 搜索80</p><p>修改这几个部分</p><p><img src="https://img-blog.csdnimg.cn/20191125124240273.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191125124320776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>改为自己想要的即可(我这里改成了8080)</p><h2 id="打开wampmanager-tpl"><a href="#打开wampmanager-tpl" class="headerlink" title="打开wampmanager.tpl"></a>打开wampmanager.tpl</h2><p>Ctrl + F 搜索80，修改这几处地方即可</p><p><img src="https://img-blog.csdnimg.cn/20191125124703709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191125124737763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>改成跟httpd.conf中一样的端口即可！</p><p>保存重启即可！</p><p><strong>注意：此时访问localhost需要加上端口号，因为以前默认的时80，现在改成了8080，及localhost:端口号</strong></p><p>如果wamp的图标显示绿色，那么说明wamp的所有服务全部开启了。如果是红色或者橙色，说明有服务没开启！</p><p><img src="https://img-blog.csdnimg.cn/20191125125346871.png" alt="在这里插入图片描述"></p><p>才疏学浅，望雅正！</p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Fiddler构造http请求</title>
      <link href="2020/05/15/software/2020/yong-fiddler-gou-zao-http-qing-qiu/"/>
      <url>2020/05/15/software/2020/yong-fiddler-gou-zao-http-qing-qiu/</url>
      
        <content type="html"><![CDATA[<p>用Fiddler构造http请求时，发现 $_POST数组中怎么也获取不到值，以为自己操作错了，但也没发现什么问题，后来得知，原来缺少了一个请求头，Fiddler不会为我们自动添加。</p><pre><code>Content-Type: application/x-www-form-urlencoded</code></pre><p>下面以bugku的web基础$_POST30为列子进行分析！</p><p><img src="https://img-blog.csdnimg.cn/20191128111600242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191128111642839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>看到是post请求，就想到构造http的post请求取得flag</p><p>打开Fiddler</p><p>在composer的options勾选Fix Content-Length header</p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/201911281122538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在composer的请求头添加一行</p><pre><code>Content-Type: application/x-www-form-urlencoded</code></pre><p>添加好请求体，按Execute即可！</p><p><strong>注：要添加的请求体是what=flag等号左右不能有空格，有多个要用&amp;连接，如：what1=flag1&amp;waht2=flag2</strong></p><p>还有另外其他几种格式化数据方式，参见：<a href="https://www.cnblogs.com/xiaoxi-3-/p/7612254.html">传送门</a></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑网卡是否支持5Ghz频段</title>
      <link href="2020/05/15/software/2020/dian-nao-wang-qia-shi-fou-zhi-chi-5ghz-pin-duan/"/>
      <url>2020/05/15/software/2020/dian-nao-wang-qia-shi-fou-zhi-chi-5ghz-pin-duan/</url>
      
        <content type="html"><![CDATA[<p>win + r 键入</p><pre class=" language-lang-bash"><code class="language-lang-bash">netsh wlan show drivers</code></pre><p><img src="https://i.loli.net/2020/03/19/vkF8nLl3cYTCipg.png" alt=""></p><p>可查看网卡支持的无线电类型</p><blockquote><p>1）802.11b、802.11g只支持2.4GHz<br>2）802.11a、802.11ac支持5GHz<br>3）802.11n 采用了多重输入/输出技术来提高网速，对于5GHz有可能支持，但大多数情况下，都是不支持的。</p></blockquote><p>总结：</p><p>无线网卡支持的无线协议标准（无线模式）中，</p><p>1）如果只有802.11 b/g/n，说明该网卡不支持5GHz；</p><p>2）如果包含了802.11a或者802.11ac，说明该网卡支持5GHz。</p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决笔记本连接wifi提示无法连接这个网络问题</title>
      <link href="2020/05/15/software/2020/jie-jue-shou-ji-lian-jie-shang-wifi-ke-yi-shang-wang-dian-nao-bu-shang-bu-liao-wang-de-wen-ti/"/>
      <url>2020/05/15/software/2020/jie-jue-shou-ji-lian-jie-shang-wifi-ke-yi-shang-wang-dian-nao-bu-shang-bu-liao-wang-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一般家里的  <strong>路由器</strong>  开启了 <strong>DHCP</strong> 动态分配 <strong>IP</strong> 功能，由于无法分配 <strong>IP</strong> 就可能导致电脑无法上网，只需要让电脑重新获取 <strong>IP</strong> 即可。</p><h3 id="可解决的情况"><a href="#可解决的情况" class="headerlink" title="可解决的情况"></a>可解决的情况</h3><ol><li>电脑成功连上 <strong>WIFI</strong>；</li><li>电脑右下角 <strong>WIFI</strong> 显示 <strong><em>此wifi不能上网</em></strong>。</li></ol><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>输入 <strong>win + r</strong>；</li><li>继续输入 <strong>cmd</strong>；</li><li>输入 <strong>ipconfig /release</strong>，回车；<ul><li>说明：去除网卡的动态 <strong>IP</strong> 地址。</li></ul></li><li>输入 <strong>ipconfig /renew</strong>，回车；<ul><li>说明：为网卡重新动态分配 <strong>IP</strong> 地址。</li></ul></li></ol><p>理论上 <strong>wifi</strong> 就可以上网了。</p><p><em>注：此方法不一定100％管用，还不可以的话，需要具体问题具体分析了，不能一棒子打死。</em></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决笔记本连接wifi提示无法连接这个网络问题</title>
      <link href="2020/05/15/software/2020/jie-jue-bi-ji-ben-lian-jie-wifi-ti-shi-wu-fa-lian-jie-zhe-ge-wang-luo-wen-ti/"/>
      <url>2020/05/15/software/2020/jie-jue-bi-ji-ben-lian-jie-wifi-ti-shi-wu-fa-lian-jie-zhe-ge-wang-luo-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>这几天被这个该死的折腾的死去活来，网上找了好多教程，试过之后感觉都没用（其实很多还是有用的，讲的跟自己做的貌似不太一样）小声逼逼QAQ</p><p>首先，很大概率上不是电脑硬件坏了。</p><p>基本上都是驱动问题。</p><p>win10自带的疑难杂症估计也解决不了。</p><p>重置电脑也太麻烦了QAQ</p><p>另外，可以去更新下驱动，鲁大师就行了。</p><p>千万不要 <strong>轻易</strong> 去用这个命令：<code>netsh winsock reset</code>就是重置网络命令。</p><p>当然，密码没输入正确，被拉黑了就没什么好讲的了。</p><p>在右下角找到wifi图标</p><p><img src="https://img-blog.csdnimg.cn/20190826174807397.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190826174855881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190826174932635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190826175023967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190826175100988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190826175317482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190826175503163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后可能就可以了。</p><p>要是还不可以，就用把驱动卸载，手动重新安装（系统自己会重新安装的，但是不一定有效）。</p><p>要是实在是连接不了，就拿去给高手看看吧。</p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机仿真指示灯开关控制器</title>
      <link href="2020/05/14/mcu/2020/dan-pian-ji-fang-zhen-zhi-shi-deng-kai-guan-kong-zhi-qi/"/>
      <url>2020/05/14/mcu/2020/dan-pian-ji-fang-zhen-zhi-shi-deng-kai-guan-kong-zhi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>程序启动后， <strong>8</strong>  只发光二极管先整体闪烁 <strong>3</strong> 次（即亮→暗→亮→暗→亮→暗，间隔时间以肉眼可观察到为准），然后根据开关状态控制对应发光二极管的亮灯状态，即开关闭合相应灯亮，开关断开相应灯灭，直至停止程序运行软件编程原理为：</p><ol><li><strong>8</strong> 只发光二极管整体闪烁 <strong>3</strong> 次亮灯：向 <strong>P2</strong> 口送入数值 <strong>0</strong>；灭灯：向 <strong>P2</strong> 口送人数值 <strong>0FFH</strong> ；闪烁 <strong>3</strong> 次：循环 <strong>3</strong> 次；闪烁快慢：由软件延时时间决定。</li><li>根据开关状态控制灯亮或灯灭开关控制灯：将 <strong>P3</strong> 口（即开关状态）内容送入 <strong>P2</strong> 口；无限持续：无条件循环。</li></ol><h3 id="所需芯片"><a href="#所需芯片" class="headerlink" title="所需芯片"></a>所需芯片</h3><ol><li><strong>AT89C51</strong></li><li><strong>CAP</strong></li><li><strong>CAP-ELEC</strong> </li><li><strong>CRYSTAL</strong></li><li><strong>LED-RED</strong> </li><li><strong>RES</strong></li><li><strong>SWITCH</strong></li></ol><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://imgkr.cn-bj.ufileos.com/9e33fe64-4b2f-4e44-9037-75d71554aa5a.png" alt="流程图"></p><h3 id="仿真图"><a href="#仿真图" class="headerlink" title="仿真图"></a>仿真图</h3><p><img src="https://imgkr.cn-bj.ufileos.com/0996d836-d0aa-46d2-b28d-a8168ab4473a.png" alt="仿真图"></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><pre class=" language-lang-assembly"><code class="language-lang-assembly">    ORG     0000H    LJMP    START    ORG     0030HSTART:    MOV     R5, #3SUBROUTINE:    MOV     P2, #0    LCALL   DELAY    MOV     P2, #0FFH    LCALL   DELAY    DJNZ    R5, SUBROUTINEDLOOP:    MOV     P2, P3    LJMP    DLOOP;延时子程序，延时100毫秒DELAY:    MOV     R0, #100D1:    MOV     R1, #50D2:    MOV     R2, #25    DJNZ    R2, $    DJNZ    R1, D2    DJNZ    R0, D1    RETEND</code></pre><p>C语言代码比较简单，就不写了。</p><h2 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h2><p><img src="https://imgkr.cn-bj.ufileos.com/6f5b11f7-d4ab-4406-bc79-a68280bedf56.gif" alt="仿真gif"></p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>龟虽寿</center><center>曹操</center><center>神龟虽寿，犹有竟时。</center><center>腾蛇乘雾，终为土灰。</center><center>老骥伏枥，志在千里。</center><center>烈士暮年，壮心不已。</center><center>盈缩之期，不但在天；</center><center>养怡之福，可得永年。</center><center>幸甚至哉，歌以咏志。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机仿真指示灯数码管的中断控制</title>
      <link href="2020/05/14/mcu/2020/dan-pian-ji-fang-zhen-zhi-shi-deng-shu-ma-guan-de-zhong-duan-kong-zhi/"/>
      <url>2020/05/14/mcu/2020/dan-pian-ji-fang-zhen-zhi-shi-deng-shu-ma-guan-de-zhong-duan-kong-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在编程软件的配合下，要求实现如下功能：</p><ul><li>程序启动后，D处于熄灯、LED1处于黑屏状态；单击K1，可使D亮灯状态反转一次；单击K2，可使LED1显示值加1，并按十六进制数显示，达到F后重新从1开始。</li></ul><h3 id="所需芯片"><a href="#所需芯片" class="headerlink" title="所需芯片"></a>所需芯片</h3><ol><li><strong>AT89C51</strong></li><li><strong>CAP</strong></li><li><strong>CAP-ELEC</strong> </li><li><strong>CRYSTAL</strong></li><li><strong>LED-RED</strong> </li><li><strong>RES</strong></li><li><strong>BUTTON</strong></li><li><strong>RESPACK-8</strong></li></ol><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://imgkr.cn-bj.ufileos.com/7fcb3e84-a887-41c0-8e5a-42c81a6253c8.png" alt="流程图"></p><h3 id="仿真图"><a href="#仿真图" class="headerlink" title="仿真图"></a>仿真图</h3><p><img src="https://imgkr.cn-bj.ufileos.com/7dc3fbe3-4497-470a-a6fd-19c08cefbcec.png" alt="仿真图"></p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><pre class=" language-lang-assembly"><code class="language-lang-assembly">    ORG     0000H    LJMP    START    ORG     0003H    LJMP    INT_0    ORG     0013H    LJMP    INT_1START:    MOV     P2, 00000000B    SETB    P0.4    SETB    EA    SETB    EX0    SETB    EX1    SETB    IT1    SETB    IT0    MOV     R1, #16    MOV     R2, 00HDLOOP:    LJMP   DLOOPINT_0:    CLR     EA        ;关中断    PUSH    PSW        ;保护现场    PUSH    ACC    SETB    EA        ;开中断    CPL     P0.4    ;中断子程序段    CLR     EA        ;关中断    POP        ACC        ;恢复现场    POP        PSW    SETB    EA        ;开中断    RETI            ;中断返回INT_1:    CLR     EA        ;关中断    PUSH    PSW        ;保护现场    PUSH    ACC    SETB    EA        ;开中断    CJNE    R2, #16, CONTINUE    MOV     R2, #00HCONTINUE:    MOV     DPTR, #TABLE    MOV     A, R2    MOVC    A, @A + DPTR    MOV     P2, A    INC     R2    CLR     EA        ;关中断    POP        ACC        ;恢复现场    POP        PSW    SETB    EA        ;开中断    RETI            ;中断返回TABLE:     DB 3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H, 7FH, 6FH, 77H, 7CH, 58H, 5EH, 79H, 71HEND</code></pre><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><pre class=" language-lang-c"><code class="language-lang-c">#include <reg51.h>unsigned char led_mod[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,                           0x7f, 0x6f, 0x77, 0x7c, 0x58, 0x5e, 0x79, 0x71};unsigned char count = 0;sbit P0_4 = P0 ^ 4;void INT_0SRV() interrupt 0 { P0_4 = ~P0_4; }void INT_1SRV() interrupt 2 {  count++;  if (count == 16)    count = 1;  P2 = led_mod[count];}void main(void) {  P2 = 0x00;  P0_4 = 0x01;  EA = 1;  EX0 = 1;  EX1 = 1;  IT1 = 1;  IT0 = 1;  while (1) {        ;    }}</code></pre><h2 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h2><p><img src="https://imgkr.cn-bj.ufileos.com/c6efcfac-a008-4240-854f-f804d5b9d6a2.gif" alt="仿真结果"></p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>登飞来峰</center><center>王安石</center><center>飞来山上千寻塔，闻说鸡鸣见日升。</center><center>不畏浮云遮望眼，自缘身在最高层。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用proteus仿真8086</title>
      <link href="2020/05/14/mcu/2020/ru-he-yong-proteus-fang-zhen-8086/"/>
      <url>2020/05/14/mcu/2020/ru-he-yong-proteus-fang-zhen-8086/</url>
      
        <content type="html"><![CDATA[<p><strong><em>岁月不饶人，我亦未曾饶过岁月。</em></strong></p><h2 id="1-需要的工具"><a href="#1-需要的工具" class="headerlink" title="1.需要的工具"></a>1.需要的工具</h2><p>proteus</p><p><em>过低版本不可以仿真8086，请下载7.8版本及以上的</em></p><p><a href="https://pan.baidu.com/s/1ANBzX668f9rVUAPKMASRLQ">下载地址(附教程)</a></p><p>提取码：rh8j</p><p>emu8086</p><p><a href="https://emu8086-microprocessor-emulator.en.softonic.com/download">官网地址</a></p><p><a href="https://pan.baidu.com/s/1UWKSyGCCOXgZ8fdwbS3fVA">网盘地址</a></p><p>提取码：j5qn</p><h2 id="2-编译汇编代码"><a href="#2-编译汇编代码" class="headerlink" title="2.编译汇编代码"></a>2.编译汇编代码</h2><p>打开emu8086</p><p><img src="https://img-blog.csdnimg.cn/20191231093207807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191231093228694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选择默认的即可。</p><p><em>也可以生成.exe或者.bin文件</em></p><p><img src="https://img-blog.csdnimg.cn/20191231093402948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>添加好你的代码，点compile</p><p><img src="https://img-blog.csdnimg.cn/20191231093446176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如果代码没有错误会弹出这个窗口，你可以重命名或者更改文件位置。</p><p><em>如果点的默认，那么这个文件在emu8086安装位置的MyBuild里面会有</em></p><h2 id="3-给proteus添加可执行文件"><a href="#3-给proteus添加可执行文件" class="headerlink" title="3.给proteus添加可执行文件"></a>3.给proteus添加可执行文件</h2><p>打开proteus</p><p><img src="https://img-blog.csdnimg.cn/20191231093957703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>会弹出来如下窗口</p><p><img src="https://img-blog.csdnimg.cn/20191231094537245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>按照图示更改好，即可</p><p><img src="https://img-blog.csdnimg.cn/2019123109461392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最后点击Execute，如果代码没错，仿真图连接的没有问题，就可以看到仿真结果了。</p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机仿真循环点亮那盏灯</title>
      <link href="2020/05/14/mcu/2020/dan-pian-ji-fang-zhen-dian-liang-na-zhan-deng/"/>
      <url>2020/05/14/mcu/2020/dan-pian-ji-fang-zhen-dian-liang-na-zhan-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>学单片机课程也有一段时间了，今天亲自动手做个超级 <strong>easy</strong> 的仿真试验，通过 <strong>keil + proteus</strong> 来点亮发光二极管。</p><h3 id="所需软件及芯片"><a href="#所需软件及芯片" class="headerlink" title="所需软件及芯片"></a>所需软件及芯片</h3><ol><li><strong><em>keil</em></strong></li><li><strong><em>proteus</em></strong><ul><li><strong>AT89C51</strong></li><li><strong>CAP</strong></li><li><strong>CAP-ELEC</strong> </li><li><strong>CRYSTAL</strong></li><li><strong>LED-RED</strong> </li><li><strong>RES</strong></li></ul></li></ol><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><h3 id="AT89C51引脚"><a href="#AT89C51引脚" class="headerlink" title="AT89C51引脚"></a><strong>AT89C51</strong>引脚</h3><p>简单介绍下这次仿真需要用到的 <strong>AT89C51</strong> 的引脚，这次我们做仿真用到的引脚不多！</p><h4 id="晶振引脚（XTAL1-XTAL2）"><a href="#晶振引脚（XTAL1-XTAL2）" class="headerlink" title="晶振引脚（XTAL1 + XTAL2）"></a>晶振引脚（<strong>XTAL1 + XTAL2</strong>）</h4><ul><li><strong>XTAL1(Pin19)</strong> ：片内振荡电路的输入端</li><li><strong>XTAL2(Pin20)</strong> ：片内振荡电路的输出端</li></ul><p>晶振电路：</p><p><img src="https://imgkr.cn-bj.ufileos.com/5ce44b98-7a93-4e1f-8b3f-117c714f1906.png" alt="晶振电路"></p><h4 id="控制引脚"><a href="#控制引脚" class="headerlink" title="控制引脚"></a>控制引脚</h4><ul><li><strong>$\overline{EA}$(Pin31)</strong> ：程序存储器的内外部选通，接低电平从外部程序存储器读指令，如果接高电平则从内部程序存储器读指令。</li></ul><h4 id="可编程输入-输出引脚"><a href="#可编程输入-输出引脚" class="headerlink" title="可编程输入/输出引脚"></a>可编程输入/输出引脚</h4><ul><li><strong>51</strong> 单片机有 <strong>4</strong> 组 <strong>8</strong> 位的可编程 <strong>I/O</strong> 口，分别为 <strong>P0、P1、P2、P3</strong> 口，每个口有 <strong>8</strong> 位（ <strong>8</strong> 根引脚），共 <strong>32</strong> 根。<ul><li><strong>PO</strong> 口（ <strong>Pin39～Pin32</strong> ）： <strong>8</strong> 位双向 <strong>I/O</strong> 口线，名称为 <strong>P0.0～P0.7</strong> 。</li><li><strong>P1</strong> 口（ <strong>Pin1～Pin8</strong> ）： <strong>8</strong> 位准双向I/O口线，名称为 <strong>P1.0～P1.7</strong> 。 </li><li><strong>P2</strong> 口（ <strong>Pin21～Pin28</strong> ）：<strong>8</strong> 位准双向 <strong>I/O</strong> 口线，名称为 <strong>P2.0～P2.7</strong> 。</li><li><strong>P3</strong> 口（ <strong>Pin10～Pin17</strong> ）：<strong>8</strong> 位准双向 <strong>I/O</strong> 口线，名称为 <strong>P3.0～P3.7</strong> 。</li></ul></li></ul><p>这就意味着 <strong>P1 ~ P3</strong> 都可以控制二极管！</p><h3 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h3><p><img src="https://imgkr.cn-bj.ufileos.com/4b76c18b-c187-4406-a346-3b59e9c58905.png" alt="电路图"></p><p>通过实验原理图，我们可以得出，发光二极管共阳极，所以P1.0 ~ P1.7口是低电平时才能点亮二极管。</p><h3 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h3><pre class=" language-lang-assembly"><code class="language-lang-assembly">    ORG 0000H    LJMP    START                              ORG 0300HSTART:    MOV     A, #0FEH                ;0FEH = 1111 1110BOUTPUT:    MOV     P1, A                       RL      A                       ;左移    LCALL   Delay                   ;跳转延时子程序    LJMP    OUTPUTDelay:    MOV R2,#10          L1:    MOV R3,#200       DLoop:    MOV R4,#248             DJNZ R4,$               DJNZ R3,DLY2           DJNZ R2,DLY1            RET                     END</code></pre><p>怎么仿真可以参考<a href="https://blog.csdn.net/qq_43826212/article/details/103777319">如何用proteus仿真8086</a></p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>原理图不难，程序不难，这是一个很简单的试验。</p><p>我们把主要的目光放在延时子程序上，这个延时程序到底延时多久？这就需要我们计算了。</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">Delay:    MOV R2,#10          ;执行1次, 单周期指令L1:    MOV R3,#200         ;执行10次, 单周期指令DLoop:    MOV R4,#248         ;执行 200 * 10 次, 单周期指令    DJNZ R4,$           ;执行 2 * 248 * 200 * 10, 双周期指令, 所以要 × 2    DJNZ R3,DLY2        ;执行 2 * 200 * 10, 双周期指令    DJNZ R2,DLY1        ;执行 2 * 10, 双周期指令    RET                 ;双周期指令 2    ;总时间 1 + 10 + 200 * 10 + 2 * 248 * 200 * 10 + 2 * 200 * 10 + 2 * 10 + 2 = 998033us, 即延时1s</code></pre><p>首先我们需要知道 <strong>一个机器周期包括12个时钟周期</strong> ，那么<strong>1</strong>个机器周期是多长时间呢？</p><p>如果一个 <strong>单片机工作于12M晶体震荡器，它的时钟周期是1/12（微秒）</strong> ，那么 <strong>它的一个机器周期是12 *（1/12）也就是1微秒。</strong> </p><p>还有就是 在 <strong>MCS-51单片机的所有指令中，有一些完成得比较快，只要1个机器周期就行了，有一些完成得比较慢，得要2个机器周期，还有两条指令要4个机器周期才行。</strong> </p><p>所以我们把每条指令执行的次数累加起来就得到了延时的时间了。</p><p>更加具体的可以参考：<a href="http://www.51hei.com/mcu/1247.html">单片机汇编延时程序的理解</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习单片机，就是学习怎么使用这款芯片，把这款芯片的各个引脚的功能搞清楚了，把芯片对应的汇编弄明白了，按照自己的想法进行编程，再对自己的程序Debug，这样子才能真正做好将来的大项目。熟能生巧，编程是不断的练习而掌握的一种技巧。</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>江城子·密州出猎</center><center>苏东坡</center><center>老夫聊发少年狂，左牵黄，右擎苍，锦帽貂裘，千骑卷平冈。<br>为报倾城随太守，亲射虎，看孙郎。<br></center><center>酒酣胸胆尚开张，鬓微霜，又何妨？持节云中，何日遣冯唐？<br>会挽雕弓如满月，西北望，射天狼。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式学习笔记(2)</title>
      <link href="2020/05/13/iot/2020/qian-ru-shi-arm-xue-xi-bi-ji-2/"/>
      <url>2020/05/13/iot/2020/qian-ru-shi-arm-xue-xi-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h2 id="ARM体系"><a href="#ARM体系" class="headerlink" title="ARM体系"></a>ARM体系</h2><p>ARM：Advanced RISC Machine</p><h3 id="ARM命名规则"><a href="#ARM命名规则" class="headerlink" title="ARM命名规则"></a>ARM命名规则</h3><div class="table-container"><table><thead><tr><th style="text-align:center">ARMv</th><th style="text-align:center">n</th><th style="text-align:center">variants</th><th style="text-align:center">x (variants)</th></tr></thead><tbody><tr><td style="text-align:center">固定字符，即ARM Version</td><td style="text-align:center">指令集版本号</td><td style="text-align:center">变种</td><td style="text-align:center">排除x后指定的变种</td></tr></tbody></table></div><p>常见的variants有以下几种：</p><ul><li>T — Thumb指令集</li><li>M — 长乘法指令</li><li>E  — 增强型DSP指令</li><li>J  — Java加速器Jazelle</li><li>D  — 支持片上Debug</li><li>I   — 嵌入式ICE，支持片上断点和调试</li><li>z  — cache</li></ul><p>比如： <strong>ARM7TMDI</strong> 表示ARM指令集版本为7，支持 <strong>TMDI</strong> 变种</p><p>在 <strong>ARMv7</strong> 以后时期，统一用 Cortex 作为主名。</p><p><img src="https://i.loli.net/2020/03/18/6b8xJurhjlPngAz.png" alt="image-20200318200830713"></p><h3 id="ARM公司"><a href="#ARM公司" class="headerlink" title="ARM公司"></a>ARM公司</h3><ol><li><strong>ARM</strong> 公司于1990年11月在英国剑桥成立，前身为 <strong>Acorn</strong> 计算机公司。</li><li><strong>ARM</strong> 公司是全球领先的16/32位嵌入式 <strong>RISC</strong> 微处理器解决方案供应商。</li><li><strong>ARM</strong> 公司是知识产权( <strong>IP</strong> )公司，本身不生产芯片，靠转让设计许可，由合作伙伴公司来生产各具特色的芯片。</li></ol><p>目前，全世界有几十家著名的半导体公司都使用 <strong>ARM</strong> 公司的授权，其中包括 <strong>MOTOROLA</strong> 、 <strong>IBM</strong> 、 <strong>Intel</strong> 、 <strong>LG</strong> 、 <strong>SONY</strong> 、 <strong>NEC</strong> 、 <strong>ATMEL</strong> 等，从而保证了大量的开发工具和丰富的第三方资源，它们共同保证了基于 <strong>ARM</strong> 处理器核的设计可以很快投入市场。</p><p><strong>ARM</strong> 公司已成为移动通信、手持设备、多媒体数字消费嵌入式解决方案的 <strong>RISC</strong> 标准。</p><h3 id="ARM-Cortex系列"><a href="#ARM-Cortex系列" class="headerlink" title="ARM Cortex系列"></a>ARM Cortex系列</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Cortex-A</th><th style="text-align:center">Cortex-R</th><th style="text-align:center">Cortex-M</th><th style="text-align:center">Machine Learing</th><th style="text-align:center">SecureCore</th></tr></thead><tbody><tr><td style="text-align:center">Highest Performance(高性能)</td><td style="text-align:center">Real-Time Processing(实时)</td><td style="text-align:center">Lowest Power, Lower Cost(低功率,低成本)</td><td style="text-align:center">Efficiency Uplift for All Devices(提高所有设备效率)</td><td style="text-align:center">Tamper Resistant(防篡改)</td></tr></tbody></table></div><h3 id="ARM处理器运行模式"><a href="#ARM处理器运行模式" class="headerlink" title="ARM处理器运行模式"></a>ARM处理器运行模式</h3><h4 id="内存字节顺序"><a href="#内存字节顺序" class="headerlink" title="内存字节顺序"></a>内存字节顺序</h4><ul><li>大端模式(Big Endian)</li><li>小端模式(Little Endian)</li></ul><p><img src="https://i.loli.net/2020/03/18/KV8RhDyjbAI2GQ5.png" alt="image-20200318194956268"></p><p>我们用ARM的一般是32-bit体系结构</p><ul><li>1 Byte = 8 bits</li><li>半个字(Halfword) 是16bits (2Byte)</li><li>一个字(Word)是32bits(4Byte)</li><li>ARM指令集32位，Thumb指令集16位，Thumb集为ARM指令集的子集</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">mode</th><th style="text-align:center">特权模式(Y/N)</th><th style="text-align:center">异常模式(Y/N)</th><th style="text-align:center">description</th><th style="text-align:center">二进制表示</th></tr></thead><tbody><tr><td style="text-align:center">User(用户模式)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">大多数任务运行的非特权模式</td><td style="text-align:center">10000</td></tr><tr><td style="text-align:center">System(系统模式)</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center">使用与用户相同的寄存器的特权模式</td><td style="text-align:center">10001</td></tr><tr><td style="text-align:center">FIQ(快速中断模式)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">当一个高优先级(快速)中断被引起时输入</td><td style="text-align:center">10010</td></tr><tr><td style="text-align:center">IRQ(外部中断模式)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">当一个低优先级(普通)中断被引起时输入</td><td style="text-align:center">10011</td></tr><tr><td style="text-align:center">Supervisor(管理模式)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">在复位和执行软件中断指令时输入</td><td style="text-align:center">10111</td></tr><tr><td style="text-align:center">Abort(中止模式)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">用于处理内存访问冲突</td><td style="text-align:center">11011</td></tr><tr><td style="text-align:center">Undef(未定义模式)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">用于处理未定义的指令</td><td style="text-align:center">11111</td></tr></tbody></table></div><p>总的来讲可以分为两大类：</p><ul><li>特权模式(其余6个模式)和非特权模式(User)</li></ul><p>针对特权模式(除User模式以外的模式)：</p><ul><li>系统模式(System)和异常模式(其余5种)</li></ul><h3 id="ARM7TDMI-S-core的逻辑结构"><a href="#ARM7TDMI-S-core的逻辑结构" class="headerlink" title="ARM7TDMI-S core的逻辑结构"></a>ARM7TDMI-S core的逻辑结构</h3><ul><li>32bits</li><li>Load/Store</li><li>31个通用寄存器组( <strong>general purpose register</strong> )，6个状态寄存器( <strong>status register</strong> )<ul><li>R0~R12通用寄存器</li><li>R13堆栈指针(Stack Pointer)</li><li>R14链接寄存器(Link Register)</li><li>R15程序指针(Program Counter)</li><li>CPSR当前程序状态寄存器(Current Program Status Register)</li><li>SPSR保存程序状态寄存器(Saved Program Statuc Register)</li></ul></li></ul><p>ARM状态下的寄存器组织：</p><p><img src="https://i.loli.net/2020/03/18/GTu6Frz5mVIojck.png" alt="ARM状态下的寄存器组织"></p><p>未分组寄存器R0~R7</p><ul><li>在所有的运行模式下，未分组寄存器都指向同一个物理寄存器，他们未被系统用作特殊的用途，因此，在中断或异常处理进行运行模式转换时，由于不同的处理器运行模式均使用相同的物理寄存器，可能会造成寄存器中数据的破坏，这一点在进行程序设计时应引起注意。</li></ul><p>分组寄存器R8~R12</p><ul><li>每次所访问的物理寄存器与处理器当前的运行模式有关</li><li><strong>R8～R12</strong> ：每个寄存器对应两个不同的物理寄存器<ul><li>当使用 <strong>fiq</strong> 模式时，访问寄存器 <strong>R8_fiq～R12_fiq</strong> </li><li>当使用除 <strong>fiq</strong> 模式以外的其他模式时，访问寄存器 <strong>R8_usr～R12_usr</strong> </li></ul></li></ul><h3 id="ARM异常处理"><a href="#ARM异常处理" class="headerlink" title="ARM异常处理"></a>ARM异常处理</h3><h4 id="R14-LInk-Register链接寄存器"><a href="#R14-LInk-Register链接寄存器" class="headerlink" title="R14(LInk Register链接寄存器)"></a>R14(LInk Register链接寄存器)</h4><ul><li><p>R14保存的是程序的地址(程序的返回地址)</p><pre class=" language-lang-armasm"><code class="language-lang-armasm"># 调用子程序(异常)STMFD SP!,{<Regs>,LR}# 子程序返回(异常返回)LDMFD SP!,{<Regs>,PC}</code></pre></li></ul><p>当前程序状态寄存器(Current Program Status Register)</p><p><img src="https://i.loli.net/2020/03/18/ypGErWXQstfHBSi.png" alt="当前程序状态寄存器"></p><p>一般用SPSR来恢复CPSR！</p><h4 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常(Exception)"></a>异常(Exception)</h4><ul><li>当程序的正常流程必须临时停止时，就会出现异常，例如为来自外设的中断提供服务。在尝试处理异常之前，ARM7TDMI-S保留当前处理器状态，以便在处理程序例程完成后可以恢复原始程序。</li><li>优先级(Priority)<ol><li>Reset(highest priority) -&gt; 重置</li><li>Data Abort -&gt; 数据预取中止</li><li>FIQ</li><li>IRQ</li><li>Prefetch Abort -&gt; 指令预取中止</li><li>Undefined instruction -&gt; 未定义指令</li><li>SWI(lowest priority) -&gt; 软件中断(software interrupt)</li></ol></li></ul><h4 id="进入异常流程"><a href="#进入异常流程" class="headerlink" title="进入异常流程"></a>进入异常流程</h4><ol><li>Preserves the address of the next instruction in the appropriate LR.(在适当的LR中保留下一条指令的地址)</li><li>Copies the CPSR into the appropriate SPSR.(将CPSR复制到适当的SPSR中)</li><li>Forces the CPSR mode bits to a value which depends on the exception.(将CPSR模式位设置为当前异常模式位)</li><li>Forces the PC to fetch the next instruction from the relevant exceptions.(使PC处理相应的异常)</li></ol><p>中断向量表(Vector Table)</p><p><img src="https://i.loli.net/2020/03/18/b98WngIeHRkq6lT.png" alt="中断向量表"></p><h4 id="异常返回"><a href="#异常返回" class="headerlink" title="异常返回"></a>异常返回</h4><ol><li>PC  = LR - offset</li><li>SPSR -&gt; CPSR</li><li>Clear the interrupt disable flags that were set on entry(清除在中断时时设置的中断禁用标志)</li></ol><p><img src="https://i.loli.net/2020/03/18/kuF5jrey2t4Bown.png" alt="image-20200318213758689"></p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式学习笔记(3)</title>
      <link href="2020/05/13/iot/2020/qian-ru-shi-arm-xue-xi-bi-ji-3/"/>
      <url>2020/05/13/iot/2020/qian-ru-shi-arm-xue-xi-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h2 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h2><h3 id="精简指令集设计理念-The-RISC-design-philosophy"><a href="#精简指令集设计理念-The-RISC-design-philosophy" class="headerlink" title="精简指令集设计理念(The  RISC design philosophy)"></a>精简指令集设计理念(The  RISC design philosophy)</h3><ul><li>设计原则(Design rules)<ul><li>指令”短小精悍”</li><li>应用流水线技术设计</li><li>大量采用寄存器</li><li>Load/Store存储结构</li></ul></li></ul><h3 id="ARM指令集特点"><a href="#ARM指令集特点" class="headerlink" title="ARM指令集特点"></a>ARM指令集特点</h3><ol><li>所有指令都是32位<ol><li>大多数指令都在单周期内完成</li><li>所有指令都可以条件执行</li><li>ARM指令为Load/Store类型</li><li>基本指令仅36条，分为五类</li><li>有9种寻址方式</li><li>指令集可以通过协处理器扩展</li></ol></li><li>ARM指令是加载/存储(Load/Store)型<ol><li>指令集仅能处理寄存器中的数据，处理结果都要放回寄存器中</li><li>对系统存储器的访问则需要通过专门的Load/Store指令来完成</li></ol></li><li>ARM指令可以分为五大类<ol><li>数据处理指令</li><li>算术运算指令</li><li>逻辑指令</li><li>比较指令</li><li>乘法指令</li><li>分支转移指令</li><li>Load/Store指令</li></ol></li><li>ARM指令有9种寻址方式<ol><li>寄存器寻址</li><li>立即寻址</li><li>寄存器偏移寻址</li><li>寄存器间接寻址</li><li>基址寻址</li><li>堆栈寻址</li><li>多寄存器寻址</li><li>块拷贝寻址</li><li>相对寻址</li></ol></li></ol><h3 id="数据处理指令-Data-Processing-Instructions"><a href="#数据处理指令-Data-Processing-Instructions" class="headerlink" title="数据处理指令(Data Processing Instructions)"></a>数据处理指令(Data Processing Instructions)</h3><ul><li><strong>Syntax: \<opcode(指令)>{\<cond(指令执行条件)>}{S(状态位)} <rd(目的地址)>, <n(源数据)>{, \<opcode2>}</opcode2></n(源数据)></rd(目的地址)></cond(指令执行条件)></opcode(指令)></strong> </li><li>&lt;&gt;括号内是必须的，{}括号内的是可选的</li></ul><h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h4><ul><li>MOV Move a 32-bit value into a register Rd = N</li><li>MVN move the NOT of the 32-bit value into a register Rd = ~N</li></ul><p>Example1：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">MOV R5, #5MOV R7, #8MOV R7, R5    ;let R7 = R5</code></pre><pre class=" language-lang-assem"><code class="language-lang-assem">MVN R1, #0xFF    ;R1 = 0xFFFFFFFF00;0xFF转化为二进制;0000 0000 0000 0000 0000 0000 1111 1111;取反得到;1111 1111 1111 1111 1111 1111 0000 0000;即0xFFFFFF00</code></pre><h4 id="带有-的指令"><a href="#带有-的指令" class="headerlink" title="带有{, \的指令"></a>带有{, \<opcode2>的指令</opcode2></h4><p>Example2：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">MOV R5, #5MOV R7, #8MOV R7, R5, LSL #2    ;let R7 = R5 * 4 = (R5 << 2);LSL左移指令;左移一位×2,右移一位÷2</code></pre><h4 id="带有-S-的指令"><a href="#带有-S-的指令" class="headerlink" title="带有{S}的指令"></a>带有{S}的指令</h4><p>Example3：</p><p>请回顾下CPSR的格式</p><p><img src="https://i.loli.net/2020/03/18/ypGErWXQstfHBSi.png" alt="当前程序状态寄存器"></p><pre class=" language-lang-assembly"><code class="language-lang-assembly">CPSR = nzcvqiFt_USERR0 = 0X00000000R1 = 0X80000004MOVS R0, R1, LSL #1;结果;更新CPSR的值,影响了C标志位;CPSR = nzCvqiFt_USER;R0 = R1 << 2;把R1左移两位值赋给R0;即R0 = 0x00000008;R1 = 0x80000004</code></pre><h3 id="算术运算指令-Arithmetic-Instructions"><a href="#算术运算指令-Arithmetic-Instructions" class="headerlink" title="算术运算指令(Arithmetic Instructions)"></a>算术运算指令(Arithmetic Instructions)</h3><ul><li>算术指令实现32位有符号和无符号值的加减运算</li><li><strong>Syntax: \<instruction>{\<cond>}{S} Rd, Rn, N</cond></instruction></strong> </li></ul><h4 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h4><p>Example1：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R0 = 0x00000000R1 = 0x00000002R2 = 0x00000001SUB R0, R1, R2;结果;R0 = R1 - R2 = 0x00000001</code></pre><h4 id="RSB"><a href="#RSB" class="headerlink" title="RSB"></a>RSB</h4><p>Example2：</p><ul><li>反向减法，交换减数与被减数的位置</li></ul><pre class=" language-lang-assembly"><code class="language-lang-assembly">R0 = 0X00000000R1 = 0X00000077RSB R0, R1, #0;结果;R0 = 0x0 - R1;即R0 = -R1 = 0xFFFFFF89;-R1就是R1的补码</code></pre><h4 id="带有-S-的指令-1"><a href="#带有-S-的指令-1" class="headerlink" title="带有{S}的指令"></a>带有{S}的指令</h4><p>Example3：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">CPSR = nzcvqiFt_USERR1 = 0X00000001SUBS R1, R1, #1;结果;CPSR = nZCvqiFt_USER;R1 = 0X00000000</code></pre><h4 id="带有-的指令-1"><a href="#带有-的指令-1" class="headerlink" title="带有{, \的指令"></a>带有{, \<opcode2>的指令</opcode2></h4><p>Example4：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R0 = 0X00000000R1 = 0X00000005ADD R0, R1, R1, LSL #1;R0 = R1 + R1 << 1;结果;R0 = 0x0000000f;R1 = 0x00000005</code></pre><h3 id="逻辑指令-Logical-Instructions"><a href="#逻辑指令-Logical-Instructions" class="headerlink" title="逻辑指令(Logical Instructions)"></a>逻辑指令(Logical Instructions)</h3><ul><li>逻辑指令对两个源寄存器执行按位的逻辑操作</li><li><strong>\<syntax>: \<instruction> {\<cond>}{S} Rd, Rn, N</cond></instruction></syntax></strong> </li></ul><h4 id="ORR"><a href="#ORR" class="headerlink" title="ORR"></a>ORR</h4><p>Example1：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R0 = 0X00000000R1 = 0X02040608R2 = 0X10305070ORR R0, R1, R2;R0 = R1 OR R2;或,有1为1,无1为0;R0 = 0x12345678</code></pre><pre><code>#### BIC(位清除指令)</code></pre><p>Example2：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R1 = 0B1111    ;二进制R2 = 0B0101BIC R0, R1, R2;相当于R0 = R1 AND (NOT)R2;结果;R0 = 0B1010;(NOT)R2 = 1010;1010 AND 1111 = 1010</code></pre><h3 id="比较指令-Comparison-Instructions"><a href="#比较指令-Comparison-Instructions" class="headerlink" title="比较指令(Comparison Instructions)"></a>比较指令(Comparison Instructions)</h3><ul><li>比较指令用于比较或测试具有32位值的寄存器。它们根据结果更新cpsr标志位，但不影响其他寄存器</li><li>S后缀对于更新标志的比较指令来说是不必要的</li><li><strong>Syntax: \<instruction>{\<cond>} Rn, N</cond></instruction></strong> </li></ul><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h4><p>Example1：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">CPSR = nzcvqiFt_USERR0 = 4R9 = 4CMP R0, R9;结果;CPSR = nZcvqiFt_USER;更新了Z标志位</code></pre><h3 id="乘法指令-Multiply-Instructions"><a href="#乘法指令-Multiply-Instructions" class="headerlink" title="乘法指令(Multiply Instructions)"></a>乘法指令(Multiply Instructions)</h3><ul><li>乘法指令将一对寄存器的内容相乘，并根据指令将结果累积到另一个寄存器中。长乘法累积到一对表示64位值的寄存器上。最后的结果放在一个目的寄存器或一对寄存器中</li><li>Syntax<ul><li><strong>MLA{\<cond>}{S} Rd, Rm, Rs, Rn</cond></strong></li><li><strong>MUL{\<cond>}{S}Rd, Rm, Rs</cond></strong></li><li><strong>MLA: Rd = (Rm * Rs) + Rn</strong></li><li><strong>MUL: Rd = Rm * Rs</strong></li><li><strong>\<instruction>{\<cond>}{S} RdLo, RdHi, Rm, Rs</cond></instruction></strong></li><li><strong>SMLAL: [RdHi, RdLo] = [RdHi, RdLo] + (Rm * Rs)</strong></li></ul></li></ul><h4 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h4><p>Example1：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R0 = 0X00000000R1 = 0X00000002R2 = 0X00000002MUL R0, R1, R2    ;R0 = R1 * R2;结果;R0 = 0x00000004;R1 = 0x00000002;R2 = 0x00000002</code></pre><h4 id="UMULL-无符号长乘法"><a href="#UMULL-无符号长乘法" class="headerlink" title="UMULL(无符号长乘法)"></a>UMULL(无符号长乘法)</h4><p>Example2：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R0 = 0X00000000;R1 = 0X00000000;R2 = 0XF0000002;R3 = 0X00000002;UMULL R0, R1, R2, R3    ;[R1, R0] = R2 * R3;结果;R0 = 0xE0000004 = RdLo;R1 = 0x00000001 = RdHi;R2 * R3用32-bit肯定溢出是个64-bit的数，用R0保存低32-bit，R1保存高32-bit;R2 * R3的结果为 0x00000001E0000004(注意这是十六进制乘法,直接用左移更方便)</code></pre><h3 id="分支指令-Branch-Instructions"><a href="#分支指令-Branch-Instructions" class="headerlink" title="分支指令(Branch Instructions)"></a>分支指令(Branch Instructions)</h3><ul><li>分支指令改变执行流，或用于调用例程。这种类型的指令允许程序有子例程、if-then-else结构和循环</li><li>Syntax<ul><li><strong>B{\<cond>} label</cond></strong></li><li><strong>BL{\<cond>} label</cond></strong></li><li><strong>BX{\<cond> Rm</cond></strong></li><li><strong>BLX{\<cond>} label | Rm</cond></strong></li></ul></li></ul><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>Example1：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">    B forward    ADD R1, R2, #4    ADD R0, R6, #2    ADD R3, R7, #4forward    SUB R1, R2, #4</code></pre><p>Example2：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">backward    ADD R1, R2, #4    SUB R1, R2, #4    ADD R4, R6, R7    B backward</code></pre><h4 id="BL"><a href="#BL" class="headerlink" title="BL"></a>BL</h4><ul><li>BL指令先将下一条指令的地址拷贝到LR链接寄存器中，然后跳转到指定地址运行程序</li></ul><pre class=" language-lang-assembly"><code class="language-lang-assembly">BL subroutine    ;LR -> 下一条指令, 即CMP R1, #5CMP R1, #5        ;比较R1, R5MOVEQ R1, #0    ;if(R1 == 5)then R1 = 0...subroutine<subroutine code>MOV PC, LR        ;return by moving pc = lr</code></pre><h3 id="Load-Store指令-Load-Store-Instructions"><a href="#Load-Store指令-Load-Store-Instructions" class="headerlink" title="Load/Store指令(Load-Store Instructions)"></a>Load/Store指令(Load-Store Instructions)</h3><ul><li><strong>Load/Store指令用于寄存器和内存间数据的传送</strong></li><li><strong>Load 用于把内存中的数据装载到寄存器中</strong></li><li><strong>Store用于把寄存器中的数据存入内存</strong></li><li><strong>该集合的指令使用频繁，在指令集中最为重要，因为其他指令只能操作寄存器，当数据存放在内存中时，必须先把数据从内存装载到寄存器，执行完后再把寄存器中的数据存储到内存中</strong></li></ul><h4 id="单个寄存器传输-Single-Register-Transfer"><a href="#单个寄存器传输-Single-Register-Transfer" class="headerlink" title="单个寄存器传输(Single-Register Transfer)"></a>单个寄存器传输(Single-Register Transfer)</h4><ul><li>用于将单个数据项移入或移出寄存器</li><li>支持的数据类型包括有符号的和无符号的字(32位)、半字(16位)和字节</li><li>Syntax<ul><li><strong>\<ldr|str>{\<cond>}{B} Rd, addressing1</cond></ldr|str></strong></li><li><strong>LDR{\<cond>}SB|H|SH Rd, addressing2</cond></strong></li><li><strong>STR{\<cond>}H Rd, addressing2</cond></strong></li></ul></li></ul><p>Example1：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">LDR R0, [R1]    ;= LDR R0, [R1, #0];;STR R0, [R1]    ;= STR R0, [R1, #0]</code></pre><h4 id="单寄存器负载存储寻址模式-Single-Register-Load-Store-Addressing-Modes"><a href="#单寄存器负载存储寻址模式-Single-Register-Load-Store-Addressing-Modes" class="headerlink" title="单寄存器负载存储寻址模式(Single-Register Load-Store Addressing Modes)"></a>单寄存器负载存储寻址模式(Single-Register Load-Store Addressing Modes)</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Index method</th><th style="text-align:center">Data</th><th style="text-align:center">Base address register</th><th style="text-align:center">Example</th></tr></thead><tbody><tr><td style="text-align:center">Preindex with writeback(前项索引+写回)</td><td style="text-align:center">mem[base + offset]</td><td style="text-align:center">base + offset</td><td style="text-align:center">LDR R0, [R1, #4]!</td></tr><tr><td style="text-align:center">Preindex</td><td style="text-align:center">mem[base + offset]</td><td style="text-align:center">not updated</td><td style="text-align:center">LDR R0, [R1, #4]</td></tr><tr><td style="text-align:center">Postindex(后项索引)</td><td style="text-align:center">mem[base]</td><td style="text-align:center">base + offset</td><td style="text-align:center">LDR R0, [R1], #4</td></tr></tbody></table></div><p>前项索引和后项索引指的是，先访问还是后访问，写回表示写入寄存器。</p><p>Example2：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R0 = 0x00000000R1 = 0X00090000mem32[0x00009000] = 0x01010101mem32[0x00009004] = 0x02020202LDR R0, [R1, #4]!LDR R0, [R1, #4]LDR R0, [R1], #4;Preindexing with writeback;R0 = 0x02020202;R1 = 0x00009004;Preindexing;R0 = 0x02020202;R1 = 0x00009000;Postindexing;R0 = 0x01010101;R1 = 0x00009004</code></pre><h4 id="多个寄存器传输-Multiple-Register-Transfer"><a href="#多个寄存器传输-Multiple-Register-Transfer" class="headerlink" title="多个寄存器传输(Multiple-Register Transfer)"></a>多个寄存器传输(Multiple-Register Transfer)</h4><ul><li>Load-store多个寄存器传输指令可以用一条指令在内存和处理器之间传输多个寄存器</li><li>Syntax<ul><li><strong>\<ldm|stm>{\<cond>}\<addressing mode=""> Rn{!}, \<register>{^}</register></addressing></cond></ldm|stm></strong></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Addressing mode</th><th style="text-align:center">Description</th><th style="text-align:center">Start address</th><th style="text-align:center">End address</th><th style="text-align:center">Rn!</th></tr></thead><tbody><tr><td style="text-align:center">IA</td><td style="text-align:center">increment(增加) after</td><td style="text-align:center">Rn</td><td style="text-align:center">Rn + 4 * N - 4</td><td style="text-align:center">Rn + 4 * N</td></tr><tr><td style="text-align:center">IB</td><td style="text-align:center">increment before</td><td style="text-align:center">Rn + 4</td><td style="text-align:center">Rn + 4 * N</td><td style="text-align:center">Rn + 4 * N</td></tr><tr><td style="text-align:center">DA</td><td style="text-align:center">decrement(减少) after</td><td style="text-align:center">Rn - 4 * N + 4</td><td style="text-align:center">Rn</td><td style="text-align:center">Rn - 4 * N</td></tr><tr><td style="text-align:center">DB</td><td style="text-align:center">decrement before</td><td style="text-align:center">Rn - 4 * N</td><td style="text-align:center">Rn - 4</td><td style="text-align:center">Rn - 4 * N</td></tr></tbody></table></div><p>Example3：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">mem32[0x80018] = 0x03mem32[0x80014] = 0x02mem32[0x80010] = 0x01R0 = 0X00080010R1 = 0X00000000R2 = 0X00000000R3 = 0X00000000LDMIA R0!, {R1-R3}    ;不是R1减去R3,是R1到R3中间的寄存器;结果;R0 = 0x0008001c;R1 = 0x00000001;R2 = 0x00000002;R3 = 0x00000003</code></pre><p>Example4：</p><p><img src="https://i.loli.net/2020/03/19/rdCbxORFeEc7Jy5.png" alt="地址图"></p><pre class=" language-lang-assembly"><code class="language-lang-assembly">;R9 points to start of source data;R10 points to start of destination data;R11 points to end of the sourceloop    LDMIA R9!, {R0-R7}    STMIA R10!, {R0-R7}    CMP R9, R11    BNE loop;这段代码的把R9~R11寄存器的内容添加到内存</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">Addressing mode</th><th style="text-align:center">Description</th><th style="text-align:center">Pop</th><th style="text-align:center">= LDM</th><th style="text-align:center">Push</th><th style="text-align:center">=  STM</th></tr></thead><tbody><tr><td style="text-align:center">FA</td><td style="text-align:center">full ascending(满增)</td><td style="text-align:center">LDMFA</td><td style="text-align:center">LDMDA</td><td style="text-align:center">STMFA</td><td style="text-align:center">STMIB</td></tr><tr><td style="text-align:center">FD</td><td style="text-align:center">full descending(满减)</td><td style="text-align:center">LDMFD</td><td style="text-align:center">LDMIA</td><td style="text-align:center">STMIA</td><td style="text-align:center">STMDB</td></tr><tr><td style="text-align:center">EA</td><td style="text-align:center">empty ascending</td><td style="text-align:center">LDMEA</td><td style="text-align:center">LDMDB</td><td style="text-align:center">STMEA</td><td style="text-align:center">STMIA</td></tr><tr><td style="text-align:center">ED</td><td style="text-align:center">empty descending</td><td style="text-align:center">LDMED</td><td style="text-align:center">LDMIB</td><td style="text-align:center">STMED</td><td style="text-align:center">STMDA</td></tr></tbody></table></div><p>Example5：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R1 = 0x00000002R4 = 0x00000003SP = 0x00080014STMFD SP!, {R1, R4};结果;R1 = Ox00000002;R4 = 0x00000003;SP = 0x0008000C</code></pre><p>Example6：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">R1 = 0x00000002R4 = 0x00000003SP = 0x00080010STMED SP!, {R1, R4};结果;R1 = 0x00000002;R4 = 0x00000003;SP = 0x00080008</code></pre><h3 id="交换指令-Swap-Instructions"><a href="#交换指令-Swap-Instructions" class="headerlink" title="交换指令(Swap Instructions)"></a>交换指令(Swap Instructions)</h3><ul><li>Syntax<ul><li><strong>SWP{B}{\<cond>} Rd, Rm, [Rn]</cond></strong></li></ul></li></ul><p>Example1：</p><pre class=" language-lang-assembly"><code class="language-lang-assembly">mem32[0x9000] = 0x12345678R0 = 0x00000000R1 = 0x11112222R2 = 0x00009000SWP R0, R1, [R2];结果mem32[0x9000] = 0x11112222R0 = 0x12345678R1 = 0x11112222R2 = 0x00009000</code></pre><h3 id="软中断指令-Software-Interrupt-Instruction"><a href="#软中断指令-Software-Interrupt-Instruction" class="headerlink" title="软中断指令(Software Interrupt Instruction)"></a>软中断指令(Software Interrupt Instruction)</h3><ul><li><p>Syntax</p><ul><li>SWI{code} immed_24</li></ul></li><li><p>软件中断指令SWI产生软件异常中断，用来实现用户模式到特权模式的切换。用于在用户模式下对操作系统中特权模式的程序的调用；它将处理器置于管理（_svc）模式，中断矢量地址为0x08</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ARM指令很多，不是一时半会可以记住的，代码敲的多了就有感觉了。想深度学习还是要多看书！</p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式学习笔记(1)</title>
      <link href="2020/05/13/iot/2020/qian-ru-shi-arm-xue-xi-bi-ji-1/"/>
      <url>2020/05/13/iot/2020/qian-ru-shi-arm-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h3 id="计算机系统-Computer-System"><a href="#计算机系统-Computer-System" class="headerlink" title="计算机系统(Computer System)"></a>计算机系统(Computer System)</h3><ul><li>个人计算机(Personal Computer)</li><li>服务器(Server)</li><li>嵌入式系统(Embedded System)</li></ul><p>对比</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Server</th><th style="text-align:center">Personal Computer</th><th style="text-align:center">Embedded System</th></tr></thead><tbody><tr><td style="text-align:center">CPU Capability(CPU能力)</td><td style="text-align:center">High</td><td style="text-align:center">Medium</td><td style="text-align:center">Low / Vary(变化)</td></tr><tr><td style="text-align:center">Power consumption(能量功耗)</td><td style="text-align:center">High</td><td style="text-align:center">Medium / Low</td><td style="text-align:center">Very Low</td></tr><tr><td style="text-align:center">Application area(应用领域)</td><td style="text-align:center">Data Center</td><td style="text-align:center">Personal</td><td style="text-align:center">Vary</td></tr><tr><td style="text-align:center">Reliability(可靠性)</td><td style="text-align:center">High</td><td style="text-align:center">Low</td><td style="text-align:center">Rigorous</td></tr><tr><td style="text-align:center">Cost(费用)</td><td style="text-align:center">High</td><td style="text-align:center">Low</td><td style="text-align:center">Vary</td></tr></tbody></table></div><h3 id="嵌入式系统-Embedded-System"><a href="#嵌入式系统-Embedded-System" class="headerlink" title="嵌入式系统(Embedded System)"></a>嵌入式系统(Embedded System)</h3><h4 id="嵌入式系统定义-Definition"><a href="#嵌入式系统定义-Definition" class="headerlink" title="嵌入式系统定义(Definition)"></a>嵌入式系统定义(Definition)</h4><ul><li><p><a href="[https://zh.wikipedia.org/wiki/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F](https://zh.wikipedia.org/wiki/嵌入式系统">维基百科</a>)</p></li><li><p><a href="[https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F](https://baike.baidu.com/item/嵌入式系统">百度百科</a>)</p></li></ul><h4 id="微控制器-VS-微处理器-Mircocontroller-VS-Microprocessor"><a href="#微控制器-VS-微处理器-Mircocontroller-VS-Microprocessor" class="headerlink" title="微控制器 VS 微处理器(Mircocontroller VS Microprocessor)"></a>微控制器 VS 微处理器(Mircocontroller VS Microprocessor)</h4><ol><li>都有CPU</li><li>微控制器除了有CPU，还集成了ROM，RAM，定时器，I/O端口，串口(serial port)</li></ol><h4 id="嵌入式系统分类"><a href="#嵌入式系统分类" class="headerlink" title="嵌入式系统分类"></a>嵌入式系统分类</h4><ul><li>小规模嵌入式系统(Small-scale)</li><li>中规模嵌入式系统(Medium-scale)</li><li>复杂的嵌入式系统(Sophisticated)</li></ul><h4 id="基本的嵌入式系统组成"><a href="#基本的嵌入式系统组成" class="headerlink" title="基本的嵌入式系统组成"></a>基本的嵌入式系统组成</h4><ul><li>微处理器</li><li>RAM，ROM</li><li>Input/Output(键盘……)</li><li>I/O端口</li><li>网络单元(Networks)</li><li>Timers(定时器)</li></ul><h4 id="两大结构体系"><a href="#两大结构体系" class="headerlink" title="两大结构体系"></a>两大结构体系</h4><ul><li>冯诺依曼结构(Von-Neumann architecture)</li></ul><p><img src="https://imgkr.cn-bj.ufileos.com/bf3673e0-5b62-4499-b474-24c73f515432.svg" alt=""></p><ul><li>哈佛结构(Harvard architecture)</li></ul><p><img src="https://imgkr.cn-bj.ufileos.com/8fcb07b8-98fd-4145-b1a6-4525700fc2aa.svg" alt=""></p><h4 id="两种指令集"><a href="#两种指令集" class="headerlink" title="两种指令集"></a>两种指令集</h4><ul><li><a href="[https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86](https://zh.wikipedia.org/wiki/复杂指令集">复杂指令集(CISC)</a>)</li><li><a href="[https://zh.wikipedia.org/wiki/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86](https://zh.wikipedia.org/wiki/精简指令集">精简指令集(RISC)</a>)</li></ul><p>性能方程</p><script type="math/tex; mode=display">\frac{time}{program} = \frac{time}{cycle} \times \frac{cycle}{instruction} \times \frac{instructions}{program}</script><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">CISC</th><th style="text-align:center">RISC</th></tr></thead><tbody><tr><td style="text-align:center">Instruction set(指令系统)</td><td style="text-align:center">large</td><td style="text-align:center">&lt;100</td></tr><tr><td style="text-align:center">Execution time(执行时间)</td><td style="text-align:center">vary</td><td style="text-align:center">short</td></tr><tr><td style="text-align:center">Instruction Length(指令长度)</td><td style="text-align:center">1~15byte  vary</td><td style="text-align:center">4byte  fixed</td></tr><tr><td style="text-align:center">Addressing mode(寻址模式)</td><td style="text-align:center">many</td><td style="text-align:center">few</td></tr><tr><td style="text-align:center">Memory access(访问内存)</td><td style="text-align:center">directly access</td><td style="text-align:center">load/store</td></tr><tr><td style="text-align:center">Pipeline(传递途径)</td><td style="text-align:center">difficult</td><td style="text-align:center">easy</td></tr></tbody></table></div><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式Arm立即数判定</title>
      <link href="2020/05/13/iot/2020/qian-ru-shi-arm-li-ji-shu-pan-ding/"/>
      <url>2020/05/13/iot/2020/qian-ru-shi-arm-li-ji-shu-pan-ding/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在ARM中，机器指令的格式大致有以下几种：</p><p><img src="https://i.loli.net/2020/03/20/c72UbFNXZRYlOeW.png" alt="ARM指令格式"></p><p>立即寻址的方式</p><p><img src="https://i.loli.net/2020/03/20/tmnH2LwKNMQIYyO.png" alt="立即寻址"></p><h2 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h2><ul><li>在立即寻址，操作数本身直接在指令中给出，取出指令也就获得了操作数，这个操作数也称为立即数。例子如下</li></ul><pre class=" language-lang-assembly"><code class="language-lang-assembly">ADD R0, R1, #0xF      ;R0=R1+15MOV R0, #0x55       ;R0=0x55</code></pre><p>在这两个例子中0xF和0x55就是立即数。(立即数要以#开头)</p><h2 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h2><ul><li>我们知道因为ARM指令长度是32-bit的，所以立即数不可能还有32-bit。</li><li>ARM在指令格式中设定，只能用指令机器码32位中的低12位来表示要操作的常数。</li><li>但是简单的用这12位来表示，显然范围太小了，为了扩展到32-bit，因此使用了构造的方法，在12位中用8位来表示基本数据值，用4位表示移位值，通过用8位基本数据值往右循环移动4位位移值×2次，来表示要操作的常数。</li><li>这里要强调终的循环次数是4位位移值乘以2得到的，所以得到的终循环次数肯定是一个偶数，为什么要乘以2呢，实质还是因为范围不够，4位表示位移次数，大才15次，加上8位数据还是不够32位，这样只能通过ALU的内部结构设计将4位位移次数乘以2，这样就能用12位表示32位常数了。</li></ul><p>具体点的定义：</p><blockquote><p><code>立即数 = immed_8 循环右移 (2 * Rotate_imm)</code><br>如果存在一个 Rotate_imm 能够让该立即数由 immed_8 循环右移 2×Rotate_imm 位（ <strong>偶数位</strong> ）表示，那么这个立即数就是合法的。</p></blockquote><p>那么什么样的立即数才是合法的？</p><h2 id="合法立即数的判断"><a href="#合法立即数的判断" class="headerlink" title="合法立即数的判断"></a>合法立即数的判断</h2><ol><li>把数据转化二进制形式，4位一组，不够的补0</li><li>数1的个数，大于8个肯定不是立即数</li><li>如果小于8个，如果数据是两端为1，中间有连续的大于等于24个0，循环左移4的倍数，使高位全为0<ul><li>比如 <code>1111 0000 0000 0000 0000 0000 0000 1111</code></li></ul></li><li>找到最高位的1，尽可能多的去掉前面的0（去掉的0必须是偶数个）<ul><li>比如 <code>0001 0010 0010</code> ，最高位的1前面有3个0，所以去掉2个0，即 <code>××01 0010 0010</code></li></ul></li><li>找到最低位的1，尽可能多的去掉后面的0（去掉的0必须是偶数个）<ul><li>比如 <code>0001 0010 0010</code> ，最低位的1后面有1个0，所以出掉0个0，即 <code>××01 0010 0010</code></li></ul></li><li>数剩下的位数，如果小于等于8位，那么这个数就是立即数，反之就不是立即数</li></ol><h4 id="举几个例子"><a href="#举几个例子" class="headerlink" title="举几个例子"></a>举几个例子</h4><h5 id="（1）0x4FF"><a href="#（1）0x4FF" class="headerlink" title="（1）0x4FF"></a>（1）0x4FF</h5><ol><li><code>0100 1111 1111</code></li><li>有9个1，大于8，所以不是立即数</li></ol><h5 id="（2）0x122"><a href="#（2）0x122" class="headerlink" title="（2）0x122"></a>（2）0x122</h5><ol><li><code>0001 0010 0010</code></li><li>3个1，小于8</li><li>不满足中间有24个0</li><li>最高位的1前面有3个0，所以去掉2个0，即<code>××01 0010 0010</code></li><li>最低位的1后面又1个0，所以去掉0个0，即<code>××01 0010 0010</code></li><li>剩下<code>××01 0010 0010</code>共10位，大于8，所以不是立即数</li></ol><h5 id="（3）0x234"><a href="#（3）0x234" class="headerlink" title="（3）0x234"></a>（3）0x234</h5><ol><li><code>0010 0011 0100</code></li><li>4个1，小于8</li><li>不满足中间有24个0</li><li>最高位的1前面有2个0，所以去掉2个0，即<code>××10 0011 0100</code></li><li>最低为的1后面又2个0，所以去掉2个0，即<code>××10 0011 01××</code></li><li>剩下的共8位，等于8，是立即数</li></ol><h5 id="（4）0xF000000F"><a href="#（4）0xF000000F" class="headerlink" title="（4）0xF000000F"></a>（4）0xF000000F</h5><ol><li><code>1111 0000 0000 0000 0000 0000 0000 1111</code></li><li>8个1，不大于8</li><li>满足中间有24个0，循环左移4位，使高位全为0，即<code>0000 0000 0000 0000 0000 0000 1111 1111</code></li><li>最高位的1前面有24个0，所以去掉24个0，即<code>×××× ×××× ×××× ×××× ×××× ×××× 1111 1111</code></li><li>最低为的1后面没有0</li><li>剩下的共8位，是立即数</li></ol><h5 id="（5）0x8000007F"><a href="#（5）0x8000007F" class="headerlink" title="（5）0x8000007F"></a>（5）0x8000007F</h5><ol><li><code>1000 0000 0000 0000 0000 0000 0111 1111</code></li><li>8个1，不大于8</li><li>满足中间有24个0，循环左移4位，是高位全为0，即<code>0000 0000 0000 0000 0000 0000 0111 1111 1000</code></li><li>最高位的1前面有24个0，所以去掉24个0，即<code>xxxx xxxx xxxx xxxx xxxx xxxx 0111 1111 1000</code></li><li>最低为的1后面有3个0，所以去掉2个0，即<code>xxxx xxxx xxxx xxxx xxxx xxxx 0111 1111 10xx</code></li><li>剩下的共10位，大于8，不是立即数</li></ol><h3 id="如何规避立即数"><a href="#如何规避立即数" class="headerlink" title="如何规避立即数"></a>如何规避立即数</h3><ul><li>可以通过使用 LDR 伪指令代替<ul><li>例如直接把MOV指令变为， LDR R1，=0x12345678这样编译器就不会报错。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>适合自己的方法才是最好了，真正理解了才能叫懂了！</p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程中</title>
      <link href="2020/05/13/linux/2020/linux-jin-cheng-zhong/"/>
      <url>2020/05/13/linux/2020/linux-jin-cheng-zhong/</url>
      
        <content type="html"><![CDATA[<h3 id="一-Linux进程间通信"><a href="#一-Linux进程间通信" class="headerlink" title="一. Linux进程间通信"></a>一. Linux进程间通信</h3><h4 id="Ⅰ-管道函数"><a href="#Ⅰ-管道函数" class="headerlink" title="Ⅰ. 管道函数"></a>Ⅰ. 管道函数</h4><p>管道是有大小的，通过<code>ulimit -a</code>查看管道大小</p><p><img src="https://imgkr.cn-bj.ufileos.com/5b9f0c3d-2ed4-470f-9400-6e727c54dfb1.png" alt="管道"></p><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 pipe#include <unistd.h>int pipe(int pipefd[2]);</code></pre><ul><li><p>参数</p><ul><li>文件描述符。</li></ul></li><li><p>读管道</p><ul><li>写端全部关闭 ，read读到0，相当于读到文件末尾</li><li>写端没有关闭<ul><li>有数据，read读到数据；</li><li>没数据，read阻塞，fcntl函数可以设置非阻塞。</li></ul></li></ul></li><li>写管道<ul><li>读端全部关闭，产生一个SIGPIPE信号，程序异常终止</li><li>读端未全部关闭<ul><li>管道已满，write阻塞；</li><li>管道未满， write正常写入。</li></ul></li></ul></li><li>管道优点<ul><li>简单</li></ul></li><li>缺点<ul><li>只能有血缘关系的进程通信；</li><li>父子进程只能单方向通信，如果需要双向通信，需要创建多根管道。</li></ul></li></ul><h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><ul><li>简单应用</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <stdio.h>#include <unistd.h>int main() {  int fd[2];  pipe(fd);  pid_t pid = fork();  if (pid < 0) {    perror("fork error:");  } else if (pid == 0) {    printf("I am a child fork, pid = %d, ppid = %d\n", getpid(), getppid());    write(fd[1], "hello", 5);  } else {    printf("I am a parent fork, pid = %d\n", getpid());    char buf[12] = {0};    int ret = read(fd[0], buf, sizeof(buf));    if (ret > 0) {      write(STDOUT_FILENO, buf, ret);    }  }  return 0;}</code></pre><ul><li>实现Linux的shell的管道通信，例如<code>ps -aux | grep zsh</code></li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <stdio.h>#include <unistd.h>int main() {  int fd[2];  pipe(fd);  pid_t pid = fork();  if (pid < 0) {    perror("fork err");  } else if (pid == 0) {    // 子进程负责把ps -aux查询到的内容写到管道里去    printf("I am a child process, pid = %d, ppid = %d\n", getpid(), getppid());    // 子进程只负责写，不要读，所以要关闭读端    close(fd[0]);    // 把输出到屏幕的内容重定向到写端    dup2(fd[1], STDOUT_FILENO);    execlp("ps", "ps", "-aux", NULL);  } else {    // 父进程负责把grep zsh得到的内容输出到屏幕    printf("I am a parent process, pid = %d\n", getpid());    // 父进程只负责读数据    close(fd[1]);    // 输入重定向到读管道    dup2(fd[0], STDIN_FILENO);    execlp("grep", "grep", "zsh", NULL);  }  return 0;}</code></pre><ul><li>两个子进程通信</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <stdio.h>#include <stdlib.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <time.h>#include <unistd.h>int main() {  int fd[2];  pid_t pid;  if (pipe(fd) < 0) {    perror("pipe: ");    exit(1);  }  if ((pid = fork()) < 0) {    perror("fork: ");    exit(1);  } else if (pid == 0) {    close(fd[0]);    dup2(fd[1], STDOUT_FILENO);    execlp("ps", "ps", "-aux", NULL);  }  if ((pid = fork()) < 0) {    perror("fork: ");    exit(1);  } else if (pid == 0) {    close(fd[1]);    dup2(fd[0], STDIN_FILENO);    execlp("grep", "grep", "zsh", NULL);  } else {    close(fd[0]);    close(fd[1]);    for (int i = 0; i < 2; ++i) {      pid_t wpid = wait(NULL);      printf("wpid = %d\n", wpid);    }  }  return 0;}</code></pre><h4 id="Ⅱ-有名管道"><a href="#Ⅱ-有名管道" class="headerlink" title="Ⅱ. 有名管道"></a>Ⅱ. 有名管道</h4><p>FIFO有名管道，可以实现无血缘关系进程通信。</p><ul><li><p>创建一个管道的伪文件</p><ul><li><code>mkfifo + 文件名</code> 命令创建</li><li>也可以用函数<code>int mkfifo(const char *pathname, mod_t mode);</code></li></ul></li><li><p>原理</p><ul><li>内核会针对FIFO文件开辟一个缓冲区，操作FIFO文件，可以操作缓冲区，实现进程间通信，实际上就是文件读写操作。</li><li>用open打开FIFO文件的时候，read端会阻塞等待write端open，write端同理，open也会阻塞等待另外一端read打开。</li></ul></li></ul><h5 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h5><ul><li>有名管道实现两个进程的通信</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// write function#include <fcntl.h>#include <stdio.h>#include <string.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <time.h>#include <unistd.h>int main(int argc, char *argv[]) {  // 确保当前路径有fifo有名管道文件  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  printf("open begin...\n");  int fd = open(argv[1], O_WRONLY);  printf("open end...\n");  char buf[256];  int num = 1;  while (1) {    memset(buf, 0x00, sizeof(buf));    sprintf(buf, "fifo%04d", num++);    write(fd, buf, sizeof(buf));    sleep(1);    if (num == 100) {      break;    }  }  close(fd);  return 0;}</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">// read function#include <fcntl.h>#include <stdio.h>#include <string.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  printf("open begin...\n");  int fd = open(argv[1], O_RDONLY);  printf("open end...\n");  char buf[256];  while (1) {    int ret = read(fd, buf, sizeof(buf));    printf("read: %s\n", buf);    if (ret == 0) {      break;    }  }  close(fd);  return 0;}</code></pre><h4 id="Ⅲ-mmap共享映射区"><a href="#Ⅲ-mmap共享映射区" class="headerlink" title="Ⅲ. mmap共享映射区"></a>Ⅲ. mmap共享映射区</h4><p>Linux提供了内存映射函数mmap，它把文件内容映射到一段内存上(准确说是虚拟内存上)，通过对这段内存的读取和修改, 实现对文件的读取和修改，mmap()系统调用使得进程之间可以通过映射一个普通的文件实现共享内存。</p><p>普通文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问，不需要其他系统调用(read,write)去操作。</p><p><img src="https://imgkr.cn-bj.ufileos.com/3971d173-7e9d-42ec-8a08-020e3b9812cd.png" alt="mmap"></p><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 mmap#include <sys/mman.h>// 创建映射区void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);// 释放映射区int munmap(void *addr, size_t length);</code></pre><ul><li><p>参数</p><ul><li>addr，一般传NULL</li><li>length，映射区长度</li><li>prot<ul><li>PROT_READ，可读</li><li>PROT_WRITE ，可写</li></ul></li><li>flags<ul><li>MAP_SHARED ，共享的， 对内存的修改会影响到源文件，实现通信选共享</li><li>MAP_PRIVATE，私有的</li></ul></li><li>fd<ul><li>文件描述符，open打开一个文件</li></ul></li><li>offset    <ul><li>偏移量</li></ul></li></ul></li><li><p>返回值</p><ul><li>成功，返回可用的内存首地址</li><li>失败， 返回MAP_FAILED</li></ul></li></ul><h5 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h5><ul><li>简单使用</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <string.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  int fd = open(argv[1], O_RDWR);  char *mem = (char *)mmap(NULL, 8, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);  if (mem == MAP_FAILED) {    perror("mmap error:");    return -1;  }  strcpy(mem, "hello");  // 最好哟个mscpy  if (munmap(mem, 8) < 0) {    perror("munmap error:");  }  close(fd);  return 0;}</code></pre><ul><li>父子进程通信</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main() {  int fd = open("./mem.txt", O_RDWR);  int *mem = (int *)mmap(NULL, 8, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);  if (mem == MAP_FAILED) {    perror("mmap error:");    return -1;  }  pid_t pid = fork();  if (pid < 0) {    perror("fork error:");    return -1;  } else if (pid == 0) {    *mem = 100;    printf("child, *mem = %d\n", *mem);    sleep(3);    printf("child, *mem = %d\n", *mem);  } else {    sleep(1);    printf("parent, *mem = %d\n", *mem);    *mem = 1001;    printf("parent, *mem = %d\n", *mem);    wait(NULL);  }  munmap(mem, 8);  close(fd);  return 0;}</code></pre><ul><li>匿名映射</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main() {  int *mem = (int *)mmap(NULL, 8, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON,                         -1, 0);  if (mem == MAP_FAILED) {    perror("mmap error:");    return -1;  }  pid_t pid = fork();  if (pid < 0) {    perror("fork error:");    return -1;  } else if (pid == 0) {    *mem = 100;    printf("child, *mem = %d\n", *mem);    sleep(3);    printf("child, *mem = %d\n", *mem);  } else {    sleep(1);    printf("parent, *mem = %d\n", *mem);    *mem = 1001;    printf("parent, *mem = %d\n", *mem);    wait(NULL);  }  munmap(mem, 8);  return 0;}// 匿名映射，只需要再创建时加上关键字MAP_ANON即可</code></pre><h3 id="二-总结"><a href="#二-总结" class="headerlink" title="二. 总结"></a>二. 总结</h3><p>学习了Linux进程通信，多个进程可以进行“信息交流”，实现了一个多进程复制。</p><p>多进程复制原理(步骤)：</p><ol><li>求出要被复制的文件的大小，分成n份，$part = flen\ /\ n$ , 每个进程完成一部分，除不尽的部分$remain = flen\ \%\ n$</li><li>最后一个进程复制时把剩下的remain也复制了。</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/mman.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 3) {    printf("./a.out strfile dstfile\n");    return -1;  }  // 5进程  int n = 5;  // 打开，要被复制的文件  int fd1 = open(argv[1], O_RDONLY);  if (fd1 < 0) {    perror("open_src:");    exit(1);  }  // 打开，要复制的文件  int fd2 = open(argv[2], O_CREAT | O_RDWR | O_TRUNC, 0666);  if (fd2 < 0) {    perror("open_dst:");    exit(2);  }  // 计算文件大小  int flen = lseek(fd1, 0, SEEK_END);  printf("flen = %d\n", flen);  // 扩展文件大小  ftruncate(fd2, flen);  char *src = (char *)mmap(NULL, flen, PROT_READ, MAP_SHARED, fd1, 0);  if (src == MAP_FAILED) {    printf("mmap_src error:");    exit(3);  }  close(fd1);  char *dst =      (char *)mmap(NULL, flen, PROT_READ | PROT_WRITE, MAP_SHARED, fd2, 0);  if (dst == MAP_FAILED) {    perror("mmap_dst error:");    exit(4);  }  close(fd2);  // 分成part部分，除不尽的留给最后一个进程  int part = flen / n;  int remain = flen % n;  printf("part = %d, remain = %d\n", part, remain);  int i;  pid_t pid;  for (i = 0; i < n; ++i) {    // 创建n个进程    printf("%dth process\n", i);    if ((pid = fork()) == 0) {      break;    }  }  if (n == i) {    // 父进程，需要释放子进程资源    for (int j = 0; j < n; ++j) {      wait(NULL);    }  } else if (i == (n - 1)) {    printf("i = %d\n", i);    // 最后一个子进程,要把除不尽的也拷贝了。    memcpy(dst + i * part, src + i * part, part + remain);  } else if (i == 0) {    printf("i = %d\n", i);    // 第一个子进程，从最初的位置开始拷贝    memcpy(dst, src, part);  } else {    printf("i = %d\n", i);    // 另外的子进程，拷贝    memcpy(dst + i * part, src + i * part, part);  }  // 释放mmap  munmap(src, flen);  munmap(dst, flen);  return 0;}</code></pre><h3 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h3><blockquote><center>丑奴儿</center><center>辛弃疾</center><center>少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。</center><center>而今识尽愁滋味，欲说还休。欲说还休，却道天凉好个秋。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile简单使用</title>
      <link href="2020/05/13/linux/2020/makefile-jian-dan-shi-yong/"/>
      <url>2020/05/13/linux/2020/makefile-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="一-题外话"><a href="#一-题外话" class="headerlink" title="一. 题外话"></a>一. 题外话</h2><h3 id="1-1-c-cc编译流程"><a href="#1-1-c-cc编译流程" class="headerlink" title="1.1 c/cc编译流程"></a>1.1 c/cc编译流程</h3><p>以 <strong>main.cpp</strong> 为例：</p><p><img src="https://imgkr.cn-bj.ufileos.com/c2d179b7-7ea5-4197-8bb8-c1d0196f27e8.png" alt="编译过程"></p><h3 id="1-2-gcc编译参数-部分"><a href="#1-2-gcc编译参数-部分" class="headerlink" title="1.2 gcc编译参数( 部分)"></a>1.2 gcc编译参数( 部分)</h3><p>除了前面的 <code>-E -S -c</code> 以外</p><ul><li><strong>-o</strong> 指定输出的文件名；</li><li><strong>-Wall</strong> 启用所有警告；</li><li><strong>-w</strong> 不产生任何警告；</li><li><strong>-g</strong> 生成调试信息；</li><li><strong>-I</strong> 指定头文件路径；</li><li><strong>-l</strong> 链接共享库，小写的 <strong>l</strong> ；</li><li><strong>-L</strong> 指定库文件路径，大写的 <strong>L</strong> ；</li><li><strong>-D</strong> 定义编译时的宏；</li><li><strong>-Werror</strong> 将所有的警告转换成错误信息；</li><li><strong>-ansi</strong> 只支持 ANSI 标准的 C 语法；</li><li><strong>-fexec-charset=GBK</strong> <strong>bin</strong> 文件为 <strong>GBK</strong> 编码。</li></ul><p>所有的参数可见 <a href="https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html">Option Summary</a></p><h3 id="1-3-静态库和动态库"><a href="#1-3-静态库和动态库" class="headerlink" title="1.3 静态库和动态库"></a>1.3 静态库和动态库</h3><p><strong>windows</strong> 下后缀名 <strong>.lib</strong> (静态库)， <strong>.dll</strong> (动态库)</p><p><strong>linux</strong> 下后缀名 <strong>.a</strong> (静态库)， <strong>.so</strong> (动态库)</p><p>只介绍 <strong>linux</strong> 下的库文件制作</p><h4 id="1-3-1-静态库制作"><a href="#1-3-1-静态库制作" class="headerlink" title="1.3.1 静态库制作"></a>1.3.1 静态库制作</h4><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p><strong>“lib[your_library_name].a”</strong> ，中间是静态库名字。</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ul><li>先编译成目标文件<ul><li><strong>g++ -c main.cpp</strong></li></ul></li><li>通过 <strong>ar</strong> 工具将目标文件打包成 <strong>.a</strong> 静态库文件<ul><li><strong>ar -crv libstaticmain.a main.o </strong></li></ul></li></ul><p>用 <strong>nm</strong> 可查看静态库内容。</p><h4 id="1-3-2-动态库制作"><a href="#1-3-2-动态库制作" class="headerlink" title="1.3.2 动态库制作"></a>1.3.2 动态库制作</h4><h5 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h5><p><strong>“lib[your_library_name].so”</strong> ，中间是静态库名字。</p><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><ul><li>创建与地址无关的编译程序<ul><li><strong>g++ -fPIC -c main.c</strong></li></ul></li><li>打包为动态库(共享库)<ul><li><strong>gcc -shared -o libdymain.so main.o</strong></li></ul></li></ul><p>静态库使用和动态库是一样的，但是执行的时候找不到动态库。</p><p>解决办法：</p><ul><li>拷贝到系统的库路径下，不推荐；</li><li>修改 <strong>LD_LIBRARY_PATH</strong> 环境变量，将库所在的路径添加到环境变量中；</li><li>添加库路径到 <strong>/etc/ld.so.conf</strong> ，运行 <strong>sudo ldconfig -v</strong> ( <strong>-v</strong> 可加可不加 )，该命令会重建 <strong>/etc/ld.so.cache</strong> 文件。</li></ul><p>详细解释可以参考 <a href="https://www.cnblogs.com/skynet/p/3372855.html">C++静态库与动态库</a></p><h2 id="二-makefile格式"><a href="#二-makefile格式" class="headerlink" title="二. makefile格式"></a>二. makefile格式</h2><blockquote><pre class=" language-lang-bash"><code class="language-lang-bash"><target> : <prerequisites> [tab]  <commands></code></pre></blockquote><p><strong>target</strong> 目标，  <strong>prerequisites</strong>  条件， <strong>commands</strong> 命令 。</p><p>目标不能省略，条件和命令都可以省略。</p><h3 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h3><p>目标通常是文件名，表明 <strong>make</strong> 要构建的对象。目标可以有多个，中间用空格分开。</p><p>为了防止目标和文件名冲突，产生了伪目标( <strong>phony target</strong> )</p><p>比如：</p><pre class=" language-lang-bash"><code class="language-lang-bash">clean:    rm -r *.o</code></pre><p>如果当前路径下有个叫 <strong>clean</strong> 的文件，那么使用 <strong>make clean</strong> 就无法生效了。</p><p>这时添加伪目标即可解决。</p><pre class=" language-lang-bash"><code class="language-lang-bash">.PHONY : clean</code></pre><p>伪目标可以有多个，中间用空格隔开。</p><p><strong>make</strong> 没有指定目标，默认执行第一个。</p><h3 id="2-2-条件"><a href="#2-2-条件" class="headerlink" title="2.2 条件"></a>2.2 条件</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 <strong>last-modification</strong> 时间戳比目标的时间戳新），”目标”就需要重新构建。</p><h3 id="2-3-命令"><a href="#2-3-命令" class="headerlink" title="2.3 命令"></a>2.3 命令</h3><p>命令（ <strong>commands</strong> ）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p><h2 id="三-两种常用的makefile书写方式"><a href="#三-两种常用的makefile书写方式" class="headerlink" title="三. 两种常用的makefile书写方式"></a>三. 两种常用的makefile书写方式</h2><h3 id="3-1-编译多文件"><a href="#3-1-编译多文件" class="headerlink" title="3.1 编译多文件"></a>3.1 编译多文件</h3><pre class=" language-lang-bash"><code class="language-lang-bash">all : appcc = g++include = ../Include.PHONY : clean allsrc = $(wildcard *.cc)obj = $(patsubst %.cc, %.o, $(src))app : $(obj)    $(cc) -o app -I $(include) $(obj)%.o : %.cc    $(cc) -c $< -I $(include) -o $@clean:    rm -f *.o    rm -f app</code></pre><p>这里的 <strong>wildcard</strong> 是 <strong>makefile</strong> 的内置函数，找出所有的 <strong>.cc</strong> 文件，赋值给变量 <strong>src</strong> 。</p><p><strong>patsubst</strong> 函数用于模式匹配的替换，它需要 <strong>3</strong> 个参数：第一个是一个需要匹配的式样，第二个表示用什么来替换它，第三个是一个需要被处理的由空格分隔的字列。</p><p> <strong>%.o : %.cc</strong> 用到了 <strong>makefile</strong> 的模式匹配</p><p>更多可以参考 <a href="http://www.gnu.org/software/make/manual/html_node/Functions.html">8 Functions for Transforming Text</a></p><p><strong>$&lt;</strong> 和 <strong>$@</strong> 是 <strong>makefile</strong> 的自动变量：</p><ul><li><strong>$@</strong><ul><li>$@指代当前目标，就是Make命令当前构建的那个目标。</li></ul></li><li><strong>$&lt;</strong><ul><li>$&lt; 指代第一个前置条件。</li></ul></li><li><strong>$?</strong><ul><li>$? 指代比目标更新的所有前置条件，之间以空格分隔。</li></ul></li><li><strong>$^</strong><ul><li>$^ 指代所有前置条件，之间以空格分隔。</li></ul></li><li><strong>$*</strong><ul><li>$* 指代匹配符 % 匹配的部分。</li></ul></li></ul><p>更多可以参考 <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">10.5.3 Automatic Variables</a></p><h3 id="3-2-生成多个可执行文件"><a href="#3-2-生成多个可执行文件" class="headerlink" title="3.2 生成多个可执行文件"></a>3.2 生成多个可执行文件</h3><pre class=" language-lang-bash"><code class="language-lang-bash">all : hello worldcc = g++include = ../Include.PHONY : all cleanhello : hello.o    $(cc) -o hello -I $(include) hello.oworld : world.o    $(cc) -o world -I $(include) world.ohello.o : hello.cc    $(cc) -c hello.cc -I $(include)world.o : world.cc    $(cc) -c world.cc -I $(include)clean :    rm -f *.o    rm -f hello world</code></pre><p>更详细可参考 <a href="http://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学会 <strong>makefile</strong> 对以后的编程还是有很大帮助的，可以大大提高自己编写代码的效率。</p><blockquote><p><a href="https://baike.baidu.com/item/makefile">Linux 环境下的程序员如果不会使用GNU make来构建和管理自己的工程，应该不能算是一个合格的专业程序员，至少不能称得上是 Unix程序员。</a></p></blockquote><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>青玉案·版本二</center><center>贺铸</center><center>凌波不过横塘路，但目送，芳尘去。</center><center>锦瑟华年谁与度？月桥花院，锁窗朱户，只有春知处。</center><center>碧云冉冉蘅(héng)皋(gāo)暮，彩笔新题断肠句。</center><center>试问闲情都几许？一川烟草，满城风絮，梅子黄时雨。</center><center>青玉案·版本一</center><center>贺铸</center><center>凌波不过横塘路，但目送，芳尘去。</center><center>锦瑟华年谁与度？月台花榭，锁窗朱户，只有春知处。</center><center>碧云冉冉蘅皋暮，彩笔新题断肠句。</center><center>试问闲愁都几许？一川烟草，满城风絮，梅子黄时雨。</center></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04安装</title>
      <link href="2020/05/13/linux/2020/ubuntu18.04-an-zhuang/"/>
      <url>2020/05/13/linux/2020/ubuntu18.04-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>WSL就是Windows Subsystem for Linux（Windows系统的Linux子系统），因为依赖于win10，所以“子系统”会受到一些限制。</p><p>使用方法：</p><p>打开控制面板</p><p><img src="https://img-blog.csdnimg.cn/20190827093214371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190827093327299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190827093446629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2019082709353178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>按照提示重启就好了，要是没有这个选项，就说明系统不支持，建议升级系统。</p><p>重启后打开微软自带的应用商店，搜索WSL</p><p><img src="https://img-blog.csdnimg.cn/20190827093830548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190827093907882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选择一个，下载好了，运行就会自动安装的。</p><p>设置超级用户密码：<code>sudo passwd</code></p><p>普通用户和超级用户切换</p><p>超级用户-&gt;普通用户：<code>su 用户名</code></p><p>普通用户-&gt;超级用户：<code>su</code></p><p>换源可以参考：</p><p>更换字体不成功的情况可以参考：<a href="https://blog.csdn.net/qq_43826212/article/details/100069168">传送门</a></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程</title>
      <link href="2020/05/13/linux/2020/linux-jin-cheng/"/>
      <url>2020/05/13/linux/2020/linux-jin-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一-操作系统小知识"><a href="#一-操作系统小知识" class="headerlink" title="一. 操作系统小知识"></a>一. 操作系统小知识</h2><p>注：此笔记的重点不是讲操作系统，故操作系统知识比较粗浅，只是介绍。</p><h3 id="1-进程和程序"><a href="#1-进程和程序" class="headerlink" title="1. 进程和程序"></a>1. 进程和程序</h3><ul><li>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源。</li><li>进程，是活跃的（动态的）的程序，占用系统资源，在内存中执行。进程是分配系统资源的基本单位。</li><li>区别：<ul><li>程序是静态的，进程是动态的。</li><li>程序一般保存在磁盘中，不占用系统资源，进程会占用系统资源。</li><li>一个程序可以对应多个进程，一个进程可以执行一个或多个程序。</li><li>进程具有并发性，而程序没有。</li><li>程序没有生命周期，进程有生命周期（创建，执行，撤销等）。</li></ul></li></ul><h3 id="2-多道程序"><a href="#2-多道程序" class="headerlink" title="2. 多道程序"></a>2. 多道程序</h3><ul><li>多道程序设计是指在内存同时放若干道程序，使它们在系统中并发执行，共享系统中的各种资源。当一道程序暂停执行时，CPU立即转去执行另一道程序。</li><li>宏观并行，微观串行。</li></ul><h3 id="3-进程状态转换"><a href="#3-进程状态转换" class="headerlink" title="3. 进程状态转换"></a>3. 进程状态转换</h3><p><img src="https://imgkr.cn-bj.ufileos.com/79370c2a-d150-4882-bf94-ab5a6d93053c.jpg" alt="进程状态转换图"></p><h3 id="4-PCB-进程控制块"><a href="#4-PCB-进程控制块" class="headerlink" title="4. PCB(进程控制块)"></a>4. PCB(进程控制块)</h3><ul><li>PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。</li><li>PCB主要内容：<ul><li>进程ID，系统中每一个程序都有唯一的一个id，在C/C++中用pid_t表示，也就是一个非负整数。</li><li>进程状态，运行，就绪，阻塞，表示进程的运行情况。</li><li>CPU寄存器，进程切换，中断时需要保护和恢复的一些CPU寄存器。</li></ul></li><li>在linux下查看PCB信息：<ul><li>查找进程控制块信息 <code>sudo grep -rn "struct task_struct {" /usr/</code></li></ul></li></ul><h2 id="二-Linux下进程学习"><a href="#二-Linux下进程学习" class="headerlink" title="二. Linux下进程学习"></a>二. Linux下进程学习</h2><h3 id="1-fork函数"><a href="#1-fork函数" class="headerlink" title="1. fork函数"></a>1. fork函数</h3><p>创建一个新进程</p><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 fork#include <sys/types.h>#include <unistd.h>pid_t fork(void);</code></pre><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>失败返回-1</li><li>成功，两次返回<ul><li>父进程返回子进程 id </li><li>子进程返回0</li></ul></li></ul><h3 id="2-getpid函数"><a href="#2-getpid函数" class="headerlink" title="2. getpid函数"></a>2. getpid函数</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 getpid#include <sys/types.h>#include <unistd.h>pid_t getpid(void); // 获得当前进程的id</code></pre><h3 id="3-getppid函数"><a href="#3-getppid函数" class="headerlink" title="3. getppid函数"></a>3. getppid函数</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 getppidpid_t getppid(void); // 获得父进程的id</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main() {  pid_t pid = fork();  if (pid < 0) {    perror("fork error");    exit(1);  } else if (pid == 0) {    // 子进程    printf("我是子进程, 进程id = %d, 父进程id = %d\n", getpid(), getppid());    while (1) {      sleep(1);    }  } else {    // 父进程    printf("子进程id = %d, 进程id = %d, 父进程id = %d\n", pid, getpid(),           getppid());    while (1) {      sleep(1);    }  }  return 0;}</code></pre><p>这里为什么要用设置两个死循环，稍后会讲。</p><p>通过<code>ps -aux</code>找到进程id，<code>kill PID</code>来杀死进程，这样进程资源由<code>init</code>进程释放。</p><h3 id="关于fork小题目"><a href="#关于fork小题目" class="headerlink" title="关于fork小题目"></a>关于fork小题目</h3><blockquote><p>执行如下代码时，系统中最多能产生的进程数为（）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int main() {    int i;    for (i = 0; i < 3; ++i) {        if (fork() > 0) {            break;        }    }}</code></pre><p>A. 8个            B. 5个            C.4个            D. 3个</p></blockquote><p>通过代码得知，当fork的返回值大于0时，也就是父进程跳出for语句，感觉应该是选C. 4个</p><p>我们通过代码验算下，是否正确。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <stdio.h>#include <sys/types.h>#include <unistd.h>int main() {  int i;  for (i = 0; i < 3; ++i) {    if (fork() > 0) {      break;    }  }  while (1) {    sleep(1);  }  return 0;}</code></pre><p>我们让程序产生的所有进程都进入死循环，然后我们通过<code>ps -aux</code> 或者<code>ps -ajxf</code></p><p><img src="https://imgkr.cn-bj.ufileos.com/52200da3-d1f2-4c08-99a3-256bbae73061.png" alt=""></p><p>可以看到，的确只有四个进程。</p><p><code>ps -aux</code>和<code>ps -ajxf</code>有点小区别。</p><p><code>ps -ajxf</code>显示信息更全面，以目录树形式显示</p><ul><li>父进程id <strong>ppid</strong> </li><li>当前进程id <strong>pid</strong> </li><li>组进程id <strong>pgid</strong> </li><li>会话id <strong>sid</strong> </li><li>登录者终端机的位置(与终端无关用？显示) <strong>TTY</strong> <ul><li>一般linux允许有7个TTY，可以用 <code>Ctrl + Alt + Fn</code> 来切换，n是要切换的终端号，比如 <code>Ctrl + Alt + F1</code> 切换到1号终端。</li><li>还可以用 <code>chvt n</code> 来切换，比如 <code>chvt 1</code> 就是切换到1号终端。</li></ul></li><li>进程连接到的tty(终端)所在的前台进程组的ID <strong>tpgid</strong> </li><li>进程状态字段 <strong>stat</strong> <ul><li>D 不可中断的休眠，通常是I/O；</li><li>R 运行，正在运行或者在运行队列中等待；</li><li>S 休眠，在等待某个事件，信号，这是大写的S；</li><li>T 停止，进程接收到信息SIGSTOP，SIGSTP，SIGTIN，SIGTOU信号；</li><li>X 死掉的进程，不应该出现；</li><li>Z 僵尸进程；</li><li>&lt;  高优先级；</li><li>N 低优先级；</li><li>L 有页面在内存中被锁存。用于实时或者自定义IO；</li><li>s 进程领导者，其有子进程，这是小写s；</li><li>l 多线程；</li><li>+ 位于前台进程组；</li><li>通过<code>man ps</code>查找 <strong>STAT</strong> 获取更详细的信息。</li></ul></li><li>用户表示号 <strong>uid</strong> </li></ul><p><img src="https://imgkr.cn-bj.ufileos.com/5923248e-77ff-47a9-8a48-a768fbaee0b6.png" alt=""></p><h3 id="4-孤儿进程"><a href="#4-孤儿进程" class="headerlink" title="4. 孤儿进程"></a>4. 孤儿进程</h3><p>孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。</p><p>比如我们前面写的实例代码，我们改成如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main() {  pid_t pid = fork();  if (pid < 0) {    perror("fork error");    exit(1);  } else if (pid == 0) {    // 子进程    printf("我是子进程, 进程id = %d, 父进程id = %d\n", getpid(), getppid());    while (1) {      printf("我是子进程..., pid = %d, ppid = %d\n", getpid(), getppid());      sleep(1);    }  } else {    // 父进程    printf("子进程id = %d, 进程id = %d, 父进程id = %d\n", pid, getpid(),           getppid());  }  return 0;}</code></pre><p><img src="https://imgkr.cn-bj.ufileos.com/b7ba31f6-0b02-4208-90d7-89f3330e412d.png" alt=""></p><p>我们可以看到，该子进程一直在运行，通过 <strong>crtl + z</strong> 或者 <strong>ctrl + c</strong> 是杀不死的。</p><p>用<code>ps -aux</code>看看情况。</p><p><img src="https://imgkr.cn-bj.ufileos.com/628bb3c4-e036-46e7-b84f-130f047f4da6.png" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2fa6a33e-5c0a-47b0-bb10-7665f9cd4d6e.png" alt=""></p><p>看到他的父进程已经是 <a href="https://zh.wikipedia.org/wiki/Systemd">systmd</a>了，所以用 <strong>ctrl + z</strong> 和 <strong>ctrl + c</strong> 是杀不死的，已经不归 <strong>shell</strong> 管了。</p><h3 id="5-僵尸进程"><a href="#5-僵尸进程" class="headerlink" title="5. 僵尸进程"></a>5. 僵尸进程</h3><p>一个进程结束了，父进程没有释放其资源。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main() {  pid_t pid = fork();  if (pid < 0) {    perror("fork err");    exit(1);  } else if (pid == 0) {    printf("I am child process, pid = %d, ppid = %d\n", getpid(), getppid());    sleep(2);    printf("I am child, and i will die");  } else {    // 防止父进程先结束，产生孤儿进程。    while (1) {      printf("I am father process, pid = %d\n", getpid());      sleep(1);    }  }  // 杀死僵尸进程方法，把其父进程kill即可  return 0;}</code></pre><p>运行程序，通过<code>ps -aux</code>看看什么情况</p><p><img src="https://imgkr.cn-bj.ufileos.com/8426c499-cdce-4c54-a9d5-34fc5c5d1949.png" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/f62a2474-c842-46bb-8939-51dc75d62378.png" alt=""></p><p>的确 <strong>STAT</strong> 标记为 <strong>Z</strong> ，此时产生了僵尸进程。</p><p>我们通过干掉父进程<code>kill 8433</code></p><p><img src="https://imgkr.cn-bj.ufileos.com/274323a5-f080-4385-9abf-54d0e418df9d.png" alt=""></p><p>看到僵尸进程已经没了，因为干掉父进程，僵尸进程由<code>init</code>释放了。</p><h3 id="6-wait函数"><a href="#6-wait函数" class="headerlink" title="6. wait函数"></a>6. wait函数</h3><p>僵尸进程危害还是挺大的，我们可以通过 <strong>wait</strong> 函数来释放子进程资源</p><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 wait#include <sys/types.h>#include <sys/wait.h>pid_t wait(int *wstatus);</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>wstatus，这是一个传出参数，通过这个参数，我们可以判断子进程是怎么结束的。</li></ul><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功，返回终止的子进程id；</li><li>失败，返回-1。</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>阻塞等待，如果子进程没结束，会陷入阻塞，直到子进程结束；</li><li>回收子进程资源；</li><li>查看子进程结束原因。</li></ul><h4 id="子进程死亡原因"><a href="#子进程死亡原因" class="headerlink" title="子进程死亡原因"></a>子进程死亡原因</h4><ul><li>正常死亡 <strong>WIFEXITED</strong> <ul><li>如果 <strong>WIFEXITED</strong> 为真，使用 <strong>WEXITSTATUS</strong> 得到退出状态。</li></ul></li><li>非正常死亡 <strong>WIFSIGNALED</strong> <ul><li>如果 <strong>WIFSIGNALED</strong> 为真，使用 <strong>WTERMSIG</strong> 得到信号。</li></ul></li></ul><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main() {  pid_t pid = fork();  if (pid < 0) {    perror("fork err");    exit(1);  } else if (pid == 0) {    printf("I am child, will die, pid = %d, ppid = %d\n", getpid(), getppid());    sleep(2);    while (1) {      printf("I am child, please die me\n");      sleep(1);    }    // return 101;    // exit(102);  } else {    printf("I am parent, wait child die!\n");    int status;    // 子进程没死，会陷入阻塞    pid_t wpid = wait(&status);    printf("wait ok, wpid = %d, pid = %d\n", wpid, pid);    if (WIFEXITED(status)) {      printf("child exit with %d\n", WEXITSTATUS(status));    }    if (WIFSIGNALED(status)) {      printf("child exit by %d\n", WTERMSIG(status));    }  }  return 0;}</code></pre><p>子进程是通过return 或 exit 结束的，返回对应的return 或 exit 后的数字。</p><p>通过kill杀死的，返回kill参数。</p><h3 id="7-waitpid函数"><a href="#7-waitpid函数" class="headerlink" title="7. waitpid函数"></a>7. waitpid函数</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">man 2 wait#include <sys/types.h>#include <sys/wait.h>pid_t waitpid(pid_t pid, int *wstatus, int options);</code></pre><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li>pid<ul><li>&lt; -1 回收一组id；</li><li>-1 任意回收；</li><li>0 回收和调用进程组id相同组内的子进程；</li><li>&gt; 0 回收指定进程。</li></ul></li><li>wstatus同wait</li><li>options<ul><li>0，与wait函数相同，产生阻塞；</li><li>WNOHANG， 如果当前没有子进程退出，会立刻返回。</li></ul></li></ul><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><ul><li>如果设置了 <strong>WNOHANG</strong> ，那么如果没有子进程退出，返回0<ul><li>如果有子进程退出，返回退出子进程的pid。</li></ul></li><li>失败返回-1，没有子进程</li></ul><h4 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main() {  pid_t pid = fork();  if (pid < 0) {    perror("fork err");    exit(1);  } else if (pid == 0) {    printf("I am child process, pid = %d, ppid = %d\n", getpid(), getppid());    sleep(2);  } else {    printf("I am pather process, pid = %d, ppid = %d\n", getpid(), getppid());    // 参数WNOHANG,不等待子进程结束，也就是不陷入阻塞态    int ret;    while ((ret = waitpid(-1, NULL, WNOHANG)) == 0) {      sleep(1);    }    printf("ret = %d\n", ret);    // 防止产生孤儿进程    while (1) {      sleep(1);    }  }  return 0;}</code></pre><h3 id="8-多个子进程回收"><a href="#8-多个子进程回收" class="headerlink" title="8. 多个子进程回收"></a>8. 多个子进程回收</h3><p> 创建了几个子进程，就用几次循环，用wait释放资源即可。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main() {  int n = 5;  int i;  pid_t pid;  for (i = 0; i < n; ++i) {    pid = fork();    if (pid == 0) {      printf("I am a child process, pid = %d, ppid = %d\n", getpid(),             getppid());      break;    }  }  sleep(i);  if (i == 5) {    printf("I am a parent process, pid = %d\n", getpid());    for (i = 0; i < n; ++i) {      pid_t wpid = wait(NULL);      printf("wpid = %d\n", wpid);    }    // 防止产生孤儿进程    while (1) {      sleep(1);    }  }  return 0;}</code></pre><p>​    使用waitpid同理</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>int main() {  int n = 5;  int i;  pid_t pid;  for (i = 0; i < n; ++i) {    pid = fork();    if (pid < 0) {      perror("fork err");      exit(1);    }    if (pid == 0) {      printf("I am child process, pid = %d, ppid = %d\n", getpid(), getppid());      break;    }  }  sleep(i);  if (i == 5) {    printf("I am parent process, pid = %d\n", getpid());    while (1) {      pid_t wpid = waitpid(-1, NULL, WNOHANG);      if (wpid == -1) {        break;      } else if (wpid > 0) {        printf("wpid = %d\n", wpid);      }    }    // 防止产生孤儿进程    while (1) {      sleep(1);    }  }  return 0;}</code></pre><h3 id="9-补充Linux的API函数"><a href="#9-补充Linux的API函数" class="headerlink" title="9. 补充Linux的API函数"></a>9. 补充Linux的API函数</h3><h4 id="execl函数族"><a href="#execl函数族" class="headerlink" title="execl函数族"></a>execl函数族</h4><pre class=" language-lang-bash"><code class="language-lang-bash">man execl#include <unistd.h>int execl(const char *pathname, const char *arg, ...                       /* (char  *) NULL */);int execlp(const char *file, const char *arg, ...                       /* (char  *) NULL */);</code></pre><p>只抽取了两个比较常用的。</p><p>execlp跟execl的区别：</p><ul><li>execl要使用PATH环境变量，而execlp不要使用完整加路径。</li></ul><h5 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h5><ul><li>pathname，命令的PATH</li><li>file，命令</li><li>arg，参数，可以有多个，最后一个为NULL，表示参数已经添加完。</li></ul><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><ul><li>只有发生错误时才返回，设置error。</li></ul><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul><li>在调用进程内部执行一个可执行文件。可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。</li></ul><h5 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h5><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <stdlib.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main() {  execlp("ls", "ls", "-lrt", NULL);  execl("/bin/ls", "ls", "-lrt", NULL);  perror("error fault");  return 0;}</code></pre><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>学习是不断积累，写笔记能让巩固自己所学知识，也希望可以帮助到大家。</p><p>我们看到每次我们都要让父进程进入死循环，目的是为了防止父进程先结束，产生了孤儿进程，难道就没有其它容易的解决办法吗？</p><p>关注我，下次带你解决这个问题。</p><h2 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h2><blockquote><center>虞美人·听雨</center><center>蒋捷</center><center>少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低，断雁叫西风。</center><center>而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前，点滴到天明。</center><center></center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用masm工具和DOCBOX在win10上进行汇编</title>
      <link href="2020/05/13/linux/2020/li-yong-masm-gong-ju-he-docbox-zai-win10-shang-jin-xing-hui-bian/"/>
      <url>2020/05/13/linux/2020/li-yong-masm-gong-ju-he-docbox-zai-win10-shang-jin-xing-hui-bian/</url>
      
        <content type="html"><![CDATA[<p>windows XP直接用cmd就可以了，win10用户也可也在虚拟机上装个XP进行汇编！</p><p>接下来介绍利用masm工具和DOCBOX在win10上进行汇编</p><h1 id="1-DOCBOX下载地址"><a href="#1-DOCBOX下载地址" class="headerlink" title="1.DOCBOX下载地址"></a>1.<a href="https://www.dosbox.com/download.php?main=1">DOCBOX下载地址</a></h1><p>MASM32下载地址</p><p><a href="http://www.masm32.com/">官网</a></p><p>网盘地址</p><p>链接：<a href="https://pan.baidu.com/s/172uIe8oT28-r27I93KbKxA">https://pan.baidu.com/s/172uIe8oT28-r27I93KbKxA</a> </p><p>提取码：ugyp </p><h1 id="2-安装DOCBOX"><a href="#2-安装DOCBOX" class="headerlink" title="2.安装DOCBOX"></a>2.安装DOCBOX</h1><p>1）运行，一路next即可。</p><p>2）在另一个盘创建个专门汇编的文件夹，列如：E:\Assembly。</p><p>3）把网盘下载的masm工具放该文件夹，或者直接解压官网的masm32v11r，安装后直接用gedit.exe程序编写、编译和链接asm汇编程序。</p><p>4）点击桌面的DOCbox0.74-3。</p><pre><code>mount c E:\Assemblyc:cd 汇编文件目录</code></pre><p>5）不想每次都输入上步骤，可这样</p><p>在DOCBOX安装目录下找到DOSBox 0.74 Options.bat</p><p>在弹出来的文档最下面输入</p><pre><code>mount c E:\Assemblypath=%path%; \asm</code></pre><p>asm是在Assembly下保存汇编的文件夹，另外一个masm是用来保存汇编工具的。</p><p>接下来就可以进行汇编了。</p><p>alt+enter全屏模式！</p><p>列如</p><pre><code>cd /asmmasm test,asm敲入回车敲入回车敲入回车link test.objdebug test.exe</code></pre><p>详情可以参考<a href="https://blog.csdn.net/YuzuruHanyu/article/details/80287419">传送门</a></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux终端命令ch命令(4)</title>
      <link href="2020/05/13/linux/2020/mei-tian-yi-ge-linux-zhong-duan-ming-ling-ch-ming-ling-4/"/>
      <url>2020/05/13/linux/2020/mei-tian-yi-ge-linux-zhong-duan-ming-ling-ch-ming-ling-4/</url>
      
        <content type="html"><![CDATA[<p><strong><em>好读书，不求甚解；每有会意，便欣然忘食。</em></strong> </p><p><em>ch</em>命令指的是 <strong>chgrp,chown,chmod</strong> 这一组命令! 因为分开缺少连贯性,所以凑一起了。</p><ul><li><strong>chgrp</strong> 修改文件所属的用户组</li><li><strong>chown</strong> 修改文件的拥有者</li><li><strong>chmod</strong> 修改文件的属性</li></ul><p>chgrp和chown用法基本一致。</p><pre class=" language-lang-bash"><code class="language-lang-bash">chgrp [-R] dirname/filename ...chown [-R] 账号名称 文件或目录chown [-R] 账号名称:用户组名称 文件或目录chmod [-R] xyz 文件或者目录</code></pre><p>-R进行递归(recursive)修改,即连同子目录下的所有文件,目录都更新成为这个用户组(用户)，简言之,就是修改目录内所有文件。</p><p><img src="https://img-blog.csdnimg.cn/20200224134116955.png" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20200224133722573.png" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/2020022413385138.png" alt="在这里插入图片描述"> </p><p><em>用户组信息在  <strong>/etc/group</strong> 下。</em>   <em>用户信息在  <strong>/home</strong> 下,或者到  <strong>/etc/passwd</strong> 也可以查看。</em> </p><p> 如图,我的linux中我创建了两个用户以及两个同名的用户组。</p><p><img src="https://img-blog.csdnimg.cn/20200224134751654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p> <strong>chmod</strong> 用法 1.py文件的文件权限字符为【-rw-r- -r- -】 这九个权限三个三个一组，我们可以用数字来代表各个权限。</p><ul><li>r：4</li><li>w：2</li><li>x：1</li></ul><p>例如，我们要把1.py权限修改为【-rwxrwxrwx】 </p><p><img src="https://img-blog.csdnimg.cn/20200224140054988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p><strong>chmod</strong>还有如下使用方法：</p><div class="table-container"><table><thead><tr><th style="text-align:center">chmod<br></th><th style="text-align:center">u<br> g <br>  o <br>  a <br></th><th style="text-align:center">+(加入)<br> -(移除)<br> =(设置) <br></th><th style="text-align:center">r<br>   w <br>   x <br></th><th style="text-align:center">文件或目录</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><ul><li>u(user)用户权限</li><li>g(group)组成员权限</li><li>o(others)其它用户权限</li><li>a(all)所有的 <img src="https://img-blog.csdnimg.cn/20200224143227333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>每天一个linux终端命令,积少成多,希望大家越来越优秀!</p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux终端命令ls命令(3)</title>
      <link href="2020/05/13/linux/2020/mei-tian-yi-ge-linux-zhong-duan-ming-ling-ls-ming-ling-3/"/>
      <url>2020/05/13/linux/2020/mei-tian-yi-ge-linux-zhong-duan-ming-ling-ls-ming-ling-3/</url>
      
        <content type="html"><![CDATA[<p><strong><em>凡心所向，素履可往</em></strong></p><p><strong>ls</strong> 即list,译为列举。</p><p><strong>ls</strong> 可带参数,也可不带参数。可带的参数很多,这里只列举最常用的几种,有特殊需求可使用man或者—help命令进行参考。</p><pre class=" language-lang-bash"><code class="language-lang-bash">man ls或者ls --helpls [-lha]</code></pre><p>参数介绍:</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>参数</strong></th><th style="text-align:center"><strong>功能</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>-l</strong></td><td style="text-align:center"><strong>列出文件和文件夹的详细信息</strong></td></tr><tr><td style="text-align:center"><strong>-h</strong></td><td style="text-align:center"><strong>以人性化的方式显示文件大小(搭配-l使用)</strong></td></tr><tr><td style="text-align:center"><strong>-a</strong></td><td style="text-align:center"><strong>显示所有文件及目录(包括隐藏目录和文件)</strong></td></tr></tbody></table></div><p>范例:</p><pre class=" language-lang-bash"><code class="language-lang-bash">ls -lls -als -lhls -lha</code></pre><p><img src="https://img-blog.csdnimg.cn/20200223163213504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p>请看红色方框部分,所谓以人性化方式显示文件夹大小就是把每个文件的大小换算成我们熟悉的单位(比如K,M,G)。 </p><p><img src="https://img-blog.csdnimg.cn/20200223163413713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p>不带任何参数的ls是不能显示隐藏文件(目录)的(linux中以.开头的基本上就是隐藏文件(目录),加上-a参数即可显示隐藏文件(目录)。 </p><p>另外,一个点（.）在linux中表示当前目录,两个点（. .）在linux中表示上一级目录。（-）可以在两个最近的两个命令间进行切换。</p><p> <img src="https://img-blog.csdnimg.cn/20200223164628966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p>第一部分的代表的意思： 比如(-rwxrwxrwx)一共有10个字符；</p><ul><li>第一个字符代表这个文件是目录,文件或者链接文件等。 [d]代表目录,[-]代表文件,[l]代表链接文件。</li><li>接下来的字符,以三个为一组。 第一组为文件拥有者的权限; 第二组为加入此用户组的用户(账号)的权限; 第三组为其它用户的权限。 [r]代表可读权限，[w]代表可写权限，[x]代表可执行权限。</li></ul><p>第二部分代表文件的链接数(硬链接数)</p><ul><li>就是有多少条路径可以进入到达此文件</li></ul><p>第三部分是文件的拥有者的名字(账号)</p><ul><li>linux是多用户用任务的操作系统</li></ul><p>第四部分是文件所属组的名字</p><ul><li>linux下文件对文件分组</li></ul><p><strong>Linux下一切皆文件！</strong></p><p>每天一个linux终端命令,积少成多,希望大家越来越优秀!</p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux终端命令man命令</title>
      <link href="2020/05/13/linux/2020/mei-tian-yi-ge-linux-zhong-duan-ming-ling-man-ming-ling/"/>
      <url>2020/05/13/linux/2020/mei-tian-yi-ge-linux-zhong-duan-ming-ling-man-ming-ling/</url>
      
        <content type="html"><![CDATA[<p><strong><em>我不树敌,敌自树</em></strong></p><p><strong>shutdown</strong> 中文就是关机的意思。</p><p>由于linux的关机和重新启动操作是很重大的系统操作,所以一般只有 <strong>root</strong> ( <strong>超级用户</strong> )才能执行,不过在一些linux发行版中,我们可以使用sudo增加用户权限来执行这些需要 <strong>root</strong> 身份才能执行的命令。</p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo shutdown [-krhc] [时间] [警告信息]</code></pre><p>选项与参数介绍:</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">-k</td><td style="text-align:center">不要真的关机,只是发出警告信息</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">在将系统的服务停掉之后就重启(常用)</td></tr><tr><td style="text-align:center">-h</td><td style="text-align:center">将系统的服务停掉之后,立即关机(常用)</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">取消已经在进行的shutdown命令内容</td></tr><tr><td style="text-align:center">时间</td><td style="text-align:center">指定系统关机的时间,若没有这个项目,则默认一分钟后进行</td></tr></tbody></table></div><p>范例:</p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo shutdown -h 10 'I will shutdown after 10 mins'</code></pre><p><img src="https://img-blog.csdnimg.cn/20200222141339960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p>‘I will shutdown after 10 mins’</p><p>会提示其它使用者这台电脑将在10分钟后关机,请做好保存工作!</p><p> 还有个常用的重启命令 <strong>reboot</strong> </p><pre class=" language-lang-shell"><code class="language-lang-shell">sync; sync; sync; reboot</code></pre><p><strong>sync</strong>会使在内存中尚未更新的数据,被写入磁盘中。</p><p> 每天一个linux终端命令,积少成多,希望大家越来越优秀!</p><p> <strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux终端命令shutdown命令(2)</title>
      <link href="2020/05/13/linux/2020/mei-tian-yi-ge-linux-zhong-duan-ming-ling-shutdown-ming-ling-2/"/>
      <url>2020/05/13/linux/2020/mei-tian-yi-ge-linux-zhong-duan-ming-ling-shutdown-ming-ling-2/</url>
      
        <content type="html"><![CDATA[<p><strong><em>我不树敌,敌自树</em></strong></p><p><strong>shutdown</strong>中文就是关机的意思。</p><p>由于linux的关机和重新启动操作是很重大的系统操作,所以一般只有<strong>root</strong>(<strong>超级用户</strong>)才能执行,不过在一些linux发行版中,我们可以使用sudo增加用户权限来执行这些需要<strong>root</strong>身份才能执行的命令。</p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo shutdown [-krhc] [时间] [警告信息]</code></pre><p>选项与参数介绍:</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">-k</td><td style="text-align:center">不要真的关机,只是发出警告信息</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">在将系统的服务停掉之后就重启(常用)</td></tr><tr><td style="text-align:center">-h</td><td style="text-align:center">将系统的服务停掉之后,立即关机(常用)</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">取消已经在进行的shutdown命令内容</td></tr><tr><td style="text-align:center">时间</td><td style="text-align:center">指定系统关机的时间,若没有这个项目,则默认一分钟后进行</td></tr></tbody></table></div><p>范例:</p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo shutdown -h 10 'I will shutdown after 10 mins'</code></pre><p><img src="https://img-blog.csdnimg.cn/20200222141339960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p>‘I will shutdown after 10 mins’<br>会提示其它使用者这台电脑将在10分钟后关机,请做好保存工作!<br> 还有个常用的重启命令<strong>reboot</strong></p><pre class=" language-lang-bash"><code class="language-lang-bash">sync; sync; sync; reboot</code></pre><p><strong>sync</strong>会使在内存中尚未更新的数据,被写入磁盘中。<br> 每天一个linux终端命令,积少成多,希望大家越来越优秀!<br> <strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给虚拟机的Ubuntu换阿里源</title>
      <link href="2020/05/13/linux/2020/gei-xu-ni-ji-de-ubuntu-huan-a-li-yuan/"/>
      <url>2020/05/13/linux/2020/gei-xu-ni-ji-de-ubuntu-huan-a-li-yuan/</url>
      
        <content type="html"><![CDATA[<p>安装的Ubuntu安装东西速度实在是不敢恭维QAQ，因为是国外的网址。 </p><p>所以我们要换成国内的源，然后就可以尽情飞越了。</p><p>首先我们还是要先备份下：<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p><p>接下来：<code>sudo vim /etc/apt/sources.list</code></p><p>然后把里面的东西全删除，</p><p>我们来到</p><p>找到Ubuntu，把里面内容换成如下：</p><pre class=" language-lang-c"><code class="language-lang-c">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</code></pre><p>然后</p><pre><code>sudo apt-get updatesudo apt-get upgrade</code></pre><p>就OK了。</p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机安装Tinyos</title>
      <link href="2020/05/13/linux/2020/xu-ni-ji-an-zhuang-tinyos/"/>
      <url>2020/05/13/linux/2020/xu-ni-ji-an-zhuang-tinyos/</url>
      
        <content type="html"><![CDATA[<h2 id="讲在前面的话"><a href="#讲在前面的话" class="headerlink" title="讲在前面的话"></a>讲在前面的话</h2><p>不建议大家用虚拟机ubuntu18.04LTS安装Tinyos，很多坑。</p><p>弄了好久，最后编译还各种无法解决的错误，还望各位不吝赐教！</p><p><a href="[https://incipe-win.github.io/2020/03/13/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu18.04/](https://incipe-win.github.io/2020/03/13/虚拟机安装Ubuntu18.04/">Vmware下载</a>)</p><p><a href="https://mirrors.aliyun.com/deepin-cd/15.11/deepin-15.11-amd64.iso">推荐系统Debain</a></p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="1-搭建java环境"><a href="#1-搭建java环境" class="headerlink" title="1. 搭建java环境"></a>1. 搭建java环境</h3><p><a href="https://cloud.tencent.com/developer/article/1162527">Ubuntu(Debian)安装教程</a></p><h3 id="2-搭建python开发环境和g-编译工具"><a href="#2-搭建python开发环境和g-编译工具" class="headerlink" title="2. 搭建python开发环境和g++编译工具"></a>2. 搭建python开发环境和g++编译工具</h3><pre class=" language-lang-bash"><code class="language-lang-bash">sudo apt-get install python2.7-devsudo apt-get install gccsudo apt-get install g++sudo apt-get install gcc-msp430</code></pre><h2 id="1-Tell-apt-about-the-TinyProd-Signing-Key"><a href="#1-Tell-apt-about-the-TinyProd-Signing-Key" class="headerlink" title="1. Tell apt about the TinyProd Signing Key."></a>1. Tell apt about the TinyProd Signing Key.</h2><p>告诉apt TinyProd签名密钥</p><pre class=" language-lang-bash"><code class="language-lang-bash">wget -O - http://tinyprod.net/repos/debian/tinyprod.key | sudo apt-key add -</code></pre><h2 id="2-添加Tinyos源"><a href="#2-添加Tinyos源" class="headerlink" title="2. 添加Tinyos源"></a>2. 添加Tinyos源</h2><pre class=" language-lang-bash"><code class="language-lang-bash">sudo -scd /etc/apt/sources.list.decho "deb http://tinyprod.net/repos/debian wheezy main" >> tinyprod-debian.listecho "deb http://tinyprod.net/repos/debian msp430-46 main" >> tinyprod-debian.list</code></pre><p>最后两句的意思是把”deb <a href="http://tinyprod.net/repos/debian">http://tinyprod.net/repos/debian</a> wheezy main”重定向到tinyprod-debian.list文件</p><h2 id="3-更新源并且安装tinyos依赖包"><a href="#3-更新源并且安装tinyos依赖包" class="headerlink" title="3. 更新源并且安装tinyos依赖包"></a>3. 更新源并且安装tinyos依赖包</h2><pre class=" language-lang-bash"><code class="language-lang-bash">sudo apt-get updatesudo apt-get install nesc tinyos-tools</code></pre><p>这个过程可能有点长，请耐心等待！</p><h2 id="4-下载Tinyos源代码"><a href="#4-下载Tinyos源代码" class="headerlink" title="4. 下载Tinyos源代码"></a>4. 下载Tinyos源代码</h2><pre class=" language-lang-bash"><code class="language-lang-bash">wget http://github.com/tinyos/tinyos-release/archive/tinyos-2_1_2.tar.gz  tar xf tinyos-2_1_2.tar.gz</code></pre><p>你可以将tinyos-release-tinyos-2_1_2文件命名为tinyos-main或者其它。</p><p>移动到个自己熟悉的地方保存起来。</p><h2 id="5-建立-env或者-sh文件"><a href="#5-建立-env或者-sh文件" class="headerlink" title="5. 建立.env或者.sh文件"></a>5. 建立.env或者.sh文件</h2><p>快速启动Tinyos</p><p>在tinyos-main目录下</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim tinyos.env</code></pre><p>添加如下内容</p><pre class=" language-lang-sh"><code class="language-lang-sh"># Here we setup the environment# variables needed by the tinyos # make systemexport TOSROOT="<local-tinyos-path>"export TOSDIR="$TOSROOT/tos"export CLASSPATH=.:$CLASSPATH:$TOSROOT/support/sdk/java/tinyos.jarexport MAKERULES="$TOSROOT/support/make/Makerules"export PYTHONPATH=$PYTHONPATH:$TOSROOT/support/sdk/python:PYTHONPATHecho "setting up TinyOS on source path $TOSROOT"export CPATH=:/usr/include/python2.7/</code></pre><p>这里的  <strong>&lt; local-tinyos-path&gt;</strong> 替换成自己tinyos-main的路径。</p><p>添加shell访问</p><ol><li>让其(tinyos.env)作为root用户放在/etc/profile.d/下</li><li>添加到.bsahrc</li></ol><p>这里采用第二种方法</p><p>如果安装了zsh就是添加到.zshrc</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim ~/.zshrc</code></pre><p>添加source &lt; local-tinyos-path&gt;/tinyos.env </p><p>同理，这里的&lt; local-tinyos-path&gt;也是tinyos-main的安装路径。</p><p>重启终端，终端输出setting up TinyOS on source path &lt; local-tinyos-path&gt;即说明添加成功！</p><h2 id="4-检查是否安装成功"><a href="#4-检查是否安装成功" class="headerlink" title="4. 检查是否安装成功"></a>4. 检查是否安装成功</h2><pre class=" language-lang-bash"><code class="language-lang-bash">tos-check-env</code></pre><p>查看选项 nesc 、java 以及 graphviz 是否已经正确安装。</p><p>打开仿真程序目录下的  <strong>Blink</strong> 仿真程序</p><pre class=" language-lang-bash"><code class="language-lang-bash">cd /opt/tinyos-main/apps/Blink</code></pre><p>编译示例程序</p><pre class=" language-lang-bash"><code class="language-lang-bash">make telosb（编译不添加仿真）或者make telosb sim（编译添加仿真）</code></pre><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><pre class=" language-lang-bash"><code class="language-lang-bash">$make micaz simmkdir -p simbuild/micazmake: python2.5-config: Command not foundmake: python2.5-config: Command not foundmake: python2.5-config: Command not found</code></pre><p>请确定安装好的python2.7</p><p>打开tinyos-main文件</p><p>搜索： <strong>“sim.extra”</strong> ，打开更改</p><blockquote><p>PYTHON_VERSION ?= $(shell python —version 2&gt;&amp;1 | sed ‘s/Python 2.([0-9]).[0-9]+\{0,1\}/2.\1/‘)</p></blockquote><p>为：</p><blockquote><p>PYTHON_VERSION ?= $(shell python —version 3&gt;&amp;1 | sed ‘s/Python 2.([0-9]).[0-9]+\{0,1\}/2.\1/‘)</p></blockquote><p>有其它问题可以自行谷歌😂。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://askubuntu.com/questions/799603/install-tinyos-on-ubuntu">https://askubuntu.com/questions/799603/install-tinyos-on-ubuntu</a></p><p><a href="https://stackoverflow.com/questions/34139897/make-python2-5-config-command-not-found-error-on-tinyos/50547278">https://stackoverflow.com/questions/34139897/make-python2-5-config-command-not-found-error-on-tinyos/50547278</a></p><p><a href="https://github.com/tinyos/tinyos-main/issues/289">https://github.com/tinyos/tinyos-main/issues/289</a></p><p><a href="http://tinyos.stanford.edu/tinyos-wiki/index.php/Automatic_installation">http://tinyos.stanford.edu/tinyos-wiki/index.php/Automatic_installation</a></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TinyOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机安装Ubuntu18.04</title>
      <link href="2020/05/13/linux/2020/xu-ni-ji-an-zhuang-ubuntu18.04/"/>
      <url>2020/05/13/linux/2020/xu-ni-ji-an-zhuang-ubuntu18.04/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu19.04只有九个月的支持服务时间、可以去体验下。<br>下载vmware workstation<br><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">下载地址</a><br>用这个密钥激活应该就可以了<strong>YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8</strong><br>下载Ubuntu18.04镜像文件<br>链接：<a href="https://pan.baidu.com/s/1xrGPVE5TFkiOpeoSfjiw-w">https://pan.baidu.com/s/1xrGPVE5TFkiOpeoSfjiw-w</a><br>提取码：cs9d<br>ctrl+N新建虚拟机：<br><img src="https://img-blog.csdnimg.cn/2019082710064156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选自定义典型都可以。（这里以自定义为列）<br><img src="https://img-blog.csdnimg.cn/20190827100825225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190827100916492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里先选择ISO文件和稍后再选择是有区别的。<br><img src="https://img-blog.csdnimg.cn/20190827101008586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190827101047418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>起好名字，选择好安装路径，点击下一步<br><img src="https://img-blog.csdnimg.cn/20190827101226263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里根据自己的需求来，点击下一步<br><img src="https://img-blog.csdnimg.cn/20190827101319817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一样的根据自己的要求选择<br><img src="https://img-blog.csdnimg.cn/20190827101701843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来一直点下一步<br><img src="https://img-blog.csdnimg.cn/20190827101910786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里自己分配内存，储存为单个文件，点击下一步<br><img src="https://img-blog.csdnimg.cn/20190827102011127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190827102053313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>ISO映像文件就是刚刚下载的Ubuntu镜像文件。<br>最后点击完成就好了。<br>然后点击开启此虚拟机。<br><img src="https://img-blog.csdnimg.cn/201908271030060.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>后面的默认推荐都没必要改，一直点继续就好了。<br>设置时间地点选上海就好了。<br>最后一步设置用户名，和密码，自己设置下就好了。<br>安装成功后换源可以参考   <a href="https://blog.csdn.net/qq_43826212/article/details/100068862">传送门</a><br><img src="https://img-blog.csdnimg.cn/2019082710431526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Ubuntu Navicat的一些问题(虚拟机)</title>
      <link href="2020/05/13/linux/2020/jie-jue-ubuntu-navicat-de-yi-xie-wen-ti-xu-ni-ji/"/>
      <url>2020/05/13/linux/2020/jie-jue-ubuntu-navicat-de-yi-xie-wen-ti-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<p>先安装好MySQL</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev检查是否成功：sudo ps -aux | grep mysql如果看到有mysql 则表示安装成功。</code></pre><p>配置MySQL</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo mysql_secure_installation</code></pre><p>设置好密码后会出现一些安全设置:(我的输入是nyyy)<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><p>验证MySQL是否正在运行</p><pre class=" language-lang-bash"><code class="language-lang-bash">systemctl status mysql.service</code></pre><p>有running显示即说明MySQL在运行! </p><p>注：登录mysql时一定要加<strong>sudo</strong></p><h2 id="一-远程登录问题"><a href="#一-远程登录问题" class="headerlink" title="一.远程登录问题"></a>一.远程登录问题</h2><h2 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1.修改配置文件"></a>1.修改配置文件</h2><p>终端输入</p><pre class=" language-lang-shell"><code class="language-lang-shell">netstat -an | grep 3306</code></pre><p>如果3306前面是127.0.0.1,就要求我们去修改配置文件了。</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>把bind-address = 127.0.0.1改成0.0.0.0，没有bind-address就直接加上</p><blockquote><p>bind-address=0.0.0.0</p><h2 id="2-允许所有用户远程登录"><a href="#2-允许所有用户远程登录" class="headerlink" title="2.允许所有用户远程登录"></a>2.允许所有用户远程登录</h2><ul><li>登录mysql数据库<pre class=" language-lang-bash"><code class="language-lang-bash">  sudo mysql -u[用户名] -p[密码]</code></pre>  一定要加<strong>sudo</strong>，不加登不进去的。</li><li>修改 root 的 host 属性为 %<pre class=" language-lang-bash"><code class="language-lang-bash">  use mysql;  select host, user from user;    update user set host = '%' where user = 'root';</code></pre><h3 id="3-出现1698-access-denied-for-user-‘root’-’ip’"><a href="#3-出现1698-access-denied-for-user-‘root’-’ip’" class="headerlink" title="3. 出现1698- access denied for user ‘root’@’ip’"></a>3. 出现1698- access denied for user ‘root’@’ip’</h3>原因可能是因为MySQL默认使用了UNIX auth_socket plugin插件。</li></ul></blockquote><p>简单来说这意味着当db_users使用数据库时，将会通过系统用户认证表进行认证。</p><ul><li><p>在服务器的mysql上执行</p><pre class=" language-lang-SQL"><code class="language-lang-SQL">SELECT User, Host, plugin FROM mysql.user;+------------------+-----------------------+| User             | plugin                |+------------------+-----------------------+| root             | auth_socket           || mysql.sys        | mysql_native_password || debian-sys-maint | mysql_native_password |+------------------+-----------------------+</code></pre><p>root用户在使用 auth_socket 插件。</p></li></ul><p>解决方法：</p><ul><li>可以设置你的root用户使用 mysql_native_password 插件<pre class=" language-lang-SQL"><code class="language-lang-SQL">USE mysql;UPDATE user SET plugin='mysql_native_password' WHERE User='root';FLUSH PRIVILEGES;exit;</code></pre></li></ul><p>或者</p><ul><li>用你的操作系统用户名代替YOUR_SYSTEM_USER<pre class=" language-lang-SQL"><code class="language-lang-SQL">USE mysql;CREATE USER 'YOUR_SYSTEM_USER'@'localhost' IDENTIFIED BY '';GRANT ALL PRIVILEGES ON *.* TO 'YOUR_SYSTEM_USER'@'localhost';UPDATE user SET plugin='auth_socket' WHERE User='YOUR_SYSTEM_USER';FLUSH PRIVILEGES;exit;</code></pre>选一种就好了。</li></ul><p>重启数据库<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo mysql restart</code></pre><h2 id="二-字体问题"><a href="#二-字体问题" class="headerlink" title="二.字体问题"></a>二.字体问题</h2><p>找到Navicat文件</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo vim start_navicat</code></pre><blockquote><p>把export LANG=”en_US.UTF-8” 将这句话改为 export LANG=”zh_CN.UTF-8”</p></blockquote><p>这还不能解决所有的乱码问题。</p><p>进去Navicat，点开工具：<br><img src="https://img-blog.csdnimg.cn/20200301214436463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>把这几处的字体改为[Noto Sans mono CJK SC Regular<sup><a href="#fn_3" id="reffn_3">3</a></sup></p><p>基本上字体问题都已解决!</p><h2 id="三-破解问题"><a href="#三-破解问题" class="headerlink" title="三.破解问题"></a>三.破解问题</h2><p>到~目录下，使用</p><pre class=" language-lang-shell"><code class="language-lang-shell">ls -lh</code></pre><p>删除.navicat文件<sup><a href="#fn_4" id="reffn_4">4</a></sup></p><p>注意：<strong>此种破解方式的缺点在于 删除日志文件后, navicat各种设置(比如字符设置)会被清空</strong></p><p><strong>才疏学浅，望雅正！</strong></p><p><sup><a href="#fn_4" id="reffn_4">4</a></sup>:<a href="https://www.cnblogs.com/tanrong/p/10173109.html">或者删除此文件夹下的 system.reg    user.reg   userdef.reg 文件</a></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决WSL修改不了字体的方法</title>
      <link href="2020/05/13/linux/2020/jie-jue-wsl-xiu-gai-bu-liao-zi-ti-de-fang-fa/"/>
      <url>2020/05/13/linux/2020/jie-jue-wsl-xiu-gai-bu-liao-zi-ti-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>win+r</p><p>输入<code>regedit</code></p><p>找到：</p><pre><code>计算机\HKEY_CURRENT_USER\Console\C:_Program Files_WindowsApps_CanonicalGroupLimited.UbuntuonWindows_1804.2019.521.0_x64__79rhkp1fndgsc_ubuntu.exe</code></pre><p>右键新建：<code>DWORD类型</code>，名字<code>CodePage</code>，确定，右键修改：16进制<code>0x01b5</code></p><p>解决问题。</p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决centos使用sudo时出现“用户名 is not in the sudoers file. This incident will be reported.”的问题</title>
      <link href="2020/05/13/linux/2020/jie-jue-centos-shi-yong-sudo-shi-chu-xian-yong-hu-ming-is-not-in-the-sudoers-file.this-incident-will-be-reported.de-wen-ti/"/>
      <url>2020/05/13/linux/2020/jie-jue-centos-shi-yong-sudo-shi-chu-xian-yong-hu-ming-is-not-in-the-sudoers-file.this-incident-will-be-reported.de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p><strong><em>活在自然美景之中，人就懒，懒就善。</em></strong></p><p>安装好Centos后，想通过终端安装点软件，总是提示用户权限不足，使用 <strong>sudo</strong> 提升权限的话，就会出现 <strong>用户名 is not in the sudoers file. This incident will be reported.</strong> 的提示，这时我们需要在sudoers文件里面把自己的用户名加进去。<br>1.进入root用户</p><blockquote><p>su root</p></blockquote><p>2.终端输入</p><blockquote><p>usermod -G sudo 用户名<br>重启</p></blockquote><p>或者按以下步骤：</p><p>2.修改文件权限</p><blockquote><p>chmod u+w /etc/sudoers</p></blockquote><p>3.编辑sudoers文件</p><blockquote><p>vim /etc/sudoers</p></blockquote><p>4.找到 <strong>root ALL=(ALL) ALL</strong><br>在下面添加一行</p><blockquote><p>你的用户名 ALL=(ALL) ALL<br>或者<br>你的用户名 ALL=NOPASSWD:ALL</p></blockquote><p>5.保存退出</p><blockquote><p>wq!</p></blockquote><p>接下来就可以使用sudo提升权限了。</p><p><strong>才疏学浅，望雅正！</strong></p><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统API</title>
      <link href="2020/05/13/linux/2020/linux-xi-tong-api/"/>
      <url>2020/05/13/linux/2020/linux-xi-tong-api/</url>
      
        <content type="html"><![CDATA[<h3 id="讲在前面的话"><a href="#讲在前面的话" class="headerlink" title="讲在前面的话"></a>讲在前面的话</h3><p>本文主要介绍几个主要的 <strong>linux</strong> 系统 <strong>API</strong>。</p><p>注：本文讲的简单，每个 <strong>API</strong> 举了一个例子，不适合深入学习，只适合忘记了某个函数来回顾下用法。</p><p><strong>系统API</strong> 和 <strong>C语言库函数</strong> 区别：</p><p>简单的讲： <strong>C库函数</strong> 是由 <strong>API</strong> 封装而来的。每个系统的 <strong>API</strong> 都不一样，但是 <strong>C库函数</strong> 一样，库函数更具移植性。</p><h3 id="errno-错误报告"><a href="#errno-错误报告" class="headerlink" title="errno 错误报告"></a>errno 错误报告</h3><p>下文很多函数返回失败都要设置 <strong>errno</strong> ，这里解释明白。</p><p>更详细的可到 <strong>linux</strong> 这三个头文件查看。</p><pre class=" language-lang-bash"><code class="language-lang-bash">/usr/include/asm-generic/errno-base.h /usr/include/asm-generic/errno.h/usr/include/errno.h</code></pre><p>C语言提供了 <strong>perror</strong> 和 <strong>strerror</strong> 函数来显示与 <strong>error</strong> 相关的错误信息。</p><ul><li><strong>perror()</strong> 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 <strong>errno</strong> 值的文本表示形式。<ul><li><strong>perror(“error is”);</strong></li></ul></li><li><strong>strerror()</strong> 函数，返回一个指针，指针指向当前 <strong>errno</strong> 值的文本表示形式。<ul><li><strong>fprintf(stderr, “error in CreateProcess %s”, strerror(errno));</strong></li></ul></li></ul><h3 id="open打开文件"><a href="#open打开文件" class="headerlink" title="open打开文件"></a>open打开文件</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 open#include <sys/types.h>#include <sys/stat.h>#include <fcntl.h>int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);</code></pre><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>pathname</strong>  文件名；</li><li><strong>flags</strong><ul><li>必选项<ul><li><strong>O_RDONLY</strong>  只读</li><li><strong>O_WRONLY</strong> 只写</li><li><strong>O_RDWR</strong>  读写</li></ul></li><li>可选项<ul><li><strong>O_APPEND</strong> 追加</li><li><strong>O_CREAT</strong> 创建文件<ul><li><strong>O_EXCL</strong> 与  <strong>O_CREAT</strong>  一起使用，如果文件存在，则报错。</li><li><strong>mode</strong> 权限位，最终（ <strong>mode &amp; ~umask</strong> ）</li></ul></li><li><strong>O_NONBLOCK</strong> 非阻塞 </li></ul></li></ul></li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>返回最小的可用文件描述符</li><li>失败返回-1，设置 <strong>errno</strong> </li></ul><h3 id="close关闭文件"><a href="#close关闭文件" class="headerlink" title="close关闭文件"></a>close关闭文件</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 close#include <unistd.h>int close(int fd);</code></pre><h4 id="参数介绍-1"><a href="#参数介绍-1" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>fd</strong> 文件描述符</li></ul><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功0</li><li>失败-1，设置 <strong>errno</strong></li></ul><h3 id="open-和-close-实现-touch"><a href="#open-和-close-实现-touch" class="headerlink" title="open 和 close 实现 touch"></a>open 和 close 实现 touch</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  int fd = open(argv[1], O_RDONLY | O_CREAT, 0666);  close(fd);  return 0;}</code></pre><pre class=" language-lang-bash"><code class="language-lang-bash">编译后执行./a.out newfile.cc即可创建newfile.cc文件</code></pre><h3 id="read读取文件"><a href="#read读取文件" class="headerlink" title="read读取文件"></a>read读取文件</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 read#include <unistd.h>ssize_t read(int fd, void *buf, size_t count);</code></pre><h4 id="参数介绍-2"><a href="#参数介绍-2" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>fd</strong> 文件描述符</li><li><strong>buf</strong> 缓冲区</li><li><strong>count</strong> 缓冲区大小</li></ul><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><ul><li><p>失败-1，设置 <strong>errno</strong> </p></li><li><p>成功返回读到的大小</p></li><li><strong>0</strong> 代表读到文件末尾</li></ul><h3 id="write写文件"><a href="#write写文件" class="headerlink" title="write写文件"></a>write写文件</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 write#include <unistd.h>ssize_t write(int fd, const void *buf, size_t count);</code></pre><h4 id="参数介绍-3"><a href="#参数介绍-3" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>fd</strong> 文件描述符</li><li><strong>buf</strong> 缓冲区</li><li><strong>count</strong> 大小</li></ul><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功，返回写入的字节数</li><li>失败，返回-1</li><li>0代表未写入</li></ul><h3 id="利用-read-和-write-可实现-cat"><a href="#利用-read-和-write-可实现-cat" class="headerlink" title="利用 read 和 write 可实现 cat"></a>利用 read 和 write 可实现 cat</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  int fd = open(argv[1], O_RDONLY);  char buf[250];  int ret = read(fd, buf, sizeof(buf));  write(STDOUT_FILENO, buf, ret);  while (ret) {    ret = read(fd, buf, sizeof(buf));    write(STDOUT_FILENO, buf, ret);  }  close(fd);  return 0;}</code></pre><pre class=" language-lang-bash"><code class="language-lang-bash">默认打开的三个文件描述符STDOUT_FILENO    0STDIN_FILENO    1STDERR_FILENO    2</code></pre><p>请戳 <a href="[https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6](https://baike.baidu.com/item/文件描述符">文件描述符</a>) </p><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 lseek#include <sys/types.h>#include <unistd.h>off_t lseek(int fd, off_t offset, int whence);</code></pre><h4 id="参数介绍-4"><a href="#参数介绍-4" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>fd</strong> 文件描述符</li><li><strong>offset</strong> <a href="[https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E9%87%8F](https://baike.baidu.com/item/偏移量">偏移量</a>)</li><li><strong>whence</strong><ul><li><strong>SEEK_SET</strong>  文件开始位置</li><li><strong>SEEK_CUR</strong>  文件当前位置</li><li><strong>SEEK_END</strong> 文件结尾</li></ul></li></ul><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功：返回当前位置到开始的长度</li><li>失败-1，设置 <strong>errno</strong></li></ul><h4 id="lseek作用："><a href="#lseek作用：" class="headerlink" title="lseek作用："></a>lseek作用：</h4><ul><li>移动文件读写位置</li><li>计算文件大小</li><li>扩展文件</li></ul><h4 id="利用lseek移动读写文件位置"><a href="#利用lseek移动读写文件位置" class="headerlink" title="利用lseek移动读写文件位置"></a>利用lseek移动读写文件位置</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <string.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 3) {    printf("./a.out filename\n");    return -1;  }  int fd = open(argv[2], O_RDWR | O_CREAT, 0666);  write(fd, argv[1], strlen(argv[1]));  write(fd, "\n", 1);  // 此时文件已经到末尾了，需要移动读写位置  lseek(fd, 0, SEEK_SET);  char buf[256] = {0};  int ret = read(fd, buf, sizeof(buf));  write(STDOUT_FILENO, buf, ret);  // STDOUT_FILENO, STDIN_FILENO, STDERR_FILENO  while (ret) {    ret = read(fd, buf, sizeof(buf));    write(STDOUT_FILENO, buf, ret);  }  close(fd);  return 0;}// 功能，终端输入内容写入指定文件，并且屏幕输出</code></pre><h4 id="计算文件大小"><a href="#计算文件大小" class="headerlink" title="计算文件大小"></a>计算文件大小</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  int fd = open(argv[1], O_RDONLY);  int ret = lseek(fd, 0, SEEK_END);  printf("file size is: %d\n", ret);  close(fd);  return 0;}// 因为lseek返回值是从当前位置到开始的长度,所以可以计算文件大小</code></pre><h4 id="扩展文件"><a href="#扩展文件" class="headerlink" title="扩展文件"></a>扩展文件</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  int fd = open(argv[1], O_WRONLY | O_CREAT, 0666);  // int ret = lseek(fd, 1024, SEEK_END);  lseek(fd, 1024, SEEK_END);  // 至少要写一次，才能创建指定大小文件  write(fd, "\n", 1);  close(fd);  return 0;}// 此代码可以改变文件大小，即扩展文件</code></pre><h3 id="实现-cp-命令"><a href="#实现-cp-命令" class="headerlink" title="实现 cp 命令"></a>实现 cp 命令</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 3) {    printf("./a.out filename1 filename2\n");    return -1;  }  int fd1 = open(argv[1], O_RDONLY);  int fd2 = open(argv[2], O_WRONLY | O_CREAT, 0666);  char buf[256];  int ret = read(fd1, buf, sizeof(buf));  write(fd2, buf, ret);  while (ret) {    ret = read(fd1, buf, sizeof(buf));    write(fd2, buf, ret);  }  close(fd1);  close(fd2);  return 0;}// 复制的本质就是打开一个文件，读取所有内容，写入另一个文件</code></pre><h3 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 stat#include <sys/types.h>#include <sys/stat.h>#include <unistd.h>int stat(const char *pathname, struct stat *statbuf);</code></pre><h4 id="参数介绍-5"><a href="#参数介绍-5" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><p><strong>pathname</strong> 文件名</p></li><li><p><strong>struct stat</strong></p><ul><li><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct stat {  dev_t     st_dev;         /* ID of device containing file 文件设备编号*/  ino_t     st_ino;         /* Inode number 索引节点*/  mode_t    st_mode;        /* File type and mode 文件类型和存储权限*/  nlink_t   st_nlink;       /* Number of hard links 硬链接数*/  uid_t     st_uid;         /* User ID of owner 用户ID*/  gid_t     st_gid;         /* Group ID of owner 组ID*/  dev_t     st_rdev;        /* Device ID (if special file) 设备类型，若是设备，则为设备编号*/  off_t     st_size;        /* Total size, in bytes 文件大小*/  blksize_t st_blksize;     /* Block size for filesystem I/O 块大小*/  blkcnt_t  st_blocks;      /* Number of 512B blocks allocated 块数*/  /* Since Linux 2.6, the kernel supports nanosecond     precision for the following timestamp fields.     For the details before Linux 2.6, see NOTES. */  struct timespec st_atim;  /* Time of last access 最后一次访问时间*/  struct timespec st_mtim;  /* Time of last modification 最后一次修改时间*/  struct timespec st_ctim;  /* Time of last status change 最后一次改变时间*/#define st_atime st_atim.tv_sec      /* Backward compatibility */#define st_mtime st_mtim.tv_sec#define st_ctime st_ctim.tv_sec};</code></pre></li></ul></li></ul><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功返回0</li><li>错误返回-1，设置 <strong>errno</strong> </li></ul><h4 id="stat作用"><a href="#stat作用" class="headerlink" title="stat作用"></a>stat作用</h4><ul><li>获取文件状态</li></ul><h4 id="实现ls-l命令"><a href="#实现ls-l命令" class="headerlink" title="实现ls -l命令"></a>实现ls -l命令</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <grp.h>#include <pwd.h>#include <stdio.h>#include <string.h>#include <sys/stat.h>#include <sys/types.h>#include <time.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  struct stat sb;  stat(argv[1], &sb);  char stmode[11] = {0};  memset(stmode, '-', sizeof(stmode) - 1);  if (S_ISREG(sb.st_mode)) {    stmode[0] = '-';  }  if (S_ISDIR(sb.st_mode)) {    stmode[0] = 'd';  }  if (S_ISCHR(sb.st_mode)) {    stmode[0] = 'c';  }  if (S_ISBLK(sb.st_mode)) {    stmode[0] = 'b';  }  if (S_ISFIFO(sb.st_mode)) {    stmode[0] = 'p';  }  if (S_ISLNK(sb.st_mode)) {    stmode[0] = 'l';  }  if (S_ISSOCK(sb.st_mode)) {    stmode[0] = 's';  }  if (sb.st_mode & S_IRUSR) {    stmode[1] = 'r';  }  if (sb.st_mode & S_IWUSR) {    stmode[2] = 'w';  }  if (sb.st_mode & S_IXUSR) {    stmode[3] = 'x';  }  if (sb.st_mode & S_IRGRP) {    stmode[4] = 'r';  }  if (sb.st_mode & S_IWGRP) {    stmode[5] = 'w';  }  if (sb.st_mode & S_IXGRP) {    stmode[6] = 'x';  }  if (sb.st_mode & S_IROTH) {    stmode[7] = 'r';  }  if (sb.st_mode & S_IWOTH) {    stmode[8] = 'w';  }  if (sb.st_mode & S_IXOTH) {    stmode[9] = 'x';  }  struct tm *filetm = localtime(&sb.st_atim.tv_sec);  char timebuf[20] = {0};  sprintf(timebuf, "%d月  %d %02d:%02d", filetm->tm_mon + 1, filetm->tm_mday,          filetm->tm_hour, filetm->tm_min);  printf("%s %ld %s %s %ld %s %s\n", stmode, sb.st_nlink,         getpwuid(sb.st_uid)->pw_name, getgrgid(sb.st_gid)->gr_name, sb.st_size,         timebuf, argv[1]);  return 0;}// 可通过man inode 查看st_mode的更多信息</code></pre><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 access#include <unistd.h>int access(const char *pathname, int mode);</code></pre><h4 id="参数介绍-6"><a href="#参数介绍-6" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>pathname</strong> 文件名</li><li><strong>mode</strong> 模式<ul><li><strong>R_OK</strong> 可读？</li><li><strong>W_OR</strong> 可写？</li><li><strong>X_OR</strong> 可执行？</li><li><strong>F_OR</strong> 存在？</li></ul></li></ul><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><ul><li>如果文件存在或者有该权限返回0</li><li>失败返回-1，设置 <strong>errno</strong></li></ul><h4 id="access作用"><a href="#access作用" class="headerlink" title="access作用"></a>access作用</h4><ul><li>检查调用进程是否可以对指定的文件执行某种操作</li></ul><h4 id="判断文件的各种权限"><a href="#判断文件的各种权限" class="headerlink" title="判断文件的各种权限"></a>判断文件的各种权限</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  if (access(argv[1], R_OK) == 0) {    printf("%s read is ok!\n", argv[1]);  }  if (access(argv[1], W_OK) == 0) {    printf("%s wirte is ok!\n", argv[1]);  }  if (access(argv[1], X_OK) == 0) {    printf("%s exe is ok!\n", argv[1]);  }  if (access(argv[1], F_OK) == 0) {    printf("%s file exists!\n", argv[1]);  }  return 0;}</code></pre><h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 truncate#include <unistd.h>#include <sys/types.h>int truncate(const char *path, off_t length)</code></pre><h4 id="参数介绍-7"><a href="#参数介绍-7" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>path</strong> 文件名</li><li><strong>length</strong> 截取长度</li></ul><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功返回0</li><li>失败返回-1，设置 <strong>errno</strong></li></ul><h4 id="truncate作用"><a href="#truncate作用" class="headerlink" title="truncate作用"></a>truncate作用</h4><ul><li>截取文件</li></ul><h4 id="truncate使用案例"><a href="#truncate使用案例" class="headerlink" title="truncate使用案例"></a>truncate使用案例</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  truncate(argv[1], 1024);  return 0;}// 执行完后文件大小变为1024，除此之外，如果设置的大小比原文件的小，会删除原文件内容</code></pre><h3 id="link系列"><a href="#link系列" class="headerlink" title="link系列"></a>link系列</h3><h4 id="link"><a href="#link" class="headerlink" title="link"></a>link</h4><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 link#include <unistd.h>int link(const char *oldpath, const char *newpath);</code></pre><h5 id="参数介绍-8"><a href="#参数介绍-8" class="headerlink" title="参数介绍"></a>参数介绍</h5><ul><li><strong>oldpath</strong> 原文件</li><li><strong>newpath</strong> 创建的硬链接文件</li></ul><h5 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h5><ul><li>成功返回0</li><li>失败返回-1，设置 <strong>errno</strong> </li></ul><h5 id="link使用案例"><a href="#link使用案例" class="headerlink" title="link使用案例"></a>link使用案例</h5><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <malloc.h>#include <stdio.h>#include <string.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  char *newhard = (char *)malloc(sizeof(argv[1]) * 2);  strcpy(newhard, argv[1]);  strcat(newhard, ".hard");  puts(newhard);  link(argv[1], newhard);  return 0;}</code></pre><h4 id="symlink"><a href="#symlink" class="headerlink" title="symlink"></a>symlink</h4><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 symlink#include <unistd.h>int symlink(const char *target, const char *linkpath);</code></pre><h5 id="参数介绍-9"><a href="#参数介绍-9" class="headerlink" title="参数介绍"></a>参数介绍</h5><ul><li><strong>target</strong> 原文件</li><li><strong>linkpath</strong> 软链接文件</li></ul><h5 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h5><ul><li>成功返回0</li><li>失败返回-1，设置 <strong>errno</strong></li></ul><h5 id="symlink使用案例"><a href="#symlink使用案例" class="headerlink" title="symlink使用案例"></a>symlink使用案例</h5><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <malloc.h>#include <stdio.h>#include <string.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  char *newsoft = (char *)malloc(sizeof(argv[1]) * 2);  strcpy(newsoft, argv[1]);  strcat(newsoft, ".soft");  symlink(argv[1], newsoft);  return 0;}</code></pre><h4 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h4><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 readlink#include <unistd.h>ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);</code></pre><h5 id="参数介绍-10"><a href="#参数介绍-10" class="headerlink" title="参数介绍"></a>参数介绍</h5><ul><li><strong>pathname</strong> 文件名</li><li><strong>buf</strong> 缓冲区</li><li><strong>bufsiz</strong> 缓冲区大小</li></ul><h5 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h5><ul><li>成功返回 <strong>buf</strong> 填充的大小</li><li>失败返回-1，设置 <strong>errno</strong></li></ul><h5 id="readlink使用案例"><a href="#readlink使用案例" class="headerlink" title="readlink使用案例"></a>readlink使用案例</h5><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  char buf[32] = {0};  // 只能读取软链接  readlink(argv[1], buf, sizeof(buf));  printf("buf is %s\n", buf);  return 0;}</code></pre><h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h4><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 unlink#include <unistd.h>int unlink(const char *pathname);</code></pre><h5 id="参数介绍-11"><a href="#参数介绍-11" class="headerlink" title="参数介绍"></a>参数介绍</h5><ul><li><strong>pathname</strong> 文件名</li></ul><h5 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h5><ul><li>成功返回0</li><li>失败返回-1，设置 <strong>errno</strong></li></ul><h5 id="unlink使用案例"><a href="#unlink使用案例" class="headerlink" title="unlink使用案例"></a>unlink使用案例</h5><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  // 软硬都可以删除  // 还可以删除文件  unlink(argv[1]);  return 0;}</code></pre><h3 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 chdir#include <unistd.h>int chdir(const char *path);</code></pre><h4 id="参数介绍-12"><a href="#参数介绍-12" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>path</strong> 路径</li></ul><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功返回0</li><li>失败返回-1，设置 <strong>errno</strong></li></ul><h4 id="chdir-作用"><a href="#chdir-作用" class="headerlink" title="chdir 作用"></a>chdir 作用</h4><ul><li>切换路径</li></ul><h3 id="getcwd-得到路径"><a href="#getcwd-得到路径" class="headerlink" title="getcwd 得到路径"></a>getcwd 得到路径</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 getcwd#include <unistd.h>char *getcwd(char *buf, size_t size);</code></pre><h4 id="参数介绍-13"><a href="#参数介绍-13" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>buf</strong> 缓冲区，传出路径</li><li><strong>size</strong> 缓冲区大小</li></ul><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功返回目录指针（目录）</li><li>失败返回-1，设置 <strong>errno</strong></li></ul><h3 id="chdir-和-getcwd-使用案例"><a href="#chdir-和-getcwd-使用案例" class="headerlink" title="chdir 和 getcwd 使用案例"></a>chdir 和 getcwd 使用案例</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./a.out filename\n");    return -1;  }  chdir(argv[1]);  char buf[256];  getcwd(buf, sizeof(buf));  printf("buf is [%s]\n", buf);  return 0;}</code></pre><h3 id="opendir-打开目录"><a href="#opendir-打开目录" class="headerlink" title="opendir 打开目录"></a>opendir 打开目录</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man opendir#include <sys/types.h>#include <dirent.h>DIR *opendir(const char *name);</code></pre><h4 id="参数介绍-14"><a href="#参数介绍-14" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>name</strong> 要打开的目录</li></ul><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功返回一个目录流指针 <strong>DIR</strong> </li><li>失败返回 <strong>NULL</strong> </li></ul><h3 id="readdir-读取目录内容"><a href="#readdir-读取目录内容" class="headerlink" title="readdir 读取目录内容"></a>readdir 读取目录内容</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man readdir#include <dirent.h>struct dirent *readdir(DIR *dirp);</code></pre><h4 id="参数介绍-15"><a href="#参数介绍-15" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>dirp</strong> 目录流指针</li></ul><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><ul><li><p>返回 <strong>dirent structure</strong> </p><ul><li><pre class=" language-lang-bash"><code class="language-lang-bash">struct dirent {               ino_t          d_ino;       /* Inode number 索引节点*/               off_t          d_off;       /* Not an offset; see below */               unsigned short d_reclen;    /* Length of this record 长度*/               unsigned char  d_type;      /* Type of file; not supported                                              by all filesystem types 类型*/               char           d_name[256]; /* Null-terminated filename 名字*/           };</code></pre></li></ul></li></ul><h3 id="closedir-关闭目录"><a href="#closedir-关闭目录" class="headerlink" title="closedir 关闭目录"></a>closedir 关闭目录</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man closedir#include <sys/types.h>#include <dirent.h>int closedir(DIR *dirp);</code></pre><h4 id="参数介绍-16"><a href="#参数介绍-16" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>dirp</strong> 目录流指针</li></ul><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功返回0</li><li>失败返回-1，设置 <strong>errno</strong> </li></ul><h3 id="计算某个目录下有多少文件"><a href="#计算某个目录下有多少文件" class="headerlink" title="计算某个目录下有多少文件"></a>计算某个目录下有多少文件</h3><ul><li><p>先用 <strong>shell</strong> 得出结果，与代码的验证，检验代码是否正确</p><ul><li><pre class=" language-lang-shell"><code class="language-lang-shell">find ./ -type f | wc -l</code></pre></li></ul></li><li><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <dirent.h>#include <fcntl.h>#include <stdio.h>#include <string.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int count = 0;int dirCount(char *dirname) {  // 打印路径  printf("%s\n", dirname);  // 打开目录  DIR *dirp = opendir(dirname);  if (dirp == NULL) {    perror("opendir err: ");    return -1;  }  struct dirent *dentp = NULL;  // 循环读目录，遇到普通文件个数++  while ((dentp = readdir(dirp)) != NULL) {    // 如果是目录    if (dentp->d_type == DT_DIR) {      // 遇到'.', '..'就跳过      if (strcmp(".", dentp->d_name) == 0 || strcmp("..", dentp->d_name) == 0) {        continue;      }      // 拼接新路径，递归找文件      char newdirname[257] = {0};      sprintf(newdirname, "%s/%s", dirname, dentp->d_name);      dirCount(newdirname);    }    // 是文件    if (dentp->d_type == DT_REG) {      ++count;      // 打印文件名字      printf("dname : %s\n", dentp->d_name);    }  }  // 关闭目录  closedir(dirp);  return count;}int main(int argc, char *argv[]) {  if (argc != 2) {    printf("./.a.out filename\n");    return -1;  }  dirCount(argv[1]);  printf("count = %d\n", count);  return 0;}// ./a.out ./</code></pre></li></ul><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><pre class=" language-lang-bash"><code class="language-lang-bash">man 2 dup#include <unistd.h>int dup(int oldfd);// 复制文件描述符int dup2(int oldfd, int newfd);// 新的文件描述符指向旧的文件描述符</code></pre><h4 id="参数介绍-17"><a href="#参数介绍-17" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul><li><strong>oldfd</strong> 旧的文件描述符</li><li><strong>newfd</strong> 新的文件描述符</li></ul><h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功返回新的文件描述符</li><li>失败返回-1，设置 <strong>errno</strong> </li></ul><h4 id="dup-和-dup2-使用案例"><a href="#dup-和-dup2-使用案例" class="headerlink" title="dup 和 dup2 使用案例"></a>dup 和 dup2 使用案例</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <fcntl.h>#include <stdio.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>int main() {  // 复制文件描述符1  int outfd = dup(1);  int fd = open("world", O_WRONLY | O_CREAT, 0666);  // 标准输出到fd文件描述符  dup2(fd, 1);  printf("Hello World!\n");  close(fd);  fflush(stdout);  // 恢复，重新对应标准输出  dup2(outfd, 1);  printf("Hello World!\n");  return 0;}// 作用，一个printf输出到文件，一个输出到屏幕</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>才疏学浅，还请雅正！</p><p>把自己学习的过程记录下来，一是巩固自己所学，二是以后自己查看方便，三希望可以帮助到大家！</p><h3 id="诗情画意"><a href="#诗情画意" class="headerlink" title="诗情画意"></a>诗情画意</h3><blockquote><center>晚晴</center><center>李商隐</center><center>深居俯夹城，春去夏犹清。天意怜幽草，人间重晚晴。</center><center>并添高阁迥，微注小窗明。越鸟巢干后，归飞体更轻。</center></blockquote><valine></valine>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu1004(map解法)</title>
      <link href="2020/05/12/hdu/2020/hdu1004-map-jie-fa/"/>
      <url>2020/05/12/hdu/2020/hdu1004-map-jie-fa/</url>
      
        <content type="html"><![CDATA[<p></p><h1 style="color:#1A5CC8">Let the Balloon Rise</h1><font><b><span style="font-family:Arial;font-size:12px;font-weight:bold;color:green">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 168777&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 67277<br></span></b></font><br><br><div class="panel_title" align="left">Problem Description</div> <div class="panel_content">Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges' favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.<br><br>This year, they decide to leave this lovely job to you. <br></div><div class="panel_bottom">&nbsp;</div><br><div class="panel_title" align="left">Input</div> <div class="panel_content">Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) -- the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.<br><br>A test case with N = 0 terminates the input and this test case is not to be processed.<br></div><div class="panel_bottom">&nbsp;</div><br><div class="panel_title" align="left">Output</div> <div class="panel_content">For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case.<br></div><div class="panel_bottom">&nbsp;</div><br><div class="panel_title" align="left">Sample Input</div><div class="panel_content"><pre><div style="font-family:Courier New,Courier,monospace;">5greenredblueredred3pinkorangepink0</div><div class="panel_bottom">&nbsp;</div><div class="panel_title" align="left">Sample Output</div><div class="panel_content"><pre><div style="font-family:Courier New,Courier,monospace;">redpink</div><br><br><p></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <cstring>#include <iostream>#include <map>#include <string>int main() {  using namespace std;  int n;  string str1;  while (cin >> n) {    if (n == 0)      break;    map<string, int> mp;    for (int i = 0; i < n; i++) {      cin >> str1;      mp[str1]++; // map的特点    }    map<string, int>::iterator it;    string str;    int sum = 0;    for (it = mp.begin(); it != mp.end(); it++) {      if (it->second > sum) {        str = it->first;        sum = it->second; //找出最大的int，保存最大int的string      }    }    cout << str << endl;  }  return 0;}</code></pre>  <valine></valine></pre></div></pre></div>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu2037今年暑假不AC</title>
      <link href="2020/05/12/hdu/2020/hdu2037-jin-nian-shu-jia-bu-ac/"/>
      <url>2020/05/12/hdu/2020/hdu2037-jin-nian-shu-jia-bu-ac/</url>
      
        <content type="html"><![CDATA[<p><strong><em>所谓贪心，只是人的一种本能反应</em></strong></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2037">原题链接</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>using std::cin;using std::cout;using std::endl;//各个节目的开始时间，结束时间！struct Ti {  int Ti_s;  int Ti_e;};//自定义排序规则cmpbool cmp(Ti a, Ti b) { return a.Ti_e < b.Ti_e; }int main() {  Ti *T = new Ti[102];  int n;  while (cin >> n) {    if (n == 0) break;    for (int i = 0; i < n; i++) {      cin >> T[i].Ti_s >> T[i].Ti_e;    }    std::sort(T, T + n, cmp);  //对结构体的Ti_e排序，自定义排序规则    // for (int i = 0; i < n; i++) {    //   cout << T[i].Ti_s << " " << T[i].Ti_e << endl;    // }    int cnt = 1, x = T[0].Ti_e;    for (int i = 1; i < n; i++) {      //如果第一个节目结束，第二个节目已经开始了，更新变量x，并且又看一个节目！      if (T[i].Ti_s >= x) {        cnt++;        x = T[i].Ti_e;      }    }    cout << cnt << endl;  }  return 0;}</code></pre><p><strong>才疏学浅，望雅正！</strong></p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门深搜(递归)</title>
      <link href="2020/05/12/hdu/2020/ru-men-shen-sou-di-gui/"/>
      <url>2020/05/12/hdu/2020/ru-men-shen-sou-di-gui/</url>
      
        <content type="html"><![CDATA[<p><strong><em>所谓无底深渊，下去，也是前程万里</em></strong></p><p>入门深搜，以<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1241">hdu1241</a>为例进行讲解！</p><p>题目的意思大概是有一块油田，要你求有多少个不同的石油储藏（如果每个油袋是上下左右，对角相邻的，那么说这是一个石油储藏，*代表没有油袋，@代表有油袋）</p><p>典型的深搜算法。我们从找到的第一个油袋@开始，上下左右，对角进行搜索，找到一个油袋就用把当前油袋变为 *，直到图中没有@了为止！那么我们总共进行了多少次深搜就有多少个石油储藏！</p><p>代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>using std::cin;using std::cout;using std::endl;const int MAX_M = 101;const int MAX_N = 101;  //最大油田面积char ch[MAX_M][MAX_N];  //油田int m, n;               //油田大小void dfs(int, int);int main() {  while (cin >> m >> n) {    if (m == 0 && n == 0) break;    for (int i = 0; i < m; i++) {      cin >> ch[i];    }    //输入！    int cnt = 0;    for (int i = 0; i < m; i++) {      for (int j = 0; j < n; j++) {        //从有油袋的地方开始        if (ch[i][j] == '@') {          dfs(i, j);          cnt++;        }      }    }    cout << cnt << endl;  }  return 0;}//现在的位置为（x，y）void dfs(int x, int y) {  //将当前位置替换为*  ch[x][y] = '*';  for (int nx = -1; nx <= 1; ++nx) {    for (int ny = -1; ny <= 1; ++ny) {      //往x方向移动nx，y方向移动nx，此时的位置为（dx，dy）      int dx = nx + x, dy = ny + y;      //判断（dx，dy）是否在油田内，是否是油袋！      if (0 <= dx && dx < m && 0 <= dy && dy < n && ch[dx][dy] == '@') {        dfs(dx, dy);      }    }  }  return;}</code></pre><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1312">牛刀小试</a></p><p>代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>using std::cin;using std::cout;using std::endl;const int MAX_W = 22;const int MAX_H = 22;   //最大长方形int w, h;               //长方形宽长int cnt;                //满足条件的.的个数char ch[MAX_W][MAX_H];  //长方形void dfs(int x, int y);int main() {  while (cin >> w >> h) {    if (w == 0 && h == 0) break;    for (int i = 0; i < h; i++) {      cin >> ch[i];    }    cnt = 0;    for (int i = 0; i < h; i++) {      for (int j = 0; j < w; j++) {        //从@开始        if (ch[i][j] == '@') {          dfs(i, j);        }      }    }    cout << cnt << endl;  }  return 0;}void dfs(int x, int y) {  //每调用一次，cnt就加一，因为是找满足条件的.的个数  cnt++;  //标记  ch[x][y] = '#';  for (int nx = -1; nx <= 1; ++nx) {    for (int ny = -1; ny <= 1; ++ny) {      if (nx == ny || nx == -ny) {        continue;      }      //题目要求只能上下左右移动，对角相邻没用！      int mx = x + nx;      int my = y + ny;      //判断是否在长方形内，是否是.      if (0 <= mx && mx < h && 0 <= my && my < w && ch[mx][my] == '.') {        dfs(mx, my);      }    }  }  return;}</code></pre><p><strong>才疏学浅，望雅正！</strong></p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转单链表(非递归)</title>
      <link href="2020/05/12/hdu/2020/fan-zhuan-dan-lian-biao-fei-di-gui/"/>
      <url>2020/05/12/hdu/2020/fan-zhuan-dan-lian-biao-fei-di-gui/</url>
      
        <content type="html"><![CDATA[<p><strong><em>The world has kissed my soul with its pain, asking for its return in songs.</em></strong></p><p>链表定义：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct ListNode {         int val;         ListNode *next;  };</code></pre><p>先上代码，再解释！</p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> /*初始链表：1 -> 2 -> 3 -> nullptr  *目标链表：3 -> 2 -> 1 -> nullptr  */ struct ListNode reverse(ListNode *head) {     ListNode *node = nullptr;     while(cur) {         ListNode *cur = head->next;    //保存head->next结点信息         head->next = node;            //反转指向         node = head;                //后移node         head = cur;                    //后移head     }     return node; }</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">初始链表:       1   ->   2   ->   3   ->   nullptr第一步:         node             head     cur                \             \        \                nullptr   ->   1   ->   2   ->   3                 node             head      cur                \             \        \    第二步 :         nullptr   <-   1        2   ->   3                         node(head)      cur                                      \        \第三步 :            nullptr   <-  1        2   ->   3                             node    head(cur)                               \        \第四步 :         nullptr   <-   1        2   ->   3 完成了第一次循环!然后重复上面的步骤直到cur为nullptr，此时易知node指向3结点。链表反转完成，新的链表为node!</code></pre><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">牛刀小试1</a><br><br><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">牛刀小试2</a></p><p><strong>才疏学浅，望雅正！</strong></p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>取模运算(深层次理解)</title>
      <link href="2020/05/12/hdu/2020/qu-mo-yun-suan-shen-ceng-ci-li-jie/"/>
      <url>2020/05/12/hdu/2020/qu-mo-yun-suan-shen-ceng-ci-li-jie/</url>
      
        <content type="html"><![CDATA[<p>之前一直觉得自己了解取模取余运算，知道最近看了C++ Primer，有这么一句话，</p><blockquote><p>当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数</p></blockquote><p>才发现自己学知识真的止于皮毛。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>给定一个正整数p，任意一个整数n，一定存在等式 ：</p><p>n = kp + r ；</p><p>其中 k、r 是整数，且 0 ≤ r &lt; p，则称 k 为 n 除以 p 的商，r 为 n 除以 p 的余数。</p><h1 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h1><p>对于整型数a，b来说，取模运算或者求余运算的方法都是：</p><p>1.求整数商：c = a / b;</p><p>2.计算模或者余数： r = a - c * b.</p><p>求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。</p><h2 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h2><blockquote><p>-1 mod 256<br>a = -1，b = 256<br>现计算c = a / b；<br>取余运算：c = 0（向0方向舍入）<br>取模运算：c = -1（向负无穷方向舍入）<br>计算模；<br>取余运算：r = -1 - 0 = -1；<br>取模运算：r = -1 - （（-1）*256）= 255；</p></blockquote><p>知道了这个就不难理解C++ Primer那句话的意思了。</p><p>更多参阅： || <a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4">维基百科</a></p><p>才疏学浅，望雅正！</p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快慢指针找链表环入口</title>
      <link href="2020/05/12/hdu/2020/kuai-man-zhi-zhen-zhao-lian-biao-huan-ru-kou/"/>
      <url>2020/05/12/hdu/2020/kuai-man-zhi-zhen-zhao-lian-biao-huan-ru-kou/</url>
      
        <content type="html"><![CDATA[<p>链表：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct ListNode {     int val;     struct ListNode *next; };</code></pre><p>快慢指针就是指指针每次移动的速度不一样，一般快指针每次移动两步，慢指针移动一步。</p><p>既然快慢指针移动的速度不同，那么如果有环，就一定会相遇，无环，就不可能相遇（相当于两个人围着跑道跑步，同起点，如果跑道有环的话，只要速度不同，那么他们肯定会相遇~，如果跑道是直线的，那么他们的距离只会越来越远，不可能再相遇。）终止条件就是链表为空。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">bool IsCycle(struct ListNode* head){    struct ListNode* fast,slow;    fast = head;    slow = head;while(fast&&fast->next){    slow = slow->next;    fast = fast->next->next;    if(fast == slow){        return true;        }    }    return false;}</code></pre><p>判断环入口，分两步：</p><p>1.判断有无环</p><p>2.重置快指针，慢指针不变，使快慢指针每次都只移动一步，快慢指针再次相遇就是环入口</p><p>如果不能理解可以在链表中画个环，用表格记录fast和slow<br><img src="https://img-blog.csdnimg.cn/20190829103542248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><div class="table-container"><table><thead><tr><th>fast</th><th>slow</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td></tr><tr><td>6</td><td>3</td></tr><tr><td>8</td><td>4</td></tr><tr><td>2</td><td>5</td></tr><tr><td>4</td><td>6</td></tr><tr><td>6</td><td>7</td></tr><tr><td>8</td><td>8</td></tr></tbody></table></div><p>找入口：<br>| fast | slow |<br>| —— | —— |<br>| 0    | 8    |<br>| 1    | 1    |<br>好了，fast和slow相遇，入口就是1</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct ListNode *detectCycle(struct ListNode *head) {    struct ListNode* fast = head;    struct ListNode* slow = head;    bool isCycle=false;    while(fast&&fast->next){        slow = slow->next;        fast = fast->next->next;        if(fast==slow){            isCycle = true;            break;        }    }    printf("%d %d\n",fast->val,slow->val);    if(isCycle){        fast = head;        while(fast!=slow){            fast=fast->next;            slow=slow->next;            printf("%d %d\n",fast->val,slow->val);        }        return fast;    }    else{        return 0;    }}</code></pre><p>快慢指针用法很多，还要继续学习！</p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="2020/05/12/hdu/2020/kuai-su-mi/"/>
      <url>2020/05/12/hdu/2020/kuai-su-mi/</url>
      
        <content type="html"><![CDATA[<p><strong><em>一场梦，不怨也不恨，上了想象力的当。</em></strong></p><p>快速幂，顾名思义，快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂n)， 与朴素的O(n)相比效率有了极大的提高。</p><p>讲白了，就是你知道了n的n次方，要你求n的2n次方，你还会循环2n次去求n的2n次方吗？显然只要计算n的n次方乘以n的n次方就行了。</p><p>那么，时间复杂度就由原来的O(n)降为了现在的O(logn)了。<br>大大优化了性能。</p><p>代码如下，位运算可用可不用！</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <bits/stdc++.h>using namespace std;// 快速模幂计算函数long long PowerFast(long long a, int n) {  long long res = 1;  while (n) {    if (n & 1) { // n % 2 == 1      res *= a;    }    a *= a;    n >>= 1; // n/2  }  return res;}int main() {  int n;  cin >> n;  cout << PowerFast(n, n) << endl;  return 0;}</code></pre><p><strong>才疏学浅，望雅正！</strong></p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯特林公式</title>
      <link href="2020/05/12/hdu/2020/si-te-lin-gong-shi/"/>
      <url>2020/05/12/hdu/2020/si-te-lin-gong-shi/</url>
      
        <content type="html"><![CDATA[<p>斯特林公式是用来估算阶乘的，n越大，结果越准确！</p><p>斯特林公式：</p><p><img align="absmiddle" alt="" title="" height="36" width="112" src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D112/sign=4aec460be7cd7b89ed6c3e823d264291/4bed2e738bd4b31c19ead27a86d6277f9f2ff819.jpg"><br>或更精确的：</p><p><img align="absmiddle" alt="" title="" height="49" width="149" src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D149/sign=61f142202e2eb938e86d7ef6ec6385fe/9d82d158ccbf6c81b51c6d29bd3eb13532fa40c3.jpg"><br>或：</p><p><img align="absmiddle" alt="" title="" height="42" width="136" src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D136/sign=5a5f4811fe1f3a295ec8d1cdaf24bce3/6609c93d70cf3bc749362423df00baa1cc112acf.jpg"><br>&lt;/div&gt;<br>&lt;/section&gt;&lt;/div&gt;<br>或：</p><p></p><div class="para" label-module="para"><section class="formula-container formula-container__inline"><p></p><p></p><div class="layoutinline formula" style="width:116px;background-color: rgb(255, 255, 255); cursor: move; text-indent: 28px; white-space: normal; display: inline;"><img align="absmiddle" alt="" title="" height="49" width="116" src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D116/sign=e0492cdb65600c33f479dac92c4d5134/d1a20cf431adcbeffd2391c9a2af2edda2cc9fee.jpg"> ，<img align="absmiddle" alt="" title="" height="18" width="69" src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D69/sign=28d15fcaebdde711e3d240ffa5ef21e9/34fae6cd7b899e51f200d5db4ca7d933c9950d77.jpg"></div></section></div><br>或：<p></p><p></p><div class="para" label-module="para"><section class="formula-container formula-container__inline"><p></p><p></p><div class="layoutinline formula" style="width:97px;background-color: rgb(255, 255, 255); cursor: move; text-indent: 28px; white-space: normal; display: inline;"><br><img align="absmiddle" alt="" title="" height="41" width="97" src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D97/sign=dfa39ecb990a304e5622acfdd3c814f3/8718367adab44aed0ccf542bbd1c8701a08bfb78.jpg"><br>，<br><img align="absmiddle" alt="" title="" height="18" width="69" src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D69/sign=28d15fcaebdde711e3d240ffa5ef21e9/34fae6cd7b899e51f200d5db4ca7d933c9950d77.jpg"><p></p><p>如果要计算N后得到的数字为几位数，则我们可以知道其位数等于lgN！+1；</p><p><img class="mwe-math-fallback-png-inline tex" style="border: none; vertical-align: middle; display: inline;" src="http://upload.wikimedia.org/math/b/d/e/bde6df6f84382a92e279f5626bed3606.png" alt="\ln(n!) = \ln 1 + \ln 2 + \cdots + \ln n."></p><p>代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <stdio.h>#include <iostream>#include <math.h>using namespace std;int main (){    int w;    scanf("%d",&w);    while(w--)    {        int z, i;        double sum = 0;        scanf("%d",&z);        for(i = 1; i <= z; i++)            sum += log10( double(i) );        printf("%d\n",int(sum) + 1);    }    return 0;}</code></pre>  <valine></valine></div></section></div>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛顿迭代法</title>
      <link href="2020/05/12/hdu/2020/niu-dun-die-dai-fa/"/>
      <url>2020/05/12/hdu/2020/niu-dun-die-dai-fa/</url>
      
        <content type="html"><![CDATA[<p>牛顿迭代法（Newton’s method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。</p><p>当然，牛顿迭代法也是已知已知的实现求方根最快的方法之一。</p><p>大家都知道，五次方程无根式解，但是用途却很多。</p><p>而牛顿迭代法的出现正好解决了这个问题。</p><p>牛顿迭代法就是不断求导数，请看下图：<br><img src="https://img-blog.csdnimg.cn/201908232007000.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>大致推导：<br><img src="https://img-blog.csdnimg.cn/20190823201506861.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>牛顿迭代法求方根：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int mySqrt(int x){    long r = x;    while(r * r > x)    {        r = (r + x / r) / 2;//迭代    }    return (int)r;}</code></pre><p>雷神之锤III的源码</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">float Q_rsqrt( float number ) {     long i; float x2, y; const float threehalfs = 1.5F;    x2 = number * 0.5F;     y = number;     i = * ( long * ) &y; // evil floating point bit level hacking     i = 0x5f3759df - ( i >> 1 ); // what the fuck?     y = * ( float * ) &i;     y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration     // y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed    #ifndef Q3_VM #    ifdef __linux__ assert( !isnan(y) ); // bk010122 - FPE?    #endif    #endif return y; }</code></pre><p>参考<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6536576.html">https://www.cnblogs.com/ECJTUACM-873284962/p/6536576.html</a></p><p>牛顿迭代法求方程的根没有固定的模板。</p><p>需根据不同要求进行解答。</p><p>可以看看hduoj 2199 </p><p>题目的大概意思是：对于8 <em> x </em>x <em>x </em>x + 7 <em> x </em>x <em>x + 2 </em> x <em>x + 3 </em> x + 6 = y ，给定y，要在1~100范围内找到合适的x使得等式成立。</p><p>可以用二分，也可以用牛顿迭代。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <bits/stdc++.h>//#include <iomanip>using std::cin;using std::cout;using std::endl;double y;const double EPS = 1e-6;//#define F(x) 8 * x *x *x *x + 7 * x *x *x + 2 * x *x + 3 * x + 6 - y//#define F1(x) 32 * x *x *x + 21 * x *x + 4 * x + 3#define F(x) 8 * x *x *x *x + 7 * x *x *x + 2 * x *x + 3 * x + 6 - y#define F1(x) 32 * x *x *x + 21 * x *x + 4 * x + 3double Newton(double x) {  int k = 1;  while (fabs(F(x)) > EPS) {    x -= (F(x)) / (F1(x));    k++;    if (k > 30)      return -1;  }  return x;}int main() {  std::ios::sync_with_stdio(false);  cin.tie(0);  cout.tie(0);  cout << std::fixed;  int T;  cin >> T;  while (T--) {    cin >> y;    double z;    bool flag = false;    for (double i = 0.0; i < 100; i++) {      z = Newton(i);      if (z <= 100 && z >= 0) {        flag = true;        break;      }    }    if (flag==false) {      cout << "No solution!" << endl;    } else {      cout << std::setprecision(4) << z << endl;    }  }  return 0;}</code></pre><p>更详细的请参考：</p><p><a href="https://www.matongxue.com/madocs/205/">https://www.matongxue.com/madocs/205/</a></p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数筛选法</title>
      <link href="2020/05/12/hdu/2020/su-shu-shai-xuan-fa/"/>
      <url>2020/05/12/hdu/2020/su-shu-shai-xuan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="朴素检测"><a href="#朴素检测" class="headerlink" title="朴素检测"></a>朴素检测</h2><p>一般我们判断某个区间中的的素数，都是直接循环遍历，进行判断。</p><p>这样的话，时间复杂度就是 $O(n \sqrt{n})$ </p><p>代码如下:</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <cmath>#include <iostream>bool IsPrime(int n) {  int k = sqrt(n);  for (int i = 2; i <= k; i++) {    if (n % i == 0) return false;  }  return true;}int main() {  int n;  std::cin >> n;  for (int i = 2; i <= n; ++i) {    if (IsPrime(i)) {      std::cout << i << " is prime\n";    }  }  return 0;}</code></pre><h2 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h2><p>时间复杂度 $O(n\log\log n)$</p><p>推导过程：<a href="https://oi-wiki.org/math/sieve/">筛法</a></p><p>用了素数的倍数一定不是素数的思想。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <iostream>using namespace std;const int maxn = 100;int is_prime[maxn + 1];int prime[maxn + 1];int Eratosthenes(int n, int m) {  int p = 0;  for (int i = 0; i <= n; ++i) is_prime[i] = 1;  is_prime[0] = is_prime[1] = 0;  for (int i = 2; i <= n; ++i) {    if (is_prime[i]) {      if (i >= m) {        prime[p++] = i;      }      if ((long long)i * i <= n)        for (int j = i * i; j <= n; j += i) {          is_prime[j] = 0;        }    }  }  return p;}int main() {  ios::sync_with_stdio(false);  cin.tie(0);  cout.tie(0);  int n, m;  cin >> m >> n;  int count = Eratosthenes(n, m);  cout << "The number of prime Numbers is: " << count << endl;  for (int i = 0; i < count; ++i) {    cout << prime[i] << " is prime\n";  }  return 0;}</code></pre><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><p>时间复杂度进一步优化 $O(n)$</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <algorithm>#include <cstring>#include <iostream>#include <vector>using namespace std;const int N = 100;vector<int> prime;bool isprime[N];int Euler(int n, int m) {  memset(isprime, true, sizeof(isprime));  for (int i = 2; i < n; i++) {    if (isprime[i]) {      if (i >= m) {        prime.push_back(i);      }    }    for (int j = 0; j < (int)prime.size() && prime[j] * i < n; j++) {      isprime[prime[j] * i] = false;      if (i % prime[j] == 0) {        break;      }    }  }  return prime.size();}int main() {  ios::sync_with_stdio(false);  cin.tie(0);  cout.tie(0);  int n, m;  cin >> m >> n;  int count = Euler(n, m);  cout << "The number of prime Numbers is: " << count << endl;  for (int i = 0; i < count; ++i) {    cout << prime[i] << " is prime\n";  }  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辗转相除法和更相减损术</title>
      <link href="2020/05/12/hdu/2020/zhan-zhuan-xiang-chu-fa-he-geng-xiang-jian-sun-zhu/"/>
      <url>2020/05/12/hdu/2020/zhan-zhuan-xiang-chu-fa-he-geng-xiang-jian-sun-zhu/</url>
      
        <content type="html"><![CDATA[<p>高中学过的求大公约数的方法就是辗转相除法和更相减损术了。</p><p>辗转相除法递归版</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using std::cin;using std::cout;using std::endl;int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }int main() {  int n, m;  cin >> n >> m;  cout << gcd(n, m) << endl;  return 0;}</code></pre><p>非递归</p><pre class=" language-lang-c"><code class="language-lang-c">#include <iostream>using std::cin;using std::cout;using std::endl;int gcd(int a, int b) {  int temp;  while (b > 0) {    temp = a % b;    a = b;    b = temp;  }  return a;}int main() {  int n, m;  cin >> n >> m;  cout << gcd(n, m) << endl;  return 0;}</code></pre><p>更相减损术</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using std::cin;using std::cout;using std::endl;int main() {  int a, b;  cin >> a >> b;  while (a != b) {    if (a > b) {      a -= b;    } else {      b -= a;    }  }  cout << a << endl;  return 0;}</code></pre><p>比较：<br>更相减损术和辗转相除法的主要区别在于前者所使用的运算是“减”，后者是“除”。从算法思想上看，两者并没有本质上的区别，但是在计算过程中，如果遇到一个数很大，另一个数比较小的情况，可能要进行很多次减法才能达到一次除法的效果，从而使得算法的时间复杂度退化为O(N)，其中N是原先的两个数中较大的一个。相比之下，辗转相除法的时间复杂度稳定于O(logN)。</p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++二维vector使用</title>
      <link href="2020/05/11/c/2020/c-er-wei-vector-shi-yong/"/>
      <url>2020/05/11/c/2020/c-er-wei-vector-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><strong><em>你再不来，我要下雪了。</em></strong></p><p> 记录下二维vector的遍历（输出）<br> <em>注：二维vector的赋值不能跟二维数组一样用scanf或者cin写入</em></p><p> <strong><font color="#0099ff">遍历（迭代器）</font></strong><br> <em>方法一</em></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void print() {  vector<vector<char>>::iterator it;  vector<char>::iterator iter;  vector<char> ch;  for(it = res.begin(); it != res.end(); ++it) {    ch = *it;    for (iter = ch.begin(); iter != ch.end(); ++iter) {      cout << *iter << " ";    }  }  cout << endl;}</code></pre><p> <em>方法二</em></p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> void print() {  for (int i = 0; i < res.size(); ++i) {      for (int j = 0; j < res[0].size(); ++j) {          cout << res[i][j] << " ";      }  }  cout << endl;}</code></pre><p> <strong><em>才疏学浅，望雅正！</em></strong></p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能头包含的头文件</title>
      <link href="2020/05/11/c/2020/wan-neng-tou-bao-han-de-tou-wen-jian/"/>
      <url>2020/05/11/c/2020/wan-neng-tou-bao-han-de-tou-wen-jian/</url>
      
        <content type="html"><![CDATA[<pre class=" language-lang-cpp"><code class="language-lang-cpp">// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2018 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library.  This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// <http://www.gnu.org/licenses/>./** @file stdc++.h *  This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include <cassert>#endif#include <cctype>#include <cerrno>#include <cfloat>#include <ciso646>#include <climits>#include <clocale>#include <cmath>#include <csetjmp>#include <csignal>#include <cstdarg>#include <cstddef>#include <cstdio>#include <cstdlib>#include <cstring>#include <ctime>#if __cplusplus >= 201103L#include <ccomplex>#include <cfenv>#include <cinttypes>#include <cstdalign>#include <cstdbool>#include <cstdint>#include <ctgmath>#include <cuchar>#include <cwchar>#include <cwctype>#endif// C++#include <algorithm>#include <bitset>#include <complex>#include <deque>#include <exception>#include <fstream>#include <functional>#include <iomanip>#include <ios>#include <iosfwd>#include <iostream>#include <istream>#include <iterator>#include <limits>#include <list>#include <locale>#include <map>#include <memory>#include <new>#include <numeric>#include <ostream>#include <queue>#include <set>#include <sstream>#include <stack>#include <stdexcept>#include <streambuf>#include <string>#include <typeinfo>#include <utility>#include <valarray>#include <vector>#if __cplusplus >= 201103L#include <array>#include <atomic>#include <chrono>#include <codecvt>#include <condition_variable>#include <forward_list>#include <future>#include <initializer_list>#include <mutex>#include <random>#include <ratio>#include <regex>#include <scoped_allocator>#include <system_error>#include <thread>#include <tuple>#include <typeindex>#include <type_traits>#include <unordered_map>#include <unordered_set>#endif#if __cplusplus >= 201402L#include <shared_mutex>#endif#if __cplusplus >= 201703L#include <charconv>#include <filesystem>#endif</code></pre>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const int p 和 int const p</title>
      <link href="2020/05/11/c/2020/const-int-p-he-int-const-p/"/>
      <url>2020/05/11/c/2020/const-int-p-he-int-const-p/</url>
      
        <content type="html"><![CDATA[<p>主要讲下这两者的区别及用法！<br><br><strong>高能区</strong></p><blockquote><p>const int<em> p 和 int const</em> p是完全等价的！<br>const int<em> const p 和 int const const</em> p 是完全等价的！</p></blockquote><p>下面举几个例子来分析：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int x = 100, y = 100;const int* p = &x;int* const m = &y;p = &y;                //正确的，但是不要忘记&符号，因为此时的p代表的是地址！*p = 10;            //错误！*p是常量！*m = 100;            //正确，此时不要加&，因为此时的*x指的是x这个地址存放的变量！m = &y;                //错误！x是常量//如果是const int* const p;那么既不能修改*p也不能修改p</code></pre><p>看看这些变量的关系！<br>| 变量名 | 存储地址 | 存储内容 |<br>| ——— | ———— | ———— |<br>| x      | &amp;x       | 100      |<br>| p      | &amp;p       | &amp;x       |<br>| m      | &amp;p       | &amp;x       |</p><p><em>从本质了解指针，可以学下汇编，或者读读《C和指针》这本书！</em><br><br>才疏学浅，望雅正！</p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于memset</title>
      <link href="2020/05/11/c/2020/guan-yu-memset/"/>
      <url>2020/05/11/c/2020/guan-yu-memset/</url>
      
        <content type="html"><![CDATA[<p>被不了解memset狠狠的坑了一把，难受。</p><p>对于整型数组，若要是初始化为非0的值时应该使用for循环，<br>字符型或0，用memset即可。</p><p>例如：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include<bits/stdc++.h>int main(){    int s[100];    memset(s,1,sizeof(s));    for(int i=0;i<100;i++)        std::cout<<s[i]<<" ";    return 0;}</code></pre><p>这样子是达不到预期效果的，因为memset函数的作用是把一整块内存区域全部填充为某个特定的值，填充的时候是一个字节一个字节进行填充的。<br>参考：<br><a href="https://blog.csdn.net/melody_1016/article/details/83479778">https://blog.csdn.net/melody_1016/article/details/83479778</a><br><br><a href="http://www.cplusplus.com/reference/cstring/memset/">http://www.cplusplus.com/reference/cstring/memset/</a></p><p>对于字符型：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include<bits/stdc++.h>int main(){    char s[100];    memset(s,'1',sizeof(s)/sizeof(s[0]));    for(int i=0;i<100;i++)        std::cout<<s[i]<<" ";    return 0;}</code></pre><p>用memset是可以的。<br>初始化数组还可以用C++的fill或者fill_n</p><p>fill:</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include<bits/stdc++.h>int main(){    int s[100];    std::fill(s,s+100,11111);    for(int i=0;i<100;i++)        std::cout<<s[i]<<" ";    return 0;}</code></pre><p>fill_n:</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include<bits/stdc++.h>int main(){    int s[100];    std::fill_n(s,100,11111);//第一个是数组名，第二个是个数，第三个是填充值    for(int i=0;i<100;i++)        std::cout<<s[i]<<" ";    return 0;}</code></pre><p>详情请参考：<br><br><a href="http://www.cplusplus.com/reference/algorithm/fill_n/?kw=fill_n">http://www.cplusplus.com/reference/algorithm/fill_n/?kw=fill_n</a><br><a href="http://www.cplusplus.com/reference/algorithm/fill/?kw=fill">http://www.cplusplus.com/reference/algorithm/fill/?kw=fill</a></p>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学map的各种操作</title>
      <link href="2020/05/11/c/2020/chu-xue-map-de-ge-chong-cao-zuo/"/>
      <url>2020/05/11/c/2020/chu-xue-map-de-ge-chong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<pre class=" language-lang-cpp"><code class="language-lang-cpp">/* * @Author: incipe * @Date: 2019-09-22 23:14:53 * @LastEditTime: 2019-10-21 21:35:58 * @LastEditors: Please set LastEditors * @Description: In User Settings Edit * @FilePath: */#include <cmath>#include <fstream>#include <iostream>#include <map>#include <utility>std::map<std::string, std::string> mp;void init() { //输出，初始化  using namespace std;  ofstream file;  file.open("1.txt");  map<string, string>::iterator it;  for (it = mp.begin(); it != mp.end(); it++)    file << it->first << " " << it->second << endl;  file.close();}void Find() { //查找学生  using namespace std;  cout << "请输入要查找人的学号:";  string id;  cin >> id;  map<string, string>::iterator it;  it = mp.find(id);  if (it == mp.end()) {    cout << "查无此人！" << endl;  } else {    cout << "查找成功！" << endl;    cout << "他的名字是:" << it->second << endl;  }}void alter() { //删除学生信息  using namespace std;  // std::ofstream file;  // file.open("1.txt");  cout << "请输入要修改的学号：";  string id;  cin >> id;  map<string, string>::iterator it;  it = mp.find(id);  if (it != mp.end()) {    cout << "查找成功，名字是：" << it->second;    cout << "\n是否删除? yes:no: ";    string temp;    while (1) {      cin >> temp;      if (temp == "yes" || temp == "YES") {        mp.erase(id);        init();        cout << "删除成功！" << endl;        break;        // file.close();      } else if (temp == "no" || temp == "NO") {        cout << "您已经取消修改" << endl;        break;      } else {        cout << "输入非法，请重新输入!" << endl;        continue;      }    }  } else {    cout << "没有这个人！" << endl;  }}void print() { //打印学生信息  using namespace std;  // ifstream file;  // file.open("1.txt");  cout << "如下所示：" << endl;  map<string, string>::iterator it;  for (it = mp.begin(); it != mp.end(); it++) {    cout << it->first << " " << it->second << endl;  }  // file.close();}void Insert() { //插入学生信息  using namespace std;  map<string, string>::iterator it;  cout << "请输入要插入同学的学号：";  string temp1, temp2;  while (1) {    cin >> temp1;    it = mp.find(temp1);    if (it != mp.end()) {      cout << "此学号已经存在了，请重新输入！" << endl;      continue;    } else {      break;    }  }  cout << "请输入要插入同学的姓名：";  cin >> temp2;  mp.insert(make_pair(temp1, temp2));  init();}int main() {  using namespace std;  mp["xxxxxxxx00"] = "xx1";  mp["xxxxxxxx01"] = "xx2";  mp["xxxxxxxx02"] = "xx3";  mp["xxxxxxxx03"] = "xx4";  mp["xxxxxxxx04"] = "xx5";  // ios::sync_with_stdio(false);  // cin.tie(0);  // cout.tie(0);  cout << "欢迎来到XXXXXX班级管理系统！" << endl;  init();  cout << "生成班级成员数据成功！" << endl;  while (1) {    cout << "1:查找" << endl;    cout << "2:删除" << endl;    cout << "3:插入" << endl;    cout << "4:打印" << endl;    cout << "5.退出" << endl;    cout << "6.清屏" << endl;    cout << "请选择:";    int n;    cin >> n;    if (n == 5) {      cout << "感谢您的使用，祝您生活愉快！" << endl;      break;    }    switch (n) {    case 1:      Find();      break;    case 2:      alter();      break;    case 3:      Insert();      break;    case 4:      print();      break;    case 6:      system("cls");      break;    default:      cout << "输入非法！" << endl;      continue;    }  }  cin.get();  return 0;}// map是自动排序的，数字按大小，字符串按字典顺序</code></pre>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种二叉树（递归）</title>
      <link href="2020/05/11/c/2020/ge-chong-er-cha-shu-di-gui/"/>
      <url>2020/05/11/c/2020/ge-chong-er-cha-shu-di-gui/</url>
      
        <content type="html"><![CDATA[<p>为了方便粘贴，就没有放多文件编译。<br>感谢leetcode的题库！<br>要实现归并二叉树，自己要稍微更改下代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include<bits/stdc++.h>using std::cin;using std::cout;using std::endl;const int MAX = 10;struct BiTree {    char data;    struct BiTree* left, * right;};//创建二叉树，以#结束void CreatBiTree(BiTree*& T) {    char ch;    ch = getchar();    if (ch == '#')T = nullptr;    else {        T = new BiTree;        T->data = ch;        CreatBiTree(T->left);        CreatBiTree(T->right);    }}//先序遍历二叉树,先序遍历就是:根->左子树->右子树void PreOrderTraverse(BiTree*& T) {    if (T) {        cout << T->data << " ";        PreOrderTraverse(T->left);        PreOrderTraverse(T->right);    }    else {        cout << "";    }}//中序遍历二叉树,中序遍历就是:左子树->根->右子树void InoderTraverse(BiTree*& T) {    if (T) {        InoderTraverse(T->left);        cout << T->data<<" ";        InoderTraverse(T->right);    }    else {        cout << "";    }}//后序遍历二叉树,后续遍历就是:左子树->右子树->根void PosoderTraverse(BiTree*& T) {    if (T) {        PosoderTraverse(T->left);        PosoderTraverse(T->right);        cout << T->data << " ";    }    else {        cout << "";    }}void LevleOrder(BiTree* T) {    BiTree* Queue[MAX], *b;    int front, rear;    front = rear = 0;    if (T) {        Queue[rear++] = T;        while (front != rear) {            b = Queue[front++];            cout << b->data << " ";            if (b->left != nullptr)Queue[rear++] = b->left;            if (b->right != nullptr)Queue[rear++] = b->right;        }    }}//求二叉树的深度:递归解决,先遍历左子树,再遍历右子树,大的+1int BiTreeDepth(BiTree* T) {    if (T == nullptr)        return 0;    int left, right;    left = BiTreeDepth(T->left);    right = BiTreeDepth(T->right);    return left > right ? left + 1 : right + 1;}/*判断二叉树是否为平衡二叉树,平衡二叉树应满足以下三个条件:1.左子树是平衡二叉树2.右子树是平衡二叉树3.左右子树之间的深度不超过1*//*int countFloor(BiTree* T) {    if (!T)        return 0;    int left, right;    left = countFloor(T->left);    right = countFloor(T->right);    return left > right ? left + 1 : right + 1;}//注意到这个函数跟求二叉树深度的函数一样,即可省略.*/bool IsBalanced(BiTree* T) {    if (!T)        return true;    if (abs(BiTreeDepth(T->left) - BiTreeDepth(T->right)) > 1) {        return false;    }//判断左子树与右子树的高度差    else {        if (IsBalanced(T->left) && IsBalanced(T->right)) {            return true;        }        else {            return false;        }    }//判断左子树与右子树是不是平衡二叉树}/*判断二叉树是不是对称二叉树列如:[1,2,2,3,4,4,3](层次遍历)就是对称二叉树,从根节点开始递归,判断左子树是不是等于右子树.*/bool IsMirror(BiTree* q,BiTree*    p) {    if (q==nullptr&&p==nullptr)        return true;//左右子树为空    if (q == nullptr || p == nullptr)        return false;//左右子树高度不等    if (q->data == p->data) {        return IsMirror(q->left, p->right) && IsMirror(q->right, p->left);    }//递归判断节点值是否相等    return false;}bool IsSymmetric(BiTree* T) {    return IsMirror(T, T);}//二叉树的最小深度int MinDepth(BiTree* T) {    if (T == nullptr)        return 0;    int left, right;    left = MinDepth(T->left);    right = MinDepth(T->right);    if (left > 0 && right > 0)        return left > right ? right + 1 : left + 1;//如果左右子树都不为空,这样子做是可以的.    return left = 0 ? right + 1 : left + 1;//如果左右子树有"空树",比如[1,2],[1,null,2,null,null,3,4](层次遍历)}//翻转二叉树struct BiTree* invertTree(BiTree* T) {    if (T == nullptr)        return T;    struct BiTree* p;    p = T->left;    T->left = invertTree(T->right);    T->right = invertTree(p);    return T;}void BiTreeCopy(BiTree* T, BiTree*& NewT) {    if (T == nullptr) {        NewT = nullptr;        return;    }    else {        NewT = new BiTree;        NewT->data = T->data;        BiTreeCopy(T->left, NewT->left);        BiTreeCopy(T->right, NewT->right);    }}/*合并二叉树大概意思是，给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。比如:二叉树[1,3,2,5,null,null,null],[2,1,3,null,4,null,7](层次遍历)合并后为[3,4,5,5,4,null,7]*/struct BiTree* mergeTrees(BiTree* t1,BiTree* t2) {    if (t1 == nullptr)        return t2;    if (t2 == nullptr)        return t1;    t1->data = t1->data + t2->data;    t1->left = mergeTrees(t1->left, t2->left);    t1->right = mergeTrees(t1->right, t2->right);    return t1;}int main() {    struct BiTree* T,*NewT=nullptr;//*t1,*t2;    CreatBiTree(T);    /*CreatBiTree(t1);    CreatBiTree(t2);    mergeTrees(t1, t2);    cout << "\n合并的二叉树为(层次遍历）：" << endl;    LevleOrder(t1);*/    cout << "\n创建二叉树成功！" << endl;    cout << "先序遍历为：" << endl;    PreOrderTraverse(T);    cout << "\n中序遍历为：" << endl;    InoderTraverse(T);    cout << "\n后序遍历为：" << endl;    PosoderTraverse(T);    cout << "\n层次遍历为：" << endl;    LevleOrder(T);    cout << "\n二叉树深度为：" << BiTreeDepth(T) << endl;    if (IsBalanced(T)) {        cout << "BiTree is Banlanced Tree !" << endl;    }    else {        cout << "BiTree is't Banlanced Tree !" << endl;    }    if (IsSymmetric(T)) {        cout << "BiTree is Symmetric Tree !" << endl;    }    else {        cout << "BiTree is't Symmetric Tree !" << endl;    }    cout << "二叉树最小深度为："<< MinDepth(T) << endl;    invertTree(T);    cout << "翻转的二叉树为(层次遍历）：" << endl;    LevleOrder(T);    BiTreeCopy(T, NewT);    cout << "\n复制的二叉树为(层次遍历）：" << endl;    LevleOrder(NewT);    cout << endl;    cin.get();    return 0;}</code></pre>  <valine></valine>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
